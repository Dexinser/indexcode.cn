---
title: JavaScript之V8引擎
tags: JavaScript
categories: 认知提升
---
**{{title}}**     <Excerpt in index | 首页摘要>
V8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用于Google Chrome中。
V8在执行之前将JavaScript代码编译成机器码让计算机识别执行，而非字节码或者直译它，以此来提升效能，JavaScript程序与V8引擎的速度可以媲美二进制编译。在高性能JavaScript一书中作者有比较V8引擎与其他语言的执行速度，作者列成了图表很清楚的显示出JavaScript引擎V8不俗的执行速度。

V8是Google Chrome浏览器内置的JavaScript脚本引擎。
Google Chrome使用V8的API，但引擎的内核部分是独立于浏览器之外的。
V8引擎编译和执行JavaScript源代码。
速度是V8引擎追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码 + 解释器”的引擎，优势不言而喻。
V8引擎的团队说Chrome对脚本的解析和执行速度是Firefox和Safari的10倍，是IE的56倍。当然了，自夸自家的瓜甜，都是这样的嘛~最近不是新出了Safari又比Google Chrome快了80%的速度吗~但是只是因为Safari更新的比较快，优化了最新的ES6，所以与之前未做优化的Chrome相比快了不少~也是真能吹牛哈~

***
正是由于V8的高性能，所以基于nodejs开发的引擎就是V8引擎。
***

V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。V8的JavaScript渲染引擎亮点在于更快速更强壮的JavaScript解析。V8是一个非常反传统的JavaScript引擎，它能够在后台动态的对JS的对象进行分类——一个在其他高级语言中很常见但JS本身不支持的特性。V8对JS的解析不是基于反复loop源代码进行解释而是直接将JS代码编译成机器码运行。换句话说，V8引擎实际上可以看做是JS的扩展和编译器——而传统上类似于JS的解释型语言恰恰是不需要编译器的。最后，高级语言的内存管理效能一直是决定其运行效率的重要因素，而当前的JS虚拟机在这方面做的比较基本，对内存的回收也非常保守。V8使用的是非常强势的内存管理策略，一切在运行堆栈里无用的数据都会被强行回收，从而可以大大提高JS代码的运行效率。
在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。

和Mozilla的SpiderMonkey一样，Google Chrome浏览器的JavaScript引擎Google V8也是一个开源的独立引擎，可内嵌于任何C++工程之中。

>速度是V8追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码+解释器”的引擎，优势不言而喻。在SunSpider测试中，V8的综合表现是最好的。据说Mozilla正在开发的TraceMonkey比V8还要快20%左右，可惜尚未完工。

# JavaScript的发展
>Netscape Navigator 在 90 在年代中期对 JavaScript 进行了集成，这让网页开发人员对 HTML 页面中诸如 form 、frame 和 image 之类的元素的访问变得非常容易。由此 JavaScript 很快成为了用于定制控件和添加动画的工具，到 90 年代后期的时候，大部分的 JavaScript 脚本仅仅完成像“根据用户的鼠标动作把一幅图换成另一幅图”这样简单的功能。
 
>随着最近 AJAX 技术的兴起，JavaScript 现在已经变成了实现基于 web 的应用程序（例如我们自己的 Gmail）的核心技术。JavaScript 程序从聊聊几行变成数百 KB 的代码。JavaScript 被设计于完成一些特定的任务，虽然 JavaScript 在做这些事情的时候通常都很高效，但是性能已经逐渐成为进一步用 JavaScript 开发复杂的基于 web 的应用程序的瓶颈。
 
>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。其中的原因在你读过这份文档余下的部分之后就会明白了。
 
# V8 的性能提升主要来自三个关键部分：
1. 快速属性访问
2. 动态机器码生成
3. 高效的垃圾收集

## 快速属性访问
JavaScript 是一门动态语言，属性可以在运行时添加到或从对象中删除。这意味着对象的属性经常会发生变化。大部分 JavaScript 引擎都使用一个类似于字典的数据结构来存储对象的属性，这样每次访问对象的属性都需要进行一次动态的字典查找来获取属性在内存中的位置。这种实现方式让 JavaScript 中属性的访问比诸如 Java 和 Smalltalk 这样的语言中的成员变量的访问慢了许多。成员变量在内存中的位置离对象的地址的距离是固定的，这个偏移量由编译器在编译的时候根据对象的类的定义决定下来。因此对成员变量的访问只是一个简单的内存读取或写入的操作，通常只需要一条指令即可。
 
为了减少 JavaScript 中访问属性所花的时间，V8 采用了和动态查找完全不同的技术来实现属性的访问：动态地为对象创建隐藏类。这并不是什么新的想法，基于原型的编程语言 Self 就用 map 来实现了类似的功能（参见 An Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language Based on Prototypes ）而且JavaScript在创建之初因为是赶时间赶出来的（10天的时间，而且还是Brendan Eich为了应付公司安排的任务的~），所以也正是借鉴了很多语言的长处，也就是上面所说的self语言和C语言等等（有一句话说的好：与其说我爱JavaScript，不如说我恨她；她是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：“她的优秀之处并非原创，她的原创之处并不优秀”）。在 V8 里，当一个新的属性被添加到对象中时，对象所对应的隐藏类会随之改变。
 
下面我们用一个简单的 JavaScript 函数来加以说明：
 
`function Point(x, y) {
    this.x = x;
    this.y = y;
}`
 
当 new Point(x, y) 执行的时候，一个新的 Point 对象会被创建出来。如果这是 Point 对象第一次被创建，V8 会为它初始化一个隐藏类，不妨称作 C0。因为这个对象还没有定义任何属性，所以这个初始类是一个空类。到这个时候为止，对象 Point 的隐藏类是 C0。
 
map_trans_a
执行函数 Point 中的第一条语句（this.x = x;）会为对象 Point 创建一个新的属性 x。此时，V8 会：
在 C0 的基础上创建另一个隐藏类 C1，并将属性 x 的信息添加到 C1 中：这个属性的值会被存储在距 Point 对象的偏移量为 0 的地方。
在 C0 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 x 之后能够找到 C1 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C1。
1. map_trans_b
执行函数 Point 中的第二条语句（this.y = y;）会添加一个新的属性 y 到对象 Point 中。同理，此时 V8 会：
在 C1 的基础上创建另一个隐藏类 C2，并在 C2 中添加关于属性 y 的信息：这个属性将被存储在内存中离 Point 对象的偏移量为 1 的地方。
在 C1 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 y 之后能够找到 C2 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C2。
2. map_trans_c
咋一看似乎每次添加一个属性都创建一个新的隐藏类非常低效。实际上，利用类转移信息，隐藏类可以被重用。下次创建一个 Point 对象的时候，就可以直接共享由最初那个 Point 对象所创建出来的隐藏类。例如，如果又一个 Point 对象被创建出来了：
一开始 Point 对象没有任何属性，它的隐藏类将会被设置为 C0。
当属性 x 被添加到对象中的时候，V8 通过 C0 到 C1 的类转移信息将对象的隐藏类更新为 C1 ，并直接将 x 的属性值写入到由 C1 所指定的位置（偏移量 0）。
当属性 y 被添加到对象中的时候，V8 又通过 C1 到 C2 的类转移信息将对象的隐藏类更新为 C2，并直接将 y 的属性值写入到由 C2 所指定的位置（偏移量 1）。

尽管 JavaScript 比通常的面向对象的编程语言都要更加动态一些，然而大部分的 JavaScript 程序都会表现出像上述描述的那样的运行时高度结构重用的行为特征来。使用隐藏类主要有两个好处：属性访问不再需要动态字典查找了；为 V8 使用经典的基于类的优化和内联缓存技术创造了条件。

## 动态机器码生成
V8 在第一次执行 JavaScript 代码的时候会将其直接编译为本地机器码，而不是使用中间字节码的形式，因此也没有解释器的存在。属性访问由内联缓存代码来完成，这些代码通常会在运行时由 V8 修改为合适的机器指令。
 
在第一次执行到访问某个对象的属性的代码时，V8 会找出对象当前的隐藏类。同时，V8 会假设在相同代码段里的其他所有对象的属性访问都由这个隐藏类进行描述，并修改相应的内联代码让他们直接使用这个隐藏类。当 V8 预测正确的时候，属性值的存取仅需一条指令即可完成。如果预测失败了，V8 会再次修改内联代码并移除刚才加入的内联优化。
 
例如，访问一个 Point 对象的 x 属性的代码如下：
 
point.x
 
在 V8 中，对应生成的机器码如下：
 
`; ebx = the point objectcmp [ebx, <hidden class offset>], <cached hidden class>
jne <inline cache miss>
mov eax, [ebx, <cached x offset>]`
 
如果对象的隐藏类和缓存的隐藏类不一样，执行会跳转到 V8 运行系统中处理内联缓存预测失败的地方，在那里原来的内联代码会被修改以移除相应的内联缓存优化。如果预测成功了，属性 x 的值会被直接读出来。
 
当有许多对象共享同一个隐藏类的时候，这样的实现方式下属性的访问速度可以接近大多数动态语言。使用内联缓存代码和隐藏类实现属性访问的方式和动态代码生成和优化的方式结合起来，让大部分 JavaScript 代码的运行效率得以大幅提升。

## 高效的垃圾回收机制
V8 会自动回收不再被对象使用的内存，这个过程通常被称为“垃圾收集（Garbage Collection）”。为了保证快速的对象分配和缩短由垃圾收集造成的停顿，并杜绝内存碎片，V8 使用了一个 stop-the-world, generational, accurate 的垃圾收集器，换句话说，V8 的垃圾收集器：

1. 在执行垃圾回收的时候会中断程序的执行。
2. 大部分情况下，每个垃圾收集周期只处理整个对象堆的一部分，这让程序中断造成的影响得以减轻。
3. 总是知道内存中所有的对象和指针所在的位置，这避免了非 accurate 的垃圾收集器中普遍存在的由于错误地把对象当作指针而造成的内存溢出的情况。

在 V8 中，对象堆被分成两部分：用于为新创建的对象分配空间的部分和用于存放在垃圾收集周期中生存下来的那些老的对象的部分。如果一个对象在垃圾收集的过程中被移动了，V8 会更新所有指向这个对象的指针到新的地址。