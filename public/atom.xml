<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>To die or not to die, this is a question~</title>
  
  <subtitle>不想成为架构师的程序员不是一个好的程序员~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://indexcode.cn/"/>
  <updated>2019-02-23T10:46:16.891Z</updated>
  <id>http://indexcode.cn/</id>
  
  <author>
    <name>Dexinser</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript之V8引擎</title>
    <link href="http://indexcode.cn/2017/11/JavaScript%E4%B9%8BV8%E5%BC%95%E6%93%8E.html"/>
    <id>http://indexcode.cn/2017/11/JavaScript之V8引擎.html</id>
    <published>2019-02-23T10:46:16.889Z</published>
    <updated>2019-02-23T10:46:16.891Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JavaScript之V8引擎</strong>     <Excerpt in index | 首页摘要><br>V8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用于Google Chrome中。<br>V8在执行之前将JavaScript代码编译成机器码让计算机识别执行，而非字节码或者直译它，以此来提升效能，JavaScript程序与V8引擎的速度可以媲美二进制编译。在高性能JavaScript一书中作者有比较V8引擎与其他语言的执行速度，作者列成了图表很清楚的显示出JavaScript引擎V8不俗的执行速度。</p><p>V8是Google Chrome浏览器内置的JavaScript脚本引擎。<br>Google Chrome使用V8的API，但引擎的内核部分是独立于浏览器之外的。<br>V8引擎编译和执行JavaScript源代码。<br>速度是V8引擎追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码 + 解释器”的引擎，优势不言而喻。<br>V8引擎的团队说Chrome对脚本的解析和执行速度是Firefox和Safari的10倍，是IE的56倍。当然了，自夸自家的瓜甜，都是这样的嘛~最近不是新出了Safari又比Google Chrome快了80%的速度吗~但是只是因为Safari更新的比较快，优化了最新的ES6，所以与之前未做优化的Chrome相比快了不少~也是真能吹牛哈~</p><hr><p>正是由于V8的高性能，所以基于nodejs开发的引擎就是V8引擎。</p><hr><p>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。V8的JavaScript渲染引擎亮点在于更快速更强壮的JavaScript解析。V8是一个非常反传统的JavaScript引擎，它能够在后台动态的对JS的对象进行分类——一个在其他高级语言中很常见但JS本身不支持的特性。V8对JS的解析不是基于反复loop源代码进行解释而是直接将JS代码编译成机器码运行。换句话说，V8引擎实际上可以看做是JS的扩展和编译器——而传统上类似于JS的解释型语言恰恰是不需要编译器的。最后，高级语言的内存管理效能一直是决定其运行效率的重要因素，而当前的JS虚拟机在这方面做的比较基本，对内存的回收也非常保守。V8使用的是非常强势的内存管理策略，一切在运行堆栈里无用的数据都会被强行回收，从而可以大大提高JS代码的运行效率。<br>在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。</p><p>和Mozilla的SpiderMonkey一样，Google Chrome浏览器的JavaScript引擎Google V8也是一个开源的独立引擎，可内嵌于任何C++工程之中。</p><blockquote><p>速度是V8追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码+解释器”的引擎，优势不言而喻。在SunSpider测试中，V8的综合表现是最好的。据说Mozilla正在开发的TraceMonkey比V8还要快20%左右，可惜尚未完工。</p></blockquote><h1 id="JavaScript的发展"><a href="#JavaScript的发展" class="headerlink" title="JavaScript的发展"></a>JavaScript的发展</h1><blockquote><p>Netscape Navigator 在 90 在年代中期对 JavaScript 进行了集成，这让网页开发人员对 HTML 页面中诸如 form 、frame 和 image 之类的元素的访问变得非常容易。由此 JavaScript 很快成为了用于定制控件和添加动画的工具，到 90 年代后期的时候，大部分的 JavaScript 脚本仅仅完成像“根据用户的鼠标动作把一幅图换成另一幅图”这样简单的功能。</p><p>随着最近 AJAX 技术的兴起，JavaScript 现在已经变成了实现基于 web 的应用程序（例如我们自己的 Gmail）的核心技术。JavaScript 程序从聊聊几行变成数百 KB 的代码。JavaScript 被设计于完成一些特定的任务，虽然 JavaScript 在做这些事情的时候通常都很高效，但是性能已经逐渐成为进一步用 JavaScript 开发复杂的基于 web 的应用程序的瓶颈。</p><p>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。其中的原因在你读过这份文档余下的部分之后就会明白了。</p></blockquote><h1 id="V8-的性能提升主要来自三个关键部分："><a href="#V8-的性能提升主要来自三个关键部分：" class="headerlink" title="V8 的性能提升主要来自三个关键部分："></a>V8 的性能提升主要来自三个关键部分：</h1><ol><li>快速属性访问</li><li>动态机器码生成</li><li>高效的垃圾收集</li></ol><h2 id="快速属性访问"><a href="#快速属性访问" class="headerlink" title="快速属性访问"></a>快速属性访问</h2><p>JavaScript 是一门动态语言，属性可以在运行时添加到或从对象中删除。这意味着对象的属性经常会发生变化。大部分 JavaScript 引擎都使用一个类似于字典的数据结构来存储对象的属性，这样每次访问对象的属性都需要进行一次动态的字典查找来获取属性在内存中的位置。这种实现方式让 JavaScript 中属性的访问比诸如 Java 和 Smalltalk 这样的语言中的成员变量的访问慢了许多。成员变量在内存中的位置离对象的地址的距离是固定的，这个偏移量由编译器在编译的时候根据对象的类的定义决定下来。因此对成员变量的访问只是一个简单的内存读取或写入的操作，通常只需要一条指令即可。</p><p>为了减少 JavaScript 中访问属性所花的时间，V8 采用了和动态查找完全不同的技术来实现属性的访问：动态地为对象创建隐藏类。这并不是什么新的想法，基于原型的编程语言 Self 就用 map 来实现了类似的功能（参见 An Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language Based on Prototypes ）而且JavaScript在创建之初因为是赶时间赶出来的（10天的时间，而且还是Brendan Eich为了应付公司安排的任务的~），所以也正是借鉴了很多语言的长处，也就是上面所说的self语言和C语言等等（有一句话说的好：与其说我爱JavaScript，不如说我恨她；她是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：“她的优秀之处并非原创，她的原创之处并不优秀”）。在 V8 里，当一个新的属性被添加到对象中时，对象所对应的隐藏类会随之改变。</p><p>下面我们用一个简单的 JavaScript 函数来加以说明：</p><p><code>function Point(x, y) {    this.x = x;    this.y = y;}</code></p><p>当 new Point(x, y) 执行的时候，一个新的 Point 对象会被创建出来。如果这是 Point 对象第一次被创建，V8 会为它初始化一个隐藏类，不妨称作 C0。因为这个对象还没有定义任何属性，所以这个初始类是一个空类。到这个时候为止，对象 Point 的隐藏类是 C0。</p><p>map_trans_a<br>执行函数 Point 中的第一条语句（this.x = x;）会为对象 Point 创建一个新的属性 x。此时，V8 会：<br>在 C0 的基础上创建另一个隐藏类 C1，并将属性 x 的信息添加到 C1 中：这个属性的值会被存储在距 Point 对象的偏移量为 0 的地方。<br>在 C0 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 x 之后能够找到 C1 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C1。</p><ol><li>map_trans_b<br>执行函数 Point 中的第二条语句（this.y = y;）会添加一个新的属性 y 到对象 Point 中。同理，此时 V8 会：<br>在 C1 的基础上创建另一个隐藏类 C2，并在 C2 中添加关于属性 y 的信息：这个属性将被存储在内存中离 Point 对象的偏移量为 1 的地方。<br>在 C1 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 y 之后能够找到 C2 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C2。</li><li>map_trans_c<br>咋一看似乎每次添加一个属性都创建一个新的隐藏类非常低效。实际上，利用类转移信息，隐藏类可以被重用。下次创建一个 Point 对象的时候，就可以直接共享由最初那个 Point 对象所创建出来的隐藏类。例如，如果又一个 Point 对象被创建出来了：<br>一开始 Point 对象没有任何属性，它的隐藏类将会被设置为 C0。<br>当属性 x 被添加到对象中的时候，V8 通过 C0 到 C1 的类转移信息将对象的隐藏类更新为 C1 ，并直接将 x 的属性值写入到由 C1 所指定的位置（偏移量 0）。<br>当属性 y 被添加到对象中的时候，V8 又通过 C1 到 C2 的类转移信息将对象的隐藏类更新为 C2，并直接将 y 的属性值写入到由 C2 所指定的位置（偏移量 1）。</li></ol><p>尽管 JavaScript 比通常的面向对象的编程语言都要更加动态一些，然而大部分的 JavaScript 程序都会表现出像上述描述的那样的运行时高度结构重用的行为特征来。使用隐藏类主要有两个好处：属性访问不再需要动态字典查找了；为 V8 使用经典的基于类的优化和内联缓存技术创造了条件。</p><h2 id="动态机器码生成"><a href="#动态机器码生成" class="headerlink" title="动态机器码生成"></a>动态机器码生成</h2><p>V8 在第一次执行 JavaScript 代码的时候会将其直接编译为本地机器码，而不是使用中间字节码的形式，因此也没有解释器的存在。属性访问由内联缓存代码来完成，这些代码通常会在运行时由 V8 修改为合适的机器指令。</p><p>在第一次执行到访问某个对象的属性的代码时，V8 会找出对象当前的隐藏类。同时，V8 会假设在相同代码段里的其他所有对象的属性访问都由这个隐藏类进行描述，并修改相应的内联代码让他们直接使用这个隐藏类。当 V8 预测正确的时候，属性值的存取仅需一条指令即可完成。如果预测失败了，V8 会再次修改内联代码并移除刚才加入的内联优化。</p><p>例如，访问一个 Point 对象的 x 属性的代码如下：</p><p>point.x</p><p>在 V8 中，对应生成的机器码如下：</p><p><code>; ebx = the point objectcmp [ebx, &lt;hidden class offset&gt;], &lt;cached hidden class&gt;jne &lt;inline cache miss&gt;mov eax, [ebx, &lt;cached x offset&gt;]</code></p><p>如果对象的隐藏类和缓存的隐藏类不一样，执行会跳转到 V8 运行系统中处理内联缓存预测失败的地方，在那里原来的内联代码会被修改以移除相应的内联缓存优化。如果预测成功了，属性 x 的值会被直接读出来。</p><p>当有许多对象共享同一个隐藏类的时候，这样的实现方式下属性的访问速度可以接近大多数动态语言。使用内联缓存代码和隐藏类实现属性访问的方式和动态代码生成和优化的方式结合起来，让大部分 JavaScript 代码的运行效率得以大幅提升。</p><h2 id="高效的垃圾回收机制"><a href="#高效的垃圾回收机制" class="headerlink" title="高效的垃圾回收机制"></a>高效的垃圾回收机制</h2><p>V8 会自动回收不再被对象使用的内存，这个过程通常被称为“垃圾收集（Garbage Collection）”。为了保证快速的对象分配和缩短由垃圾收集造成的停顿，并杜绝内存碎片，V8 使用了一个 stop-the-world, generational, accurate 的垃圾收集器，换句话说，V8 的垃圾收集器：</p><ol><li>在执行垃圾回收的时候会中断程序的执行。</li><li>大部分情况下，每个垃圾收集周期只处理整个对象堆的一部分，这让程序中断造成的影响得以减轻。</li><li>总是知道内存中所有的对象和指针所在的位置，这避免了非 accurate 的垃圾收集器中普遍存在的由于错误地把对象当作指针而造成的内存溢出的情况。</li></ol><p>在 V8 中，对象堆被分成两部分：用于为新创建的对象分配空间的部分和用于存放在垃圾收集周期中生存下来的那些老的对象的部分。如果一个对象在垃圾收集的过程中被移动了，V8 会更新所有指向这个对象的指针到新的地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JavaScript之V8引擎&lt;/strong&gt;     &lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;V8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用
      
    
    </summary>
    
      <category term="认知提升" scheme="http://indexcode.cn/categories/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="JavaScript" scheme="http://indexcode.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>The Tipping Point</title>
    <link href="http://indexcode.cn/2018/2018.01.28%20The%20Tipping%20Point.html"/>
    <id>http://indexcode.cn/2018/2018.01.28 The Tipping Point.html</id>
    <published>2018-01-28T04:03:24.113Z</published>
    <updated>2018-01-28T12:18:37.032Z</updated>
    
    <content type="html"><![CDATA[<p><strong> The Tipping Point：</strong> <Excerpt in index | 首页摘要></p><p>《引爆点》这本书是格拉德威尔在2000年出版的。一经出版就火爆全球，书中介绍的“引爆点”和流行三法则，已经成为当下的商业理论新经典。<br>思考是这本书的主旋律，作者对生活中的一些常见现象，并没有去听从各种专家所说的，不能让人信服的观点，例如：经济学家所说的是由于经济的好转所以就是年代的纽约市犯罪行为的减少；犯罪学家所说的是由于纽约市警察局的警力部署的加强所导致的犯罪行为的减少等等。作者深入思考了这些社会现象之后，认为那些专家所说的理由并不能成为形成这种现象的原因，进而自己来进行寻找和探索，由此而诞生的这本书，进而解读我们社会中的一些流行事件的原因，真的是让我们这些读者打开思想的大门，教给我们各种新奇规律的同时，也教给了我们思考问题的方式和方法。<br>书中的很多著名的专家学者在开篇点评这本书，看完这本书之后重新看这些评语，真是另一种感受：格拉德威尔不愧为2005年《时代》杂志评为世界最有影响力的100人之一，普通人的回答，很少能超出几个大脑早已作出的界定，如：亚当斯密的“看不见的手”、凯恩斯的“调控”、哈耶克的“自发生成秩序”、马克思的辩证唯物主义和历史唯物主义、弗洛伊德的心理分析…而变革者则提出理解世界的新方法：凯恩斯对亚当斯密进行修补；弗洛伊德另辟蹊经；毕加索挑战马蒂斯；爱因斯坦修订牛顿为大自然的“立法”，德鲁克对组织进行研究，提出“知识工人”与受雇阶层的理论。本质上，格拉德威尔与上面提到的为人是一类人，也是一个有新意的变革者。书中开创性的提出了很多名词：流行三法则（个别人物法则[联系员、内行和推销员—保罗·里维尔骑马夜行]、附着力法则[影响事情的主要原因跟我们所想的不一样，往往是很微小的因素所形成的—金盒子广告和打破伤风疫苗、芝麻街和蓝狗线索]、环境威力法则[人们往往会在心里对一个人有一种印象，而往往忽视了环境的不同造成的影响因素；而在事实与我们印象中的不同时我们又会找一个我们自己所能够理解的方式来解释，而保留对一个人印象的唯一性；思维定势中的我们往往又会夸大一些环境因素对我们的影响，例如：家庭因素对我们的影响等等，其实并没有那么大的影响—流言、破窗理论、地铁涂鸦、地铁逃票…]）</p><p>引爆点教给了我们什么道理？就像作者总结的一样总共有三个。</p><h1 id="集中有限的力量，全力以赴。"><a href="#集中有限的力量，全力以赴。" class="headerlink" title="集中有限的力量，全力以赴。"></a>集中有限的力量，全力以赴。</h1><p>我们大多数人做事，一般都是差不多的思维模式，相同的老办法。而往往这种老方法有时候并不是最优的，这种方法可能会包含着太多的浪费我们有限的资源的情况。思维定式之下，我们很难跳出这种限制，而格拉德威尔的这本书中就教给了我们很多方法，去找出事情的引爆点，往往就能付出最小的代价做成很多事情。美国独立战争时期，保罗·里维尔骑马夜行是成功的，但是另一个方向出发的威廉·戴维斯却是失败的，他没有成为历史上有名的人物…取巧之计用在这儿挺合适的，在编程中我们想要成长我们必须要取巧，各种自动化工具的使用，让电脑代替我们去处理重复繁琐的事情；在生活中取巧是我们做事情之前先要想到这件事情成功的引爆点在哪儿，尽量用最少的资源完成事情，不加选择地付出努力并非总是可行的，我们要尽可能的找到到达终点的捷径，以达到事半功倍的效果。</p><h1 id="世界并非是我们一厢情愿的直觉中的世界"><a href="#世界并非是我们一厢情愿的直觉中的世界" class="headerlink" title="世界并非是我们一厢情愿的直觉中的世界"></a>世界并非是我们一厢情愿的直觉中的世界</h1><p>我们总是在杂乱与黑暗之中行事，所以造成了很多的不必要的步骤。我们所认知的范畴限制了我们所看待世界的方式和误解我们所接触到的超出我们理解范围的事情。以抽象方式被表述成形象的社会问题，我们解决起来将会毫无困难。人类思维的特殊之处，在于我们能很好的处理同类之间复杂的关系。我们遇到问题的第一想法是先看一下我们的大脑中有没有储存以前类似的相关问题，类比之前的类似问题来进行处理现在所遇到的问题，但是我们又往往会忽略当下的条件下的不同，或是局限与我们知识储备的不足，处理当下的事情进而使用了错误的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; The Tipping Point：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;《引爆点》这本书是格拉德威尔在2000年出版的。一经出版就火爆全球，书中介绍的“引爆点”和流行三法则，已经成为当下的商业理论新经典。&lt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://indexcode.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="认知提升" scheme="http://indexcode.cn/tags/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>磁盘格式</title>
    <link href="http://indexcode.cn/2018/2018.01.21%20%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F.html"/>
    <id>http://indexcode.cn/2018/2018.01.21 磁盘格式.html</id>
    <published>2018-01-21T13:31:30.848Z</published>
    <updated>2018-01-21T14:39:41.630Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 磁盘格式：</strong> <Excerpt in index | 首页摘要></p><p>好久没更博客了，虽然没什么人看，但是作为练习自己写作能力的锻炼和提升，也不能荒废我的博客更新哈~<br>说一下我最近的个人动态吧~ 现在学校放假有两个星期了，学校一放假就跑到实习公司来实习了，一进公司报到当天就给我配置了2015年的mac pro顶配版，不得不说真是开心哈~而且是2017年产的新开封的哦~不要羡慕哦~哈哈哈，你们以后工作也会有的。然后新进公司第一周就一直在熟悉mac本的一些基础操作，没办法，谁让我没用过这种高大上的苹果笔记本呢。我是刚把Windows系统的笔记本用到稍微熟练一点儿，就让我接触mac真是有点儿不熟悉呢，不过经过一周的操作训练，越来越觉的mac的人性化，怪不得办公的大公司的白领啦、管理者啦、领导啦什么的，都喜欢用苹果本办公呢，真的比Windows好用多了，当然了，这只是我个人的一些浅显小想法，大家不同意就当我没说，我的人生阅历还是很少，不能确定说的对哈~</p><p>好了，接下来就来说一下写这篇博客的由来吧~换上了mac本之后，看到了mac自带的时间机器，感觉好高大上啊，可以自动保存快照，想什么时候回退到哪儿都行，真是太强大的一个功能了。虽然这个说是不占用mac上剩余的内存，不过我还是担心影响我的笔记本日常所使用的性能，万一影响我的使用体验都不好，在说了我也有一个自己的硬盘，为什么不用我自己的硬盘当作是Time Machien的保存磁盘呢；想到就去做了，第二天就把我的磁盘带过来了，兴致勃勃的插上去却让我失望了，居然是只能读的权限，然后我才知道Windows下的保存文件格式与mac下的保存文件格式是不同的。啊啊啊，要想用做mac的时间机器的御用磁盘必须先把磁盘数据全部格式化了，但是我的磁盘上还有好多我都珍贵的资源呢，怎么能删除掉呢，所以只能先把数据保存到其他的地方，到时候把磁盘的格式改回来在存进去。然后就又把磁盘带回去了，把数据拷贝到了我的Windows电脑上，然后在mac上把磁盘格式化了，终于能用作备份磁盘了，真是好不容易啊。但是这样的话又变成了磁盘只能在mac上用了，所以我索性把我的1T硬盘，分成3个区，一个单独的用作mac数据备份区，另两个一个用作Windows存放数据区，另一个用作mac存放数据区。这样总算大功告成了吧，谁知道原来我把Windows上使用的存放数据格式给改成了Fat32格式的，不是我想要的NTFS格式的，但是这个时候我已经把原先的数据都已经导回来了，实在不想再折腾了，啊啊啊，好伤心啊！接下来就让我介绍一下他俩的区别吧~</p><h1 id="FAT32与NTFS的区别"><a href="#FAT32与NTFS的区别" class="headerlink" title="FAT32与NTFS的区别"></a>FAT32与NTFS的区别</h1><p>在推出FAT32文件系统之前，通常PC机使用的文件系统是FAT16。像基于MS-DOS，Win 95等系统都采用了FAT16文件系统。在Win 9X下，FAT16支持的分区最大为2GB。我们知道计算机将信息保存在硬盘上称为“簇”的区域内。使用的簇越小，保存信息的效率就越高。在FAT16的情况下，分区越大簇就相应的要增大，存储效率就越低，势必造成存储空间的浪费。并且随着计算机硬件和应用的不断提高，FAT16文件系统已不能很好地适应系统的要求。在这种情况下，推出了增强的文件系统FAT32。同FAT16相比，FAT32主要具有以下特点：</p><ol><li>同FAT16相比FAT32最大的优点是可以支持的磁盘大小达到2TB（2047GB），但是不能支持小于512MB的分区。基于FAT32的Win 2000可以支持分区最大为32GB；而基于 FAT16的Win 2000支持的分区最大为4GB。</li><li>由于采用了更小的簇，FAT32文件系统可以更有效率地保存信息。如两个分区大小都为2GB，一个分区采用了FAT16文件系统，另一个分区采用了FAT32文件系统。采用FAT16的分区的簇大小为32KB，而FAT32分区的簇只有4KB的大小。这样FAT32就比FAT16的存储效率要高很多，通常情况下可以提高15%。</li><li>FAT32文件系统可以重新定位根目录和使用FAT的备份副本。另外FAT32分区的启动记录被包含在一个含有关键数据的结构中，减少了计算机系统崩溃的可能性。<br>NTFS文件系统<br>NTFS文件系统是一个基于安全性的文件系统，是Windows NT所采用的独特的文件系统结构，它是建立在保护文件和目录数据基础上，同时照顾节省存储资源、减少磁盘占用量的一种先进的文件系统。使用非常广泛的Windows NT 4.0采用的就是NTFS 4.0文件系统，相信它所带来的强大的系统安全性一定给广大用户留下了深刻的印象。Win 2000采用了更新版本的NTFS文件系统??NTFS 5.0，它的推出使得用户不但可以像Win 9X那样方便快捷地操作和管理计算机，同时也可享受到NTFS所带来的系统安全性。<br>NTFS 5.0的特点主要体现在以下几个方面：</li><li>NTFS可以支持的分区(如果采用动态磁盘则称为卷)大小可以达到2TB。而Win 2000中的FAT32支持分区的大小最大为32GB。</li><li>NTFS是一个可恢复的文件系统。在NTFS分区上用户很少需要运行磁盘修复程序。NTFS通过使用标准的事物处理日志和恢复技术来保证分区的一致性。发生系统失败事件时，NTFS使用日志文件和检查点信息自动恢复文件系统的一致性。</li><li>NTFS支持对分区、文件夹和文件的压缩。任何基于Windows的应用程序对NTFS分区上的压缩文件进行读写时不需要事先由其他程序进行解压缩，当对文件进行读取时,文件将自动进行解压缩；文件关闭或保存时会自动对文件进行压缩。</li><li>NTFS采用了更小的簇,可以更有效率地管理磁盘空间。在Win 2000的FAT32文件系统的情况下,分区大小在2GB～8GB时簇的大小为4KB；分区大小在8GB～16GB时簇的大小为8KB；分区大小在16GB～32GB时,簇的大小则达到了16KB。而Win 2000的NTFS文件系统，当分区的大小在2GB以下时,簇的大小都比相应的FAT32簇小;当分区的大小在2GB以上时(2GB～2TB),簇的大小都为4KB。相比之下，NTFS可以比FAT32更有效地管理磁盘空间，最大限度地避免了磁盘空间的浪费。</li><li>在NTFS分区上,可以为共享资源、文件夹以及文件设置访问许可权限。许可的设置包括两方面的内容：一是允许哪些组或用户对文件夹、文件和共享资源进行访问；二是获得访问许可的组或用户可以进行什么级别的访问。访问许可权限的设置不但适用于本地计算机的用户,同样也应用于通过网络的共享文件夹对文件进行访问的网络用户。与FAT32文件系统下对文件夹或文件进行访问相比，安全性要高得多。另外,在采用NTFS格式的Win 2000中,应用审核策略可以对文件夹、文件以及活动目录对象进行审核，审核结果记录在安全日志中，通过安全日志就可以查看哪些组或用户对文件夹、文件或活动目录对象进行了什么级别的操作，从而发现系统可能面临的非法访问,通过采取相应的措施，将这种安全隐患减到最低。这些在FAT32文件系统下,是不能实现的。</li><li>在Win 2000的NTFS文件系统下可以进行磁盘配额管理。磁盘配额就是管理员可以为用户所能使用的磁盘空间进行配额限制，每一用户只能使用最大配额范围内的磁盘空间。设置磁盘配额后，可以对每一个用户的磁盘使用情况进行跟踪和控制，通过监测可以标识出超过配额报警阈值和配额限制的用户，从而采取相应的措施。磁盘配额管理功能的提供，使得管理员可以方便合理地为用户分配存储资源，避免由于磁盘空间使用的失控可能造成的系统崩溃，提高了系统的安全性。</li><li>NTFS使用一个“变更”日志来跟踪记录文件所发生的变更。</li></ol><h1 id="小提示-选取FAT32和NTFS的建议"><a href="#小提示-选取FAT32和NTFS的建议" class="headerlink" title="小提示(选取FAT32和NTFS的建议)"></a>小提示(选取FAT32和NTFS的建议)</h1><p>在系统的安全性方面，NTFS文件系统具有很多FAT32文件系统所不具备的特点，而且基于NTFS的Win 2000运行要快于基于FAT32的Win 2000；而在与Win 9X的兼容性方面，FAT32优于NTFS。所以在决定Win 2000中采用什么样的文件系统时应从以下几点出发：</p><ol><li>计算机是单一的Win 2000系统，还是采用多启动的Win 2000系统；</li><li>本地安装的磁盘的个数和容量；</li><li>是否有安全性方面的考虑等。<br>基于以上的考虑，如果要在Win 2000中使用大于32GB的分区的话，那么只能选择NTFS格式。如果计算机作为单机使用，不需要考虑安全性方面的问题，更多地注重与Win 9X的兼容性，那么FAT32是最好的选择。如果计算机作为网络工作站或更多的追求系统的安全性，而且可以在单一的Win 2000模式下运行，强烈建议所有的分区都采用NTFS格式；如果要兼容以前的应用，需要安装Win 9X或其它的操作系统，建议做成多启动系统，这就需要两个以上的分区，一个分区采用NTFS格式，另外的分区采用FAT32格式，同时为了获得最快的运行速度建议将Win 2000的系统文件放置在NTFS分区上，其它的个人文件则放置在FAT32分区中。<br>回答字数10000字以内<br>参考资料：<br>如果您的回答是从其他地方引用，请表明出处。</li></ol><hr><h1 id="FAT分区与NTFS分区有什么区别？"><a href="#FAT分区与NTFS分区有什么区别？" class="headerlink" title="FAT分区与NTFS分区有什么区别？"></a>FAT分区与NTFS分区有什么区别？</h1><h2 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h2><p>在选择 NTFS 时可以使用的功能有：<br>Active Directory，可用来方便地查看和控制网络资源。<br>域，它是 Active Directory 的一部分，在简化管理的同时，依然可以使用域来调整安全选项。域控制器需要 NTFS 文件系统。<br>文件加密，它极大地增强了安全性。<br>可以对单个文件设置权限，而不仅仅是对文件夹进行设置。<br>稀疏文件，这些是由应用程序创建的非常大的文件，以这种方式创建的文件只受磁盘空间的限制。也就是，NTFS 只为写入的文件部分分配磁盘空间。<br>远程存储，通过使可移动媒体（如磁带）更易访问，从而扩展了硬盘空间。<br>磁盘活动恢复记录，可帮助您在断电或发生其他系统问题时，尽快地还原信息。<br>磁盘配额，可用来监视和控制单个用户使用的磁盘空间量。<br>可更好地支持大驱动器，NTFS 支持的最大驱动容量比 FAT 支持的容量大得多，但随着驱动器容量得增大，NTFS 的性能并不随之降低，而 FAT 的性能却急速下降。<br>这只是最新版 NTFS 的部分功能列表。有关新功能的详细信息，请参阅 Windows 2000 Advanced Server 的新特性。<br>安装程序可以方便地将分区转换为新版的 NTFS，即使该分区以前使用的是 FAT 或 FAT32 文件系统，这种转换可保持文件的完整性（与格式化分区不同）。安装程序通过从检查现有的文件系统开始运行。如果文件系统是 NTFS，转换会自动发生。如果是 FAT 或 FAT32，安装程序可让您选择是否要将它们转换为 NTFS。如果不想保留文件，且有一个 FAT 或 FAT32 分区，建议使用 NTFS 格式化该分区，而不是转换 FAT 或 FAT32 文件系统。格式化分区会删除该分区上所有的数据，但使用 NTFS 格式化的分区与从 FAT 或 FAT32 转换来的分区相比，磁盘碎片较少，且性能更快。<br>但是使用 NTFS 依然有缺点，不论该分区是用 NTFS 格式化还是从以前的文件系统转换而来。在安装完成之后，也可以使用 Convert.exe 转换分区的文件系统。有关 Convert.exe 的详细信息，在结束安装之后，单击“开始”，再单击“运行”，键入 cmd 并按回车键键即可查阅它的信息。在命令窗口，键入 help convert，然后按回车键。FAT 和 FAT32<br>FAT 和 FAT32 是可选的文件系统选项。如果必须将计算机安装为有时使用以前的操作系统（有时使用 Windows 2000），则将要使用这些文件系统。其他信息，请参阅：<br>决定计算机是否包含多个操作系统<br>多个操作系统和文件系统的兼容性<br>包含 Windows NT 4.0 和 Windows 2000 Advanced Server 的计算机<br>在 NTFS、FAT 和 FAT32 间选择<br>有关 FAT 和 FAT32 之间区别的详细信息，请参阅在 NTFS、FAT 和 FAT32 间选择中的表格。如果要在 FAT 和 FAT32 之间做出选择，基本的标准是安装分区的大小。如果分区容量是 2 GB 或更大，应使用 FAT32 而不是 FAT 分区。<br>注意<br>Windows 2000 支持任意大小的由 Windows 95 或 Windows 98 创建的 AT32 卷。但是，Windows 2000 格式化的 FAT32 卷最大容量只能达到 32 GB。NTFS 是更好的选择，可应用在容量大于 32 GB 的卷上。<br>如果在安装过程中，选择使用 FAT 格式化分区，且该分区大于 2 GB，那么安装程序会自动用 FAT32 文件系统格式化。<br>在 NTFS、FAT 和 FAT32 间选择<br>可以为 Windows 2000 Advanced Server 计算机的磁盘分区选择下列之一的文件系统：NTFS、FAT 和 FAT32。NTFS 是推荐的文件系统。FAT 和 FAT32 彼此相似，但与 FAT 相比，FAT32 可用在容量较大的磁盘上。（最容易使用大磁盘的文件系统是 NTFS。）本节介绍的信息可帮助您比较这些文件系统，有关每种文件系统的其他信息，请参阅：<br>NTFS</p><p>##FAT 和 FAT32<br>NTFS 与 FAT 和 FAT32 相比，它是最强大的文件系统。Windows 2000 Advanced Server 包括新版本的 NTFS，它支持各种新功能（包括 Active Directory），而域、用户帐户和其他重要的安全特性都需要 Active Directory 功能。<br>安装程序可以方便地将分区转换为新版的 NTFS，即使该分区以前使用的是 FAT 或 FAT32 文件系统，这种转换可保持文件的完整性（与格式化分区不同）。如果不想保留文件，且有一个 FAT 或 FAT32 分区，建议使用 NTFS 格式化该分区，而不是转换 FAT 或 FAT32 文件系统。格式化分区会删除该分区上所有的数据，但使用 NTFS 格式化的分区与从 FAT 或 FAT32 转换来的分区相比，磁盘碎片较少，且性能更快。<br>但是使用 NTFS 依然有缺点，不论该分区是用 NTFS 格式化还是从以前的文件系统转换而来。在安装完成之后，也可以使用 Convert.exe 转换分区的文件系统。有关 Convert.exe 的详细信息，在结束安装之后，单击“开始”，再单击“运行”，键入 cmd 并按回车键即可查阅它的信息。在命令窗口，键入 help convert，然后按回车键。<br>注意<br>只有通过选择 NTFS 作为您的文件系统，才能使用诸如 Active Directory 和基于域的安全性等重要功能。<br>有一种情况可能需要将 FAT 或 FAT32 选为您的文件系统。如果需要让计算机有时运行早期的操作系统，有时运行 Windows 2000，则需要将 FAT 或 FAT32 分区作为硬盘上的主（或启动）分区。这是因为早期的操作系统（只有一个例外），都无法访问使用最新版 NTFS 格式化的分区。例外是带有 Service Pack 4 或更高版本的 Windows NT 4.0，它可以访问使用最新版 NTFS 格式化的分区，但也有一些限制。Windows NT 4.0 无法访问那些用在 Windows NT 4.0 发布时，还没出现的 NTFS 功能存储的文件。详细信息，请参阅：<br>决定计算机是否包含多个操作系统<br>多个操作系统和文件系统的兼容性<br>但对于其他包含多个操作系统的情况，推荐的文件系统依然是 NTFS。<br>下面的表格介绍了每个文件系统与各种操作系统的兼容性。<br>NTFS FAT FAT32<br>运行 Windows 2000 的计算机可以访问 NTFS 分区上的文件。运行带有 Service Pack 4 或更高版本的 Windows NT 4.0计算机可能可以访问某些文件。其他操作系统则无法访问。 可以通过 MS-DOS、所有版本的 Windows、 Windows NT、 Windows 2000 和 OS/2 访问。 只能通过 Windows 95 OSR2、Windows 98 和 Windows 2000 访问。<br>下表比较了每个文件系统支持的磁盘和文件大小。<br>NTFS FAT FAT32<br>推荐最小的容量为 10 MB，<br>推荐实际最大的容量为 2 TB，并可支持更大的容量。<br>无法用在软盘上。<br>容量可从软盘大小到最大 4 GB。<br>不支持域。<br>容量从 512 MB 到 2 TB。<br>在 Windows 2000 中，可以格式化一个不超过 32 GB 的 FAT32 卷。<br>不支持域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 磁盘格式：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;好久没更博客了，虽然没什么人看，但是作为练习自己写作能力的锻炼和提升，也不能荒废我的博客更新哈~&lt;br&gt;说一下我最近的个人动态吧~ 现在学校放假有两个星期了，学
      
    
    </summary>
    
      <category term="资源分享" scheme="http://indexcode.cn/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="认知提升" scheme="http://indexcode.cn/tags/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>Amour-影评</title>
    <link href="http://indexcode.cn/2017/12/2017.12.08%20Amour.html"/>
    <id>http://indexcode.cn/2017/12/2017.12.08 Amour.html</id>
    <published>2017-12-08T02:07:39.257Z</published>
    <updated>2017-12-20T09:41:06.680Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Amour-影评</strong>   <Excerpt in index | 首页摘要><br>我今年23岁，在我的这有限的人生阅历中，只经历过一次亲人的离世–我的姥爷。昨天看完了法国2012年上映的电影《Amour》，让我有很大的感触，也让我回想起了我的姥爷。人生生老病死本是常态，但是当一个人慢慢变老，而由变老带来的一系列问题真的是很让人无奈又不甘心的吧！与天斗，与地斗，与人斗，最后变成了与自己斗！<br>影片中的两位主人公都是已经退休的80多岁的音乐老师，本来在安享晚年的时候，却横遭变故，女主角Anne毫无征兆的突然中风，而后右半身偏瘫，直至最后的卧床不起..而后是男主角Georges照顾Anne的一系列平常的事情，但是也正是在平常的生活中才能见证两个人的感情..以及各自的心理变化，到最后男主的妥协..<br>这部电影讲的太过于真实，以至于直敲心灵深处。看完这部电影就像影片中男主角说他小时候看过的电影一样，看的过程中很触动感情，看完之后再回想的时候更是一发不可收拾。昨天晚上看完这部电影，今天早上再回想起来的时候眼泪更是止不住的留下来，真的跟男主角说的一样..难道这也是导演做的对这部电影的铺垫吗？<br>这部电影从头到尾都是平铺直叙式的拍摄方式，背景音乐也只是再特定的时候才用到了钢琴曲，我不敢去看第二遍了，所以这是我大概的记忆，不知道对不对。没有生活中的大起大落，只是平常生活中的平平淡淡的像极了平常人的老年生活，但是也正是这样，才直指人内心深处的感触，才能激起泪腺啊！才让我对爱有了更为真实的定义。</p><h1 id="女主角的心理历程"><a href="#女主角的心理历程" class="headerlink" title="女主角的心理历程"></a>女主角的心理历程</h1><p>从一开始的病情征兆的出现，女主角对自己的病情很害怕，因为是80对岁的人了，做手术风险很高，对一般人来说几乎没什么风险的手术，都年纪很大的女主角来说风险很高了。影片中男主角也说到了做手术的风险很低，但是不巧的是女主角正好是那风险很低的5%的一部分里。做完手术后身体半瘫，从刚开始的难以接受，自尊心受到了极大的打击，乃至于男主角有一天去参加一个朋友的葬礼，提前回来之后发现女主角倒在开着的窗台下面，男主角没有问为什么会发生这样的事，他应该也能猜到Anne的想法，觉得自己是一个累赘，不如一死了之。再到Anne看相册时说的一句话：人生真是太过漫长了。听到这儿，Georges不知该说什么，明白了Anne的心思。</p><p>片中的一幕死亡引起了不少观众的非议，这不禁让我想起“安乐死”的议题。笔者所在的荷兰是最早通过“安乐死”的国家，“安乐死”其实是对生者权利和意愿的尊重。电影中的这一幕，有区别，却也有类同。许多观众无法对片中展示的价值观进行认同，其实我看《Amour》的时候，当乔治拿起枕头时，也先是吃惊，不解，随后心中却升起无尽的悲凉。电影中的细节已经无数次提醒观众：Anne去意已决，当George回家看到Anne跌坐在窗口，Anne已有了跳楼离世之心；当Anne翻起相册时，她不是已经说过，人生之于她，已经太过于漫长了么？当她彻夜喊着“痛”，喊着“妈妈”时，她难道不是已经无法再忍受下去了么？当George给Anne喂汤时，她莫非不也是无法接受最后的怜悯了么？巴掌打在Anne的脸上，却也重重打在了George的心上，这样下去的苟延残喘，只会带来互相伤害，保姆已经用梳头和镜子彻底摧毁了Anne仅剩的一点点自尊心，他又能带给她什么呢？</p><p>于是我泪流满面，明白了George的用意，与其让爱人痛苦着死去，不如让她快乐地活在他心里。一辈子的相濡以沫，又怎么会不懂得爱人的心意呢？那些只看到“谋杀”的观众，恐怕涉世未深，对“爱”无法理解吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Amour-影评&lt;/strong&gt;   &lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;我今年23岁，在我的这有限的人生阅历中，只经历过一次亲人的离世–我的姥爷。昨天看完了法国2012年上映的电影《Amour》，让我有很大的感触，也让我回想起了我的
      
    
    </summary>
    
      <category term="个人分享" scheme="http://indexcode.cn/categories/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="影评" scheme="http://indexcode.cn/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>Js中一些相似方法/属性的区别</title>
    <link href="http://indexcode.cn/2017/12/2017.12.05%20js%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E5%8C%BA%E5%88%AB.html"/>
    <id>http://indexcode.cn/2017/12/2017.12.05 js中一些方法的比较与区别.html</id>
    <published>2017-12-05T14:49:20.251Z</published>
    <updated>2017-12-05T15:33:40.471Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Js中一些相似方法/属性的区别</strong>   <Excerpt in index | 首页摘要></p><h1 id="forEach-与-map-方法比较"><a href="#forEach-与-map-方法比较" class="headerlink" title="forEach 与 map 方法比较"></a>forEach 与 map 方法比较</h1><p>forEach()和map()两个方法都是ECMA5中Array引进的新方法，主要作用是对数组的每个元素都执行一次所提供的函数，但是它们之间还是有区别的。jQuery也有一个方法$.each(),长得和forEach()有点像，功能也类似。但是从本质上还是有很大的区别的。</p><p>`//forEach<br>array.forEach(callback(currentValue, index, array){<br>    //do something<br>}, this)</p><p>//或者<br>array.forEach(callback(currentValue, index, array){<br>    //do something<br>})　　</p><p>//map:<br>var new_array = arr.map(callback[, thisArg])　</p><p>//$.each()<br>$(selector).each(function(index,element))  //注意参数的顺序`</p><p>callback: 为数组中每个元素执行的函数,该函数接收三个参数，</p><p><strong>参数一：当前数组中元素；参数二：索引； 参数三：当前数组。</strong></p><p><strong>this：可选，执行会掉时候，this的指向。</strong></p><hr><p>区别：</p><ol><li><p>forEach()返回值是undefined，不可以链式调用。</p></li><li><p>map()返回一个新数组，原数组不会改变。</p></li><li><p>没有办法终止或者跳出forEach()循环，除非抛出异常，所以想执行一个数组是否满足什么条件，返回布尔值，可以用一般的for循环实现，或者用Array.every()或者Array.some();</p></li><li><p>$.each()方法规定为每个匹配元素规定运行的函数，可以返回 false 可用于及早停止循环。</p></li></ol><hr><p>Array 在 Javascript 中是一个对象， Array 的索引是属性名。<br>事实上， Javascript 中的 “array” 有些误导性， Javascript 中的 Array 并不像大部分其他语言的数组。首先， Javascript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。<br>实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0” 。<br>所以，在 Javascript 中从来就没有 Array 的索引，而只有类似 “0” 、 “1” 等等的属性。有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。<br>但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。</p><p>map可以做链式操作，forEach不可以，<br>for不用担心兼容性的问题，还有可以break跳出循环，是基础循环，可以有for…in,foo…of,for(let i=0;i&lt;len;i++)等。可以用continue和break控制<br>forEach是for(let i=0;i&lt;len;i++)的缩写，不支持continue和break，可以return来控制循环，forEach是不能退出循环本身的<br>map循环当前可循环对象，并且返回新的可循环对象，而forEach没有返回值<br>forEach只有在火狐和谷歌浏览器中Array有这个方法，在IE中就米有，需要用prototype手动添加这个方法。</p><h1 id="类数组与数组的区别"><a href="#类数组与数组的区别" class="headerlink" title="类数组与数组的区别"></a>类数组与数组的区别</h1><p>类数组对象：<br>console.log(typeof a);//object 注意：数组也是对象哦<br>console.log(a); //  Object {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81} 很明显对象啊<br>console.log(a.length); //undefined  区别就在这了  类数组对象没有长度的属性和数组的方法<br>console.log(Object.prototype.toString.call(a));//[object Object]<br>数组对象：<br>console.log(typeof b);//object<br>console.log(b);//  [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]  很明显数组啊<br>console.log(b.length); //8<br>console.log(Object.prototype.toString.call(b));//[object Array]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Js中一些相似方法/属性的区别&lt;/strong&gt;   &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;h1 id=&quot;forEach-与-map-方法比较&quot;&gt;&lt;a href=&quot;#forEach-与-map-方法比较&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://indexcode.cn/categories/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="http://indexcode.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>彗星来的那一夜-影评</title>
    <link href="http://indexcode.cn/2017/12/2017.12.04%20%E5%BD%97%E6%98%9F%E6%9D%A5%E7%9A%84%E9%82%A3%E4%B8%80%E5%A4%9C-%E5%BD%B1%E8%AF%84.html"/>
    <id>http://indexcode.cn/2017/12/2017.12.04 彗星来的那一夜-影评.html</id>
    <published>2017-12-04T08:23:38.187Z</published>
    <updated>2017-12-05T10:43:53.498Z</updated>
    
    <content type="html"><![CDATA[<p><strong>彗星来的那一夜-影评</strong>   <Excerpt in index | 首页摘要></p><p><strong>想象一下我们生活在一个多平行空间中，有无数个平行空间中的我们，每做一个选择就会在另一个平行世界中发生另一种我们的人生..</strong></p><p>转载一篇我认可的影评吧，不看这篇影评我都注意不到电影中的这些细微之处的细节。转载自–豆瓣   <a href="https://movie.douban.com/review/7109306/">原文地址</a></p><ol><li>全片的关键词是片名“Coherence”，而不是“薛定谔的猫”</li></ol><p>我得说，原片名《Coherence》比中文译名《彗星来的那一夜》逼格高很多。</p><p>Coherence，直译就是“相干性”。经典物理中最简单的定义就是：这是一种让两列波产生干涉的性质。而在量子物理中，coherence可以从很多种角度去定义，后面再讲。</p><p>我不同意有人说的这是一部披着科幻外衣的人文片。相反，这片子的科学内核硬得很。用“Coherence”作片名，就说明编剧对量子物理的了解已经超过了简单卖弄一下“薛定谔的猫”这个概念或是不管三七二十一拿过“平行世界”的概念就来用的水平。我倒觉得最后女主黑化，展现“人性”的那一段，反而是副主题而已。</p><p>那么，“薛定谔的猫”和“平行世界”有什么关系？Coherence在这里又是什么含义？</p><p>简单来说，“薛定谔的猫”不是“平行世界”导致的结果。“平行世界”只是用来诠释“薛定谔的猫”的理论之一，更通行的说法是“多世界诠释” （many-worlds interpretation）。</p><p>这部片子其实是在量子力学的多世界诠释是正确的设定下，描写了“多世界”（平行世界）发生相干（coherence）时发生的事。</p><p>“薛定谔的猫”，让很多人迷惑的多半是在人开门观察之前，猫所处的那种不死不活又死又活的状态。其实，这种状态虽然诡异，但理论上总可以用一个波函数来表示。这个波函数在物理学家眼中具有很好的性质，因为它随时间的变化遵循薛定谔方程。门一开，“诡异”的状态立刻解除，我们得到了一个确定的状态：死或者活。开门瞬间猫的状态改变了，这意味着猫的波函数也有了一个突变，这个突变几乎是瞬时的，且不遵循薛定谔方程，是一种看上去由我们的观察（测量）而导致的突如其来的变化——这种由测量导致的突变才是更诡异的地方。</p><p>这种突变的本质是什么？就是量子力学如何诠释的问题了。两种最流行的诠释就是：哥本哈根诠释和多世界诠释。</p><p>哥本哈根诠释的核心在于波函数会“塌缩”，也就是测量瞬间，波函数以一定概率“突变”到一个确定的状态。在这种诠释下，不存在“平行世界”。猫死掉或是活着，完全是我们所在的唯一的宇宙里发生的一个随机的现象。</p><p>而在多世界诠释里，开门之前，一切和哥本哈根诠释一样。开门的一瞬间，波函数并没有塌缩，但宇宙却一分为二。在一个宇宙里猫是死的，在另一个宇宙里猫是活的。关键是，活猫的宇宙和死猫的宇宙在很短的时间里就“退相干”（decoherence)了，因此，这两个宇宙不会重叠——或者说它们退相干的速度非常之快，以至于一个宇宙中的人不可能觉察另一个宇宙的存在。</p><p>很明显，这部片子讨论的不是猫在开门之前的又死又活的状态（刘慈欣的《球状闪电》讨论的倒是这个），而是“开门之后”发生的事情。影片的设定里，量子力学的多世界诠释是正确的，而哥本哈根诠释是不正确的。因此，开门之后，各种可能的宇宙同时产生。只不过彗星发挥了神奇的作用，将这些可能的宇宙保持在一个相干的状态，里面的人可以看到甚至进入另一个宇宙。</p><p>其实，这一点在Hugh读那本书的时候已经说的很明白了。因此，最后天亮，彗星解体，世界看似回到正常的时候，发生的也不是“塌缩”，而是多世界之间“退相干”了。</p><p>结论：很多评论里都在用薛定谔的猫来解释这片子，其实这片子跟薛定谔的猫那种又死又活的状态没有什么关系。全片没有任何地方发生了“塌缩”，即使到最后天亮了一切看似恢复正常了，也不代表其他平行宇宙塌缩掉了。而只是说明所有的平行宇宙都退相干了，不再处于coherence的状态了。</p><p>所以，那诡异的一夜，发生的事情，就是平行宇宙间的coherence，以此作片名，还是相当精准的。</p><p>——————————————————————</p><ol><li>谁制造了平行世界？</li></ol><p>个人理解，彗星可能开了个头（有的宇宙里Hugh的手机裂了，有的没有），但绝大多数的平行世界都是那八个人自己制造的。</p><p>回到薛定谔的猫。宇宙的分裂和平行世界的产生，都是由“开门观察”这一行为造成的。也就是说，一次“测量”可能的结果有多少种，就会造成多少个平行世界。</p><p>讨论这部电影的时候，我们当然不必太过拘泥于“测量”的精确定义。我们只要记住，当他们每一次就某件事做出选择，他们就制造出了对应这个选择不同结果的平行宇宙。</p><p>一开头宇宙就分裂了，有的宇宙里Hugh的手机裂了，有的世界里没有（最后打成一团的时候就看到了）。 这个分裂的原因没有明说，可能是彗星。</p><p>而其中一次明显的人为选择，就是Hugh选择创可贴的种类。两种选择，制造出两个平行宇宙。</p><p>第二次明显的人为选择，就是荧光棒的颜色。主视角的那个世界里他们选了蓝色，于是就必然有选择红色和绿色的平行世界在他们作出选择的时刻同时产生。所以，在这个蓝色荧光棒宇宙里，在他们做出新的选择之前，他们出去看到的另一个宇宙里的自己手里拿的荧光棒必然是不同的颜色——比如红色。</p><p>如果就此止步，两种创可贴的选择造成两个平行世界，这两个平行世界里又各自有三种荧光棒的选择，于是这里就有2乘3也就是6个平行世界。</p><p>接下来就疯狂了。他们八个人要用骰子人为制造随机性来标记自己。要知道，8个人掷骰子，每个人有6种可能，于是总共有6的8次方种可能的排列组合，这么一来，他们在之前的6个平行世界的每一个世界里又一下子制造出了6的8次方个平行宇宙，再加上照片的选择和随机物品的选择，这样下来平行宇宙的数量就多到令人发指的几千万个了。</p><p>所以，这么细抠下来，片子里平行宇宙的总数并不是一开始就有许多个，而是随着他们的选择一次次增长的。</p><p>另一个角度也可以说，让角色们做出不同的选择，不光是为了标记各个宇宙让观众不至于晕菜，事实上，每一个选择都创造了新的平行宇宙，是剧情向前推进的重要节点。</p><p>进一步想，其实除了前面那些很明显的选择，还有许多暗含的选择比如去不去贴那个留言，Mike去不去给自己留威胁信，要不要去把另一个自己揍一顿，等等。再比如一开始，停电之后要不要出去看，这是一个很重要的选择。很显然，女主最后进入的那个“幸福”的平行世界里，他们没有选择出去看，可以注意到那个世界里Hugh的头上没有创可贴。</p><p>所以，如果我们画出一幅平行世界的“进化树”的话，第一个很大的早期节点就是“要不要出去看”。选择不出去看的那个平行宇宙是一大分支，之后一切太平，没有因为选择产生新的分叉; 而选择了出去看的平行宇宙是另一个大分支，在其上又因为荧光棒、创可贴、骰子和随机物品的各种选择迅速地产生大量的分叉。</p><p>甚至可以猜测，那个“幸福”的平行世界是早在女主选择是否要放弃那个替补席位的时候就已经分裂出去的平行宇宙。这个宇宙早就分裂了，比那个晚上才产生的诸多宇宙“辈份”高得多。</p><p>而这颗彗星的作用，就是让这些本应该在非常短的时间里就退相干的平行宇宙保持长时间的相干状态。相干的表现，就是不同平行宇宙中的人可以看到、进入并且最终互相影响彼此的历史进程。</p><p>这颗彗星能把宏观世界的相干态保持那么长时间，研究量子计算的人肯定很感兴趣。</p><p>————————————————————————</p><ol><li>各个平行世界之间的时间差与因果链。</li></ol><p>有人也许会说，只有在别的宇宙里面掷完骰子把东西放进箱子以后才可能让Amir捡回那个箱子来啊。也就是说有的宇宙比别的宇宙时间进程快的多，那么到底是哪一家掷的骰子制造了平行宇宙呢？</p><p>我的答案是每一家都创造了平行宇宙，每一家也都是被别人创造的。平行世界之间存在时间差，并不能推翻之前所说“选择产生平行宇宙”的假设。</p><p>平行宇宙存在时间差应该是很自然的结果。比如一个宇宙里你选择了走路去约会，另一个宇宙里你选择开车。结果走路比较快，准时到达，开车的宇宙里你被堵了半天，迟到了。于是，两个宇宙里你们见面的时间不同，见面以后再做下一个选择的时间和之后的进程（比如女朋友是否同意跟你啪啪啪）当然也就不同了。</p><p>前面说了，因为coherence，那个晚上，不同平行宇宙中的人互相影响了彼此的历史进程。再细想下去，正是因为它们互相影响，才会导致里面的人去作出选择，而这些选择又是产生其他平行宇宙的原因。于是我们陷入了这么一个因果关系的怪圈：</p><p>作出选择——产生平行宇宙——平行宇宙互相影响——作出选择——产生平行宇宙——平行宇宙互相影响——……</p><p>而且，这个怪圈的存在形式不是简单地一个圈，而是在几百万个平行宇宙之间互相交织、错综复杂的网状结构。</p><p>更有意思的是，正是因为他们对确定性的追求，造成了更大的不确定性：</p><p>那么多平行宇宙造成困扰——想到掷骰子确定自己——掷骰子创造了更多的平行宇宙——有那么多的平行宇宙让他们感到困扰——想到用掷骰子来区别自己……</p><p>所以，当你投身其中，事件的先后是永远理不清的，这些平行宇宙共享一段互相交错而又自洽的历史。平行宇宙之间不仅不分彼此，而且不分先后。在这个自洽历史包含着的所有宇宙里，这八个人都会去做那几件关键的事——必然会扔骰子，Amir必然会去拍那张照片，必然会去选某种颜色的荧光棒……这些“关键事件”在哪个宇宙里发生在先，哪个宇宙里发生在后，根本不重要。这些平行宇宙是自己的因，也是自己的果。如果在某一个宇宙中他们不去做这些选择中的某一项，那么这个宇宙就会脱离这个自洽历史，而剩下的所有宇宙的历史自洽性依然不受影响。</p><p>所以，里面有一个角色说的话很好：我们总觉得另一个平行世界里的我们是”dark version”, 但是, “What if we are the dark version?”这句话显然是编剧想要把主题提升到人性的层面，但也说明一点：影片的拍摄必然要选取某个平行世界做为主视角，而我们要记住所有的平行世界都是平权的。既然这些平行宇宙在空间上通过那一块黑暗地带交织在了一起，那么它们的时间线互相纠缠，都不再保持独立和线性，也就是一件很自然的事情了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;彗星来的那一夜-影评&lt;/strong&gt;   &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;想象一下我们生活在一个多平行空间中，有无数个平行空间中的我们，每做一个选择就会在另一个平行世界中发生另一种我们的人生..&lt;/stro
      
    
    </summary>
    
      <category term="影评" scheme="http://indexcode.cn/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="个人分享" scheme="http://indexcode.cn/tags/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>寂静岭-影评</title>
    <link href="http://indexcode.cn/2017/12/2017.12.04%20%E5%AF%82%E9%9D%99%E5%B2%AD-%E5%BD%B1%E8%AF%84.html"/>
    <id>http://indexcode.cn/2017/12/2017.12.04 寂静岭-影评.html</id>
    <published>2017-12-04T08:11:48.756Z</published>
    <updated>2017-12-05T10:44:50.600Z</updated>
    
    <content type="html"><![CDATA[<p><strong>寂静岭-影评</strong>   <Excerpt in index | 首页摘要></p><p>看完电影寂静岭之后想自己写一篇影评但是由于自己腹中实在没有什么干货，写不出来~~~（还是得多看书啊）<br>从网上看到了一篇讲解的非常全面的影评，看了这个影评才感觉电影中的好多东西都没有理解到位~转载到自己的博客上，以后想回看方便一些~</p><p>转载自–豆瓣 <a href="http://blog.sina.com.cn/s/blog_6707d64e0100h50g.html">原文地址</a></p><p>本文从2006年底笔者看过该片到完成该文，共看过该电影三次，构思并创作全文大约用了半年的时间。<br>现作者本人将原文全部发于豆瓣，特此说明。</p><p>2006年4月，由曾经指导过电影《狼族盟约》的法国著名导演克里斯多夫·甘斯（Christophe Gans)制作的恐怖电影《寂静岭》（英文名《Silent Hill》,中国台湾译为《沉默之丘》），在上映三天内就突破了2000万美元大关。作为同样是由同名计算机游戏改编的电影，《寂静岭》一雪《生化危机》和《古墓丽影》等影片的前耻，受到游戏玩家的一致好评，《寂静岭》也由此成为了电影界和以游戏改编的电影中里程碑式的作品。</p><p>尽管《寂静岭》获得了巨大的成功，但是仍有对其批评的声音。例如就有新闻认为《寂静岭》是一部“恶评如潮”但却票房高的影片（听起来怎么像在评价某些中国“大片”？），还有影评人称“看不懂”《寂静岭》，更有人想象力颇为丰富地将《寂静岭》与《无极》相比并认为其是一路货色。其实在文化全球化和后现代的今天，出现让每个人都拍手叫好的电影几乎是不可能的，何况还有那么多别有用心哗众取宠的人和不明就里盲从潮流的大众。《生化危机》和《古墓丽影》仅就电影本身来说，我个人认为并非“烂片”。而之所以它们被大加诛伐，就是因为与原游戏脱节严重，批评它们的人也多以游戏玩家为主。《寂静岭》之所以被玩家看好，就是因为它很真实地还原了同名游戏中推理解谜的特点和血腥、肮脏、恐怖、压抑的环境气氛。何况无论是电影还是游戏，《寂静岭》都绝对不是一个简单的、为渲染恐怖而生的“鬼域”或“血腥美学”，它是一个充满深刻人文内涵的地方，包括宗教、道德、哲学、性等多种元素和象征、隐喻、暗示等多种手法。因而对于没有玩过《寂静岭》这部系列游戏（截止拍电影时已有四部《寂静岭》游戏，现已出第五部）的人或者对这些不了解的人来说，“看不懂”实属正常。<br>既然有人说“有一千个观众就有一千个哈姆雷特，所以有一千个观众就有一千个寂静岭”，那么现在就让我们回到寂静岭：</p><p>寂静岭的世界观：“三元论”、“二元论”与“二元主义”<br>看过《寂静岭》的人可能都应该感受到电影中不止存在着一个空间。对于寂静岭究竟有几个空间的问题，普遍存在“已死论”、“二元论”和“三元论”三种观点。持“已死论”（也就是认为寂静岭就是“阴间”，进入寂静岭中的人实际已在片头车祸中死亡）的观众可能是“没看懂”电影或者受到一句被错误翻译的台词字幕——“你们都已经死了”（实际应为“你们都已经被诅咒了”）的误导。“三元论”则是广受支持的一种观点，更有文章用“黄澄澄”、“灰蒙蒙”、“黑漆漆”三个词简明而传神地概括了寂静岭的三个世界。但是我认为，虽然寂静岭存在三个世界，但是“三元论”这个说法却是不准确的。<br>首先可以区分一下寂静岭的三个世界都是什么：<br>1.真实世界：就是真实的世界，在这个世界中的寂静岭就是一个被废弃的小镇，即“黄澄澄”的世界，这是由于电影中多数表现真实的白天都采用了一种温暖阳光的色调。<br>2.“表世界”：即“灰蒙蒙”的世界，就是女主人公罗丝（Rose）在车祸醒来后发现自己身处的世界，仿佛冬天的样子，实际上是由恶魔化之后的阿莱莎（Alessa)用邪恶的力量营造的世界，将一切“罪有应得”的人困在了里面。<br>3.“里世界”：即“黑漆漆”的世界，就是表世界响过警报之后不定期转化后的世界，一派血腥、肮脏的景象并有各种怪物出没，实际是阿莱莎内心痛苦和压抑的反映并由其邪恶的力量和仇恨的情绪控制。表世界和里世界都是从《寂静岭》游戏中借鉴来的概念。<br>存在三个世界这一点似乎没有问题了。但经过分析之后，我们会发现，如果从“次元对立”的角度看，那么只有两个对立的空间。在这之前，要看一个概念：二元主义。<br>“二元主义”（Dualism)在哲学中作为一种思想通常指承认两种根本的，不可再分且互异的元素，它们彼此冲突或者相互补充，又分为将这两种基本要素应用于认识活动中的“认识论意义上的二元主义”和用于解释一切广义上的客观现象的“形而上学意义上的二元主义”。“二元主义”本身也是西方历史文化自我否定式的发展规律自近代以来的产物，是对中世纪基督教唯灵主义的否定。<br>寂静岭的世界本身就存在表里世界的二元对立，这样以来加上真实世界，似乎“三元论”是成立了。但是对立的表里世界二者却不能同时与真实世界构成对立。因为寂静岭的世界要么是表世界要么是里世界，二者相互转化不能并存，所以导致要么是真实世界与表世界共同存在且对立，要么是真实世界与里世界共同存在且对立，无法存在真实世界、表世界、里世界同时存在并且对立的情况。需要说明的是，在里世界中的教堂只是由于信仰的原因使怪物无法进入而已，它并不具备表世界的特征，因而不是表世界，只能算里世界中的一个特殊地点；而阿莱莎所在医院的地下室也只是表世界里的一个特殊地点而已，还不能因为医院地下室有怪物和黑漆一片就认为那是里世界，因为表世界也有怪物，而地下室没有光自然是一片黑；而游戏《寂静岭》中表里世界的创造、形成原因与电影中不同，也不能作为解释电影《寂静岭》的依据。所以可以得出结论，寂静岭确实存在三个世界，但是从“对立”的角度看，只有二元对立。因而《寂静岭》中的世界观是存在三个世界的“二元论”，或者也可以认为实际只存在两个世界：真实的世界和变化着的寂静岭的世界。作为西方带有宗教题材的恐怖片，《寂静岭》也没有脱离二元主义的规律。<br>其实片中的这种二元对立在电影一开始就已经暗示了，那就是罗丝的女儿莎仁（Sharon)梦游时险些摔下悬崖的镜头，构成了上下的对立，水上和水下的对立，真实世界与虚幻世界的对立，善良的莎仁与阿莱莎的邪恶面的对立，甚至原来是水下世界却存在幻境中的烈火这样水与火的对立。当阿莱莎的邪恶面从悬崖上高速下坠的镜头出现时，我承认确实被吓到了，虽然据说这个停留的镜头只持续了0.7秒，但是那恐怖的笑容着实让人一震，真很难想象到可爱的阿莱莎的形象与这个恐怖的邪恶的阿莱莎是同一个小演员出演的！实在不得不佩服她的演技！</p><p>三个阿莱莎：<br>影片中就“小女孩”的角色问题，可能有人梳理不清阿莱莎、莎仁等人物的关系，参照一些公认的定论，我们可以明确有三个不同形式的“阿莱莎”存在。<br>1.阿莱莎：即在三十多年前被施以火刑的小女孩，也是后来在教堂进行屠杀的“终极怪物”，从她后来的身形可以的知她一直处于生长中。<br>2.阿莱莎的邪恶面：即引发罗丝车祸的人影，后来一直引导罗丝追踪、解谜，以燃烧的形式消失并在医院地下室与罗丝融为一体的小女孩，以一身阿莱莎当年穿的蓝紫色校服出现。她就是阿莱莎被严重烧伤后，在医院极度的恐惧和仇恨所产生的邪恶力量形象的具体化，她使阿莱莎拥有了恶魔的力量。<br>3.阿莱莎的善良面：即罗丝的女儿莎仁，由阿莱莎以分娩的形式产出，并由阿莱莎的邪恶面送出到真实世界的修道院，后由罗丝领养（由此得知阿莱莎的邪恶面有自由穿行于三个世界之间的能力）。有人根据阿莱莎曾被强奸过这一情节认为莎仁是阿莱莎的亲生女儿，这根本就是缺乏基本生活逻辑：以当时阿莱莎的年龄不可能有生育能力，另外以莎仁的年龄看，阿莱莎不可能怀孕二十年再生孩子，而莎仁一再梦游想回寂静岭就是受到神秘力量的召唤，回去与阿莱莎的邪恶面“结合”。</p><p>《寂静岭》中的人文内涵<br>《寂静岭》的人文内涵很大一部分来源于宗教元素的存在。就在片头罗丝发疯般寻找莎仁并最后与赶来的丈夫抱在一起时，画面背景就出现了一个亮着灯的十字架，为什么那边不出来一些别的东西呢？比如亮着灯的摩天轮？亮着灯的建筑？因为这本来就是一个暗示，告诉你本片涉及的宗教题材。而罗丝带莎仁去寂静岭的路上出现的一块牌子，镜头特地在上面停留，上面的内容是，“Do you not know that we will judge angels?Do you not konw that the saints will judge the world？（岂不知我们要审判天使么？岂不知教徒要审判世界么？）”这些句子本来就是《圣经·哥林多前书》中的内容，原文是“Do you not know that the saints will judge the world? And if you are to judge the world, are you not competent to judge trivial cases?Do you not know that we will judge angels? How much more the things of this life!（岂不知教徒要审判世界么？若世界为你们所审，难道你们不配审判这最小的事么？岂不知我们要审判天使么？何况今生的事呢？）”这就是在预示她们此去寂静岭的前景，被一群自宗教偏执狂“审判”，但是最终却是在暗示整个影片的结尾，就是魔鬼对教徒进行的审判，那些为恶而自认为正义的人，最终会被上帝抛弃——别告诉我你没有注意到牌子的外形就是一本书，别告诉我你看见那书的外形没有想到那是《圣经》！还有罗丝在寂静岭学校时候，门框上文字的一个镜头：“The foes of the righteous will be condemned.”这是《圣经·诗篇》中的内容，原文为：“Evil will slay the wicked；the foes of the righteous will be condemned（恶必害死恶人；恨恶义人的，必被定罪）。”已经不用多说了，那些自以为信仰上帝的人的命运，被定罪审判，已经再一次提前告知观众了。<br>从电影中我们可以得知，寂静岭是1974年11月因为地下煤矿的火灾而被废弃的小镇，至今地下的锅炉和矿脉还在燃烧着熊熊大火，因而寂静岭的空气中飘浮着致命的污染物。这一点在真实世界中表现的不明显。而在表世界则表现为似乎是不断落下来的“雪”，后来罗丝发现其实那是飘落的“煤灰”。而《圣经》中的《圣约翰启示录》是怎样描写“地狱”的呢？“它是一个永久的火湖，它的空气来自祸害的煤炭，光来自闪烁的火焰。夜晚一片漆黑，被诅咒之人的处所毒蛇横行。他们的希望是绝望。啊，永生之死！无生之生！啊，无尽的痛苦！”《圣经·福音书》中耶稣对地狱的描绘中也有“火是不灭的”字样。<br>里世界那些残破的墙壁，锈迹斑斑的管道和门，铁制的楼梯，转动的风扇，不知从何处产生的铿锵作响的金属撞击声和烟雾或蒸汽，似乎只存在铁黑和火红这两种颜色的压抑环境，正是大机器生产的工业时代的再现！这都是电影在以后工业时代的艺术风格对没落的工业时代以一种末世的悲凉形象进行的渲染。<br>对于《寂静岭》来说，后工业时代的艺术风格只是它的表象，《圣经》中的宗教隐喻才是它的实质。在里世界被开启之后，教堂中的教徒们祈祷所要阻止的也正是《圣经》中的“末日审判”，或电影中所谓的“天启”的到来。<br>《寂静岭》中的怪物也是一大看点。它们的外形和特征等都是严重烧伤的阿莱莎恐惧、痛苦、仇恨、愤怒心理的形象具体化之后的表现。无论电影中还是游戏中，这些怪物都不是仅为了引起恐怖的视觉效果而往“怎么丑陋怎么设计”出来的产物，宗教内涵与性暗示足以使这些怪物受到弗洛伊德信徒们的鼎礼膜拜！<br>罗丝进入里世界后首先看到的第一个恐怖景象就是一张铁床上的物体，具体是什么我看了好几次也没看出来，据说是一个死得很惨的人，这是对游戏场景的一个还原。罗丝后来发现铁丝网墙上挂着的是一个穿着“防护服”的教徒（人还活着）。如果我没有看错，他已经断了一只手，而且他就是以十字架的形式挂在那里（又是一个宗教暗示）。接下来冒出的那些还处于半燃烧残骸状态的怪物，就从它们的形体大小和发出类似孩童的嘶叫声音的角度看，其实它们就是当年在学校欺负阿莱莎的同学，这些孩子在被阿莱莎拥有的邪恶力量引发的火灾烧成焦炭以后，就以这种怪物的恐怖方式存在于里世界中。<br>第二个出场的怪物被游戏玩家称为“紧身衣”，也是电影中表世界出现的唯一怪物。从它被女警察西比尔用枪击毙时喷出的红血基本可以推测出那是一个被困在自己皮肤里的人。据说在拍摄这个怪物时也是用真人穿上无臂的紧身衣然后再用电脑合成的。这个怪物是游戏《寂静岭2》中男主角长年自我束缚在生病妻子身边痛苦心理的写照，搬到这里一样也可以有合理的解释。因为阿莱莎受到火刑时也被强制束缚。其实在这里我们可否认为“紧身衣”也具有某种性暗示的意义？阿莱莎被强奸这是片中的事实，而这个无臂的怪物光溜的躯体本身就像一个可以来回行走的男性生殖器。这个怪物就是阿莱莎被强奸时恐惧和痛苦心态的形象具体化。而怪物本身可以喷射出带有强腐蚀性的液体可否被看作是还不谙世事的阿莱莎对男人精液的恐惧印象？后来这个极具性暗示外形的怪物确实喷出了这些液体，而且是向女性喷射的，别告诉我你看不出这里的意思… …<br>从厕所中爬出来的怪物，就是当年阿莱莎被同学欺负躲进厕所后强奸了她的清洁工，电影中两次用身份牌上的名字柯林（Colin）暗示出他与怪物的关系。这个怪物被以扭曲的形式用铁丝网捆绑，应该是阿莱莎以被强奸时的心理对其的报复。而怪物的眼睛被铁丝网蒙住则是阿莱莎对柯林强奸时看了她身体的惩罚。只有怪物身上的输液瓶让人觉得奇怪，也可能是对游戏细节的尊重。怪物爬行时手臂所及之处会产生藤蔓般的血管并伴有毒泡产生，它不断“吐舌头”的动作则是性暗示的标志，而按照它那样两腿被高高吊起地爬行方式，每爬动一次，生殖器就会被严重摩擦，让它经受如此的痛苦也是阿莱莎对他的报复。<br>在罗丝于里世界的镜头中，出现很多笼子中倒挂的成年男性的尸体。为什么都是成年男人，我只能用阿莱莎本身是私生女、从小没有父亲所以很少接触男人，后来又被男人强奸而导致她对男性产生了极不信任感和仇视来解释了。随着罗丝下楼梯的镜头我发现其中一具男尸是没有生殖器的（被割去了？），或许这也就是因为上述原因导致阿莱莎对男人的报复。也是因为这种不信任和仇视也是阿莱莎没有将罗丝的丈夫拉入寂静岭世界的原因。而那些被倒挂的尸体，其实在《圣经》中的《彼得启示录》中就有很容易找到的答案。那里描写的地狱里被惩罚的人以不同罪恶的原因被施以不同的刑罚，但是被“吊起来”或“倒挂”却是很共同的一种。其实寂静岭的里世界就是“地狱”！<br>之后，多灾多难的罗丝遇上了一大群圣甲虫或被称为“人面虫”的怪物。三个来不及逃跑的教徒被虫子吃掉，看来他们身上看似结实厚实的防护服也不怎么样，顶多应该能抵挡下表世界“紧身衣”怪物喷出的毒液。关于这些虫子的来历，有人认为是阿莱莎重伤时被甲虫咬过或感觉身上像被甲虫咬的感觉幻化出的，其实这些都是没有任何根据的，至少电影中没有这些情节。认为虫子是阿莱莎以前同学的说法也似乎有些牵强，而且我没有怎么看出甲虫的脸怎么像人脸。其实这些虫子就是圣甲虫，古埃及神话中被认为是太阳神科何普拉的化身（当然，古埃及神话中太阳神不止他一个），原因是古埃及人看见这些乌黑的甲虫反射的阳光就认为它们是太阳神的化身。有人认为这些虫子是尸虫而不是圣甲虫，其实这点并不矛盾，因为古埃及人确实将这种被认为能避免尸体受到恶灵侵害的虫子倒入棺材。圣甲虫在古埃及神话中的另一意义就是“复活”，在电影中它们它们代表了经受火刑之后几乎死掉的阿莱莎“复活”时产生的仇恨。或者也可以揣摩一下这些虫子的宗教隐喻，《圣经·福音书》中耶稣对地狱的描述中就提到了地狱中“虫是不死的”（圣甲虫可以随着寂静岭表里世界的转换而复生），而《圣经》中《彼得启示录》更写到了迫害正义之士的人要“站在火焰中”，“受到不死之虫的吞噬”，而谋杀犯和帮凶则“被扔进满是恶毒害虫的狭小之地，他们受到那些生物的折磨，不停痛苦地扭动着。黑云一般的害虫向他们频频袭来。被谋杀之人的灵魂在一旁站立，目睹自己仇人受罚，并对他们说道，主啊，你的惩罚公正无比。”以上内容有没有让人想起那三个教徒被圣甲虫吃掉时候的场面？这些人里哪个当时不是想烧死阿莱莎的谋杀犯，哪个不是女教主克蕾丝（Ghristabella）的帮凶呢？<br>接下来出场的就是极具视觉冲击力的“大铁头”怪物了。这个在游戏《寂静岭2》中代表南主角自身的暴力倾向和对罪孽的自我审判的象征，据说其典型的特征“三角铁头”来源于寂静岭历史上美国南北战争时期一座监狱中的刽子手形象。在电影中，这个拖着沉重步伐游走于里世界并且见人就杀的怪物也着实让人感到恐怖和震撼。其极具男性特征的粗壮躯体正表达了阿莱莎复仇的渴望，之所以阿莱莎会被同学欺负、被强奸、被施以火刑而无法反抗，就是以为内她是一个弱小的女孩，而如此强悍的外形则正好符合阿莱莎复仇的条件。有人曾对电影里三角头的武器由游戏中极具性暗示作用的长矛换成大刀而感到遗憾，但是我觉得这大可不必，因为根据弗洛伊德的理论，不仅是长矛，一切长形、凸起、竖起、坚硬有穿刺力的物体，尤其是武器本身都是极具性暗示的。当罗丝和女警察西比尔（Cybil）在小屋的铁门后面躲避铁头怪物的剧情里，当铁头怪物用极具性暗示作用的大刀“刺破”关着两个“女性”的铁门，并将已经“进入”铁门的大刀来回“搅动”时，这里的“大刀”、“小屋”、“铁门”、大铁头伸进来的“手”和“门闩”，甚至被放进来的几只圣甲虫本身就带上了弗洛伊德性暗示的暧昧色彩。再联想到大铁头在教堂门前因为安娜（Anna）曾经向阿莱莎的生母扔石头而石头而将安娜撕成两半的情节里，你说铁头怪物你要撕就撕好了，为什么还要把安娜衣服扒光了再撕呢？大铁头扒人家衣服时干净利落地简直有几分强奸的神韵，这是否是阿莱莎对自己被强奸的报复呢？弗洛伊德又在微笑了… …<br>就那把大刀看，似乎《圣经》也要来分一杯羹。《圣约翰启示录》中写到末日审判中，羔羊（本指耶稣，在电影中能否是对柔弱的阿莱莎的暗喻？）揭开七印，倾斜出愤怒（此处与电影一致），放出四个人，第一个被赐予“冠冕”（铁制三角吗？），第二个被赐予大刀… …看来这下，上帝要与弗洛伊德一起微笑了。<br>那群护士怪物，本来也是游戏《寂静岭2》中男主角长期性压抑的产物或者《寂静岭1》中阿莱莎对医院的反感的产物，在电影中就只能解释为阿莱莎得到邪恶力量时由于极度愤怒而将身边的人都杀死并变成怪物，从片中也可以得知当年寂静岭的大火也确实烧死了一些无辜的人。那个没有眼睛的红衣护士是因为好奇而看了重伤之后阿莱莎后被阿莱莎挖去了眼睛并一直照顾阿莱莎的生活。护士怪物们用利器相互切杀并不是自相残杀，而是感觉到身边有人但却因为无光（片中说到它们只对光有反应）的反应而已，而这些护士怪物走路时的动作被誉为“痉挛芭蕾”，据说她们都是由艳舞女郎和爵士舞蹈家扮演。<br>在教堂最后那场稍显“华丽”的屠杀中，被罗丝（或者说阿莱莎的邪恶面）的血腐蚀的教堂地板上，真正的阿莱莎从满是暗红色烈火和钢铁设备的地下出现了。她在杀死克蕾丝教主的时候，很明显可以看见，最早刺进其身体的铁丝网是从裙子下面伸入直接刺进下体的，这又是一个明显的性暗示。从克蕾丝那身蓝紫色的衣着与阿莱莎就读学校学生校服的颜色一致我们可以得知克蕾丝有可能是那所学校的老师，如果要宣传一种宗教，那么从孩子抓起完全是可能的，何况在西方并不是没有教会学校。那么也就是说孩子们认为阿莱莎是女巫除了有片中提到“父母的灌输”以外，很有可能有克蕾丝老师的教唆和命令。其中克蕾丝找阿莱莎的生母谈话时曾关门推走了几个好奇的学生，由此得知她们谈话的地点就是学校，能在学校召见家长的，除了老师还有谁呢？而正是因为学生们被克蕾丝唆使欺负阿莱莎，她才会躲进厕所而遭强奸，因而完全可以得知阿莱莎这样杀死克蕾丝是对其行为导致自己遭到强奸的报复。最后，阿莱莎将克蕾丝一分为二，正是让其知道阿莱莎受火刑而痛苦地分裂为一个善良体和一个邪恶体的感受，所谓以其人之道还其人之身，而教堂这场屠杀正是犹太教末世论和条顿化基督教对最后审判日观念的体现，或许走进寂静岭就是打开了《圣经》。<br>其实片中众多的性暗示除了可以从阿莱莎的经历解释外，也可以从影片导演的话看出一些内容——“我喜欢女人，喜欢和美国婊子做爱。我想拍一部到处都是性感女人的电影，没一个男人。我不想处理和男人有关的东西。”只是可怜了这些女演员们一次又一次成为了导演们“意淫”的对象。</p><p>对于《寂静岭》中杂项的解释试探：<br>1.寂静岭中的真实世界与表世界，真实世界与里世界都可以以一定方式联系，此处可以从罗丝给丈夫的电话，女警察发给总部的求救，丈夫闻到罗丝的香水味得知。<br>2.阿莱莎是通过自己邪恶面造成的车祸的方式，用神秘的力量将罗丝和女警察拉进寂静岭表世界空间里的，这可以从很多相关资料中得到证明。女警察很有可能是阿莱莎故意拉进寂静岭以用来保护罗丝完成任务的。女警察跟踪母女俩的原因是女警察曾去寂静岭调查过一个杀人狂将一男孩塞进煤矿通风管道的案件，进而对想去被废弃小镇的大人加小孩的组合加以怀疑。对于有资料认为曾有克蕾丝身边一个塑料女模特是暗指女警察这点不予支持，我认为之所以有这种想法是因为女警察头发短而塑料人正好没头发导致看起来相似而已，而且到不如说那塑料是在暗指克蕾丝自己，被控制在寂静岭而又不自知的“傀儡”。<br>3.注意女警察的名字，西比尔，英文为“Cybil”，乍看来就是一个普通的英文名字而已。但是英文中“女巫”一词，除了常用的“witch”以外，还有两个词，分别是“sybil”和“sibyl”，为女巫、女算命师和女预言师的意思。有没有发现，其实这两个词中第一个词与女警察的名字“Cybil”只相差了一个首字母而且它们的发音是一致的？有没有发现第二个词“sibyl”仅仅是把第一个词“sybil”中间的两个字母“y”和“i”调换了一下位置，而且它的发音也与“Cybil”一致呢？也就是说，女警察的名字本身就是“女巫”或者说被设定为“女巫”的谐音，这又是一个暗示，暗示女警察Cybil被烧死（与女巫被处死的方式一致）的结果。<br>4.真实世界转换与表世界怪物出现时会造成收音机、手机等电子产品噪音这点是对游戏的还原，无科学解释。<br>5.里世界经常出现的风扇的喻义：一个是工业生产本身必须的通风设备，也是后工业艺术风格的元素，也是里世界压抑的工业运行声音的来源，也是对里世界就是“绞肉机”的暗示，而且也有宗教观点认为地狱的运行就是“铁轮”来回转动的原因。<br>6.教徒们用来对表里世界转换的报警工具是笼子里的鸟，这也是今天用于监测煤矿一氧化碳含量的工具。<br>7.片中寂静岭的世界周围都是悬崖，这也是被困在这个空间里的人跑不出去的原因。即使能跑出去，另外的地方也是表世界也是表世界的延伸，会转成里世界，所以不如老老实实呆在教堂里避难。<br>8.不支持片头NATHAN旅馆下的“DRUGS”（药的意思，也指毒品）是对小镇贩毒的暗示。这是游戏里的情节，电影中没有交代。这最多就是对游戏的还原，如果是暗示也只能是暗示教徒们对他们宗教的信仰如吸毒一般。<br>9.片中出现的男警察就是当年在寂静岭从火刑架上救下阿莱莎的男警察，因为是好人，所以没有被阿莱莎困在寂静岭世界的空间里。<br>10.罗丝拿到画的信箱号是111，后来在旅馆中找到火刑画后面的房间（就是当年阿莱莎受火刑的房间）也是111，一处明显的暗示。<br>11.女警察护送罗丝下电梯时与几个穿防护服的教徒发生打斗，她曾经将一人隔着防护服打得头部直接喷血，这样的人还能再爬起来对女警察进行殴打，我觉得施瓦辛格也不行！坚定为硬伤！<br>12.不清楚这点应该如何解释：片中已经告知，阿莱莎拥有邪恶力量引发的大火使寂静岭废弃是在1974年，罗丝来寂静岭已经是2006年，中间已经有32年时间。但是从片中克蕾丝前后32年的模样我们可以发现她几乎没有什么变化，也就是说有可能被困在寂静岭的人已经停止生长了，因为从寂静岭表世界建筑的破旧可以得知如果不是有年头的话是不会出现这种情况的。而且认为安娜就是阿莱莎以前同学的说法也是不可能的，因为她怎么看也就二十多岁，绝对不像三十多岁或者四十多岁的人，1974年可能她还没有出生呢。而阿莱莎只可能把迫害过她的教徒拉进她的空间，因此看来教徒从1974年以来就停止生长是正确的，而奇怪的是最后屠杀时的阿莱莎本体却已经是成年人的体形了，可以可见她却是一直生长的。疑问就在于即使人不生长了，但是片中的人还是得出来找食物的，在寂静岭那样的环境中任何种植和食品加工都是不可能的，我们也看到安娜找的都是一些以前寂静岭剩下的食品罐头。但是请注意！什么罐头的保质期能保证32年呢？寂静岭里又有多少罐头能供那么多人维持32年呢？而且寂静岭里的人的水又从哪里来的？自来水厂肯定是一片废墟了，片中说寂静岭边的河也被绝壁隔住了。里世界似乎下雨，但是里世界的雨水能喝吗？即使能喝，能供应这么多人吗？里世界的雨水会不会随着世界的转化一样消失掉？如果说寂静岭的人是被“延缓”而不是被“停止”以解释教徒的年龄的话，那么当年解救过阿莱莎的男警察又怎么解释呢？假设1974年他只有20岁，2006年他也有52岁了，但是片中他最多三十多岁而已，他不在寂静岭的世界怎么年龄也被“延缓”了呢？<br>13.罗丝带着阿莱莎开车回家，虽然出了寂静岭，世界也仍是一片灰色，来寂静岭的路上热闹的加油站也空无一人。回到家时，电影用罗丝在灰蒙蒙的寂静岭与丈夫所在的黄澄澄的真实世界的反复交替出现来说明罗丝其实是被永远困在了寂静岭的表世界里。原因很简单，当时的莎仁其实是阿莱莎的邪恶面通过对视与莎仁融为一体之后的人，或者说，莎仁已经不存在了。没有发现回家后的莎仁有一种成人的眼神，并且仿佛从来没有来过自己的家一样，进屋之后有种好奇感？阿莱莎就是因为曾经被自己的生母抛弃给教徒，而从罗丝这里感受到真正母爱，而想把罗丝永远困在寂静岭的世界里以独享母爱！“莎仁”上车之后吸手指的动作就是在使用神秘力量，她吸手指之后，原本不能发动的汽车发动了。有文章认为车是从悬崖上“飞”出去的，我觉得不是，从车经过悬崖的画面明显可以发现原来的绝壁上已经出现了一座桥梁，这也是车上的莎仁吸手指使用神秘力量延伸出来的结果，最后表世界的空间被一直延伸到罗丝的家。我认为，劫难之后的罗丝其实已经知道自己的女儿不是原来的莎仁了，也知道自己将永远被困在寂静岭的表世界，否则她怎么就上去去试图开动这辆之前已经开过但却无效的车呢？罗丝原本也知道寂静岭四周是无路可走的虚悬，怎么就敢开车往外走呢？原因就是她知道“莎仁”或者说阿莱莎不会让车掉进悬崖而一定会让自己开车出寂静岭。世界仍是一片灰色和加油站的空落罗丝不可能没有察觉，最后她进屋后直愣地望着沙发，就是她感觉到了自己丈夫的存在，但却也知道这种“两个空间”的存在是咫尺天涯了。其实者这一切都是阿莱莎安排好的，她将自己的善良面莎仁送出寂静岭险恶的地方被人收养，长大到自己受火刑的年龄再招回寂静岭，复仇并完成合体，然后独享母爱。</p><p>寂静岭所要表达的主题：<br>1.母爱：体现在罗丝面对如此艰险的环境还义无返顾地寻找女儿，阿莱莎的生母无论在里世界还是在最后审判中都安然无恙。女警察一句“在孩子的眼中，母亲就是上帝”和罗丝对其的引用，以及女警察被烧死时也喊母亲、都揭示了这一点。<br>2.后工业时代：一如美国甚至世界各国在后工业时代没落的工业城市，寂静岭也象征一个时代的终结。<br>3.宗教反思：阿莱莎是因为私生女所以才被当地的“邪教”组织所不容，类似的还有旧中国某些某些地区女人未婚先孕就要被淹死的陋习。美国本身是一个新教国家，而中世纪天主教在欧洲烧死的“女巫”则不计其数，无数无辜的人被以各种名义施以火刑处死，沦为宗教狂热和愚昧的牺牲品。最荒谬的更有1474年巴塞尔城曾因为一只公鸡下蛋（公鸡中的战斗机？）被视为“女巫”而烧死！美国本身在成立之前也有从欧洲大陆来的各种教派，导致今天美国各种名目繁多的宗教组织。在美国建国前的混乱状态，各教派都认为对方是“异端”，结果就是更多人因为“异端”或“女巫”被推上火刑架。所以《寂静岭》不仅是基督教新教对天主教的反思，也是美国新教本身对自己的反思，一如阿莱莎生母说：“我们的信仰是我们的掘墓人。”<br>4.对善恶的思考：电影中借男警察之口道出“魔鬼也有自己的正义”，如果正义用邪恶的手段摧毁邪恶，那么它究竟是正义还是邪恶？究竟什么是善和恶？是否存在一个绝对的标准？<br>5.赎罪/审判之地：这本来是游戏《寂静岭2》所要表达的主题，在这里同样适用。寂静岭其实就是每个人心中的道德底线，是每个人最后都要受到的自我拷问。那些做了坏事的人最终都要被最后审判，赎罪的方式就是接受审判，就像电影中那些教徒，那些为恶又自我开脱而不自知的人，早晚都要受到魔鬼的最后审判！<br>寂静岭是一个恐怖、压抑而又充满魅力的地方，我不知道为什么我给文章标题鬼使神差地写上了“带我回到寂静岭”，仿佛我曾经去过，或许那里对人的内心有种神秘的感召力。李安导演在奥斯卡获奖时曾经说人人心中都有一座断臂山，如果真是这样的话，那么我认为每个人心中也有一座寂静岭，那是每个人心中的自我审判，是每个人最后都要回到的地方..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;寂静岭-影评&lt;/strong&gt;   &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;看完电影寂静岭之后想自己写一篇影评但是由于自己腹中实在没有什么干货，写不出来~~~（还是得多看书啊）&lt;br&gt;从网上看到了一篇讲解的非常全面的影评，看了这个影
      
    
    </summary>
    
      <category term="影评" scheme="http://indexcode.cn/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="个人分享" scheme="http://indexcode.cn/tags/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>狩猎-影评</title>
    <link href="http://indexcode.cn/2017/12/2017.12.04%20%E7%8B%A9%E7%8C%8E-%E5%BD%B1%E8%AF%84.html"/>
    <id>http://indexcode.cn/2017/12/2017.12.04 狩猎-影评.html</id>
    <published>2017-12-04T06:52:50.182Z</published>
    <updated>2017-12-05T10:44:23.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>狩猎-影评</strong>   <Excerpt in index | 首页摘要><br>好几天没更博了，想着总要写点儿什么，锻炼一下我的写作能力，嘿嘿嘿~<br>不得不说的是，这几天我过的很爽哈，一下看了好几天的电影，都是名气很高的电影，看完电影之后就想着写一下影评抒发一下我的看法~不过自己的文笔不太好，所以就转载一篇吧~</p><p>看完了《狩猎》，这是一部丹麦的电影；导演托马斯·温特伯格，曾是丹麦电影学院有史以来最年轻的入学学生，而且表现出色。</p><p>影片最让我动容的是对人性的刻画。好了，就让我转载一个我所认同的影评吧~ <a href="https://movie.douban.com/review/5818670/">原文地址</a></p><p>一部寒冷彻骨的电影。不温不火的叙事和冷静理智镜头之中酝酿了近乎绝望的压抑、狂躁与寒冷，这部丹麦电影就像北欧的冬天一样寒冷，在颤栗中毫不留情的在人性与社会道德划上深入骨头的一刀。</p><p>这部电影的观影过程绝对不是一个愉快的过程，片中酝酿的一种冷而近乎绝望的氛围让整部电影张力饱满，郁结到近乎暴戾的怨气充斥胸腔，让人意志中的理智与情感大乱阵脚，剧情爆炸式的张力让整部电影的氛围处在一种极其微妙、一触即发的精确位置，而这种微妙张力来源于人内心之间的斗争。所谓三人成虎，但这部电影不仅仅是一个三人成虎的故事，儿童在影片中游离于天使与恶魔之间的设置，让这个三人成虎的故事变得更加深刻和让人不寒而栗，西方国家对儿童的保护和重视也在此片中可见一斑，孩子的话往往是纯真而无意的，但是这种无意的“孩子话”要是沾上社会道德禁区，并被误解，那纯真便可以变成剧毒的毒药，很遗憾，影片中的主人公就是一个不幸中毒的倒霉蛋，孩子自然可以不为自己的话负责，短浅的人生阅历让他们在社会的地位中一无所有，而对于一个成年人来说，社会中的一席之地近乎可以是他们的全部，当这些被毁灭时，就意味着个人的社会性被抹掉，对于一个有理智成年人来说，这是一种变相的谋杀。片中男主角的反应似乎略显迟钝，自我维护也是到了最后才迸发，可是细心的可以发现，在铺垫段落，男主角与孩子的互动之中，与女朋友的交往之中，我看到了男主角身上隐隐约约的被动性格，这种人，往往木讷而善良。</p><p>孩子算社会中的特殊的弱势群体，他们在生理和心理上都不成熟，保护自我的能力薄弱，所以一旦发生疑似侵犯儿童的事，社会群体总是会毫无保留的站在孩子的这一端而群起攻之，但是当这种社会性的毫无保留被曲解和误用的时候，孩子就由天使变成了魔鬼，孩子尚未健全的人格和辨识力让社会常规、合理的解决途径在此无路可通，于是他们的话往往带来巨大的破坏性，影片中卢卡斯的生活就被一两句近似胡话的童呓毁灭，但毁灭过程最大的破坏力并不是由孩子直接带来的，而是由社会群体的排斥和异化所带来的，人毕竟还是群居动物，当一个人被孤立和异化的时候，这种隔阂带来的对人的伤害是巨大的，更何况这种排斥和有意的异化是冤屈的，影片的张力便是建立在这种排斥和冤屈的对立上，精准到位的把这种恶毒的人际对立和人物内心的崩塌完美的展现了出来。谣言猛于虎，而当社会伦理禁区的谣言来自天真的孩子，这种破坏力则更加猛烈，影片中，在丑闻和随之而来的各种谣言面前，社会群体之间的对立逐渐变得立体而猛烈，从开始的将信将疑留有余地，到最后近乎整个社会群体的排斥，影片在似乎平静的氛围中酝酿下了更大的恶意，当观众以男主角为第一人称带入故事时，这种慢慢酝酿而来的恶意和仇恨近乎可以演化成反社会的暴戾情绪，一股积郁的愤怒迟迟无法爆炸最终竟成了彻骨的寒意。</p><p>影片的前半个小时感觉有点云里雾里不知所云，切入过慢，但是一过这个节点，影片便开始展开其爆炸性的张力，导演对镜头的处理平静而理智，就像影片中主人公开始对自己理智的克制一样，但是到了后半段，主人公的理智开始摇晃时，影片的镜头仍然平静如初，这种镜头内的躁动和镜头外的平静理智，让观众产生一种由内及外的愤怒，甚至萌生反社会的暴戾情绪，正是因为镜头冷峻的袖手旁观与故事内的爆炸张力产生的强烈对比，为主人公鸣不平却无可奈何而产生的强烈观影共鸣，带来了极大的带入感和精准的人物塑造。本片的导演托马斯•温特伯格轻松的把观众的情绪玩弄于鼓掌之中，这正是这位丹麦导演的功力所在。这种沉重的社会题材电影往往可以给人带来更多的思考，不论是去年的《爱》还是以往的更多欧洲社会题材电影。影片最让我印象深刻的是在教堂的一幕，男主角非常讽刺来到教堂这个乞求救赎的地方，顶着上帝普世之爱的光环这或许是唯一能让他这个“罪人”和一社区“善人”平静共处一室的地方，当孩子们用天使般的声音开始唱圣诞颂歌时，这种恶与纯真的巨大反差让男主角的理智处于崩溃边缘，但是终究理智还是没有崩溃，这种人社会性的属性永远也抹不去，不然他会去绕过卡拉的爸爸，直接对孩子下手，理智告诉卢卡斯孩子是无辜的，卢卡斯只能找卡拉的爸爸出气，我想这是终究个错误的判断，因为最后的一幕非常明确的说明了，这整个闹剧最大的罪魁祸首，并不是卡拉，也不是卡拉做出错误判断的父亲，而是卢卡斯所处的这整个社会的偏见，影片结尾成人仪式非常值得玩味，猎枪的承接和周遭暧昧不清的笑容让人寒颤，成年意味着力量和责任，而也意味着代价，社会族群可以这样接纳你，给予你一定的位置，也可以迅速的像对卢卡斯那般，残忍的把你除名。电影最后那意味深长的一枪是谁开的其实并不重要，它最大的价值便是打醒那些做梦的人，而背后的开枪者，只是一个模糊的轮廓，导演的意图很明确，这个轮廓是为所有人设计的。</p><p>“狩猎”这个片名有一定的意味，显然卢卡斯就是社会群体森林中那只被追猎的麋鹿，毫无防备，甚至心怀感激的袒露在黑暗森林之中，无数躲在暗中的猎人可以中伤他，而最后那惊人心魄的一枪，既可以视为恶意的中伤，也可视为善意的警告，但想要表达的暗示都是同一点：走吧，这片森林再也不欢迎你了。这种无意引起的社会群体对个人的排斥，让人看清社会的部分阴暗面貌，深刻见底，暂时不提娈童的恶，说说群体性的排斥，在浩荡历史上，这种多数人对少数人偏见和迫害又能少到哪去？从异教徒到同性恋，从布鲁诺到图灵，这种恶毒的幽灵一直活着，至今伊朗仍对同性恋处予恶毒的石刑，别以为它们离我们很远很远，即使到了今天，它仍然活生生在我们周围匍匐着，无法忽略卡拉作为导火索在事件中起的恶劣作用，但是最可恶的并不是孩子，而是那群虚伪的，带有偏见的，先入为主的，自封卫道士的傲慢大人们，要知道无知并不是文明最大的障碍，傲慢才是。影片的所谓的刻意其实并不过分，这种滑稽天方夜谭似的连锁事件时刻在我们所处的世界上演，如果你细心留意。感谢最后的一枪把我所有的幻想和美好愿景都打了个粉碎。心中郁结已久的戾气最后居然被这突然而来的枪声惊吓冻结成了冰块，一股彻骨的寒意弥漫全身。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;狩猎-影评&lt;/strong&gt;   &lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;好几天没更博了，想着总要写点儿什么，锻炼一下我的写作能力，嘿嘿嘿~&lt;br&gt;不得不说的是，这几天我过的很爽哈，一下看了好几天的电影，都是名气很高的电影，看完电影之后就想
      
    
    </summary>
    
      <category term="影评" scheme="http://indexcode.cn/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="个人分享" scheme="http://indexcode.cn/tags/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之V8引擎</title>
    <link href="http://indexcode.cn/2017/11/2017.11.25%20JavaScript%E4%B9%8BV8%E5%BC%95%E6%93%8E.html"/>
    <id>http://indexcode.cn/2017/11/2017.11.25 JavaScript之V8引擎.html</id>
    <published>2017-11-25T11:47:31.703Z</published>
    <updated>2019-02-23T10:22:23.281Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JavaScript之V8引擎</strong>     <Excerpt in index | 首页摘要><br>V8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用于Google Chrome中。<br>V8在执行之前将JavaScript代码编译成机器码让计算机识别执行，而非字节码或者直译它，以此来提升效能，JavaScript程序与V8引擎的速度可以媲美二进制编译。在高性能JavaScript一书中作者有比较V8引擎与其他语言的执行速度，作者列成了图表很清楚的显示出JavaScript引擎V8不俗的执行速度。</p><p>V8是Google Chrome浏览器内置的JavaScript脚本引擎。<br>Google Chrome使用V8的API，但引擎的内核部分是独立于浏览器之外的。<br>V8引擎编译和执行JavaScript源代码。<br>速度是V8引擎追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码 + 解释器”的引擎，优势不言而喻。<br>V8引擎的团队说Chrome对脚本的解析和执行速度是Firefox和Safari的10倍，是IE的56倍。当然了，自夸自家的瓜甜，都是这样的嘛~最近不是新出了Safari又比Google Chrome快了80%的速度吗~但是只是因为Safari更新的比较快，优化了最新的ES6，所以与之前未做优化的Chrome相比快了不少~也是真能吹牛哈~</p><hr><p>正是由于V8的高性能，所以基于nodejs开发的引擎就是V8引擎。</p><hr><p>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。V8的JavaScript渲染引擎亮点在于更快速更强壮的JavaScript解析。V8是一个非常反传统的JavaScript引擎，它能够在后台动态的对JS的对象进行分类——一个在其他高级语言中很常见但JS本身不支持的特性。V8对JS的解析不是基于反复loop源代码进行解释而是直接将JS代码编译成机器码运行。换句话说，V8引擎实际上可以看做是JS的扩展和编译器——而传统上类似于JS的解释型语言恰恰是不需要编译器的。最后，高级语言的内存管理效能一直是决定其运行效率的重要因素，而当前的JS虚拟机在这方面做的比较基本，对内存的回收也非常保守。V8使用的是非常强势的内存管理策略，一切在运行堆栈里无用的数据都会被强行回收，从而可以大大提高JS代码的运行效率。<br>在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。</p><p>和Mozilla的SpiderMonkey一样，Google Chrome浏览器的JavaScript引擎Google V8也是一个开源的独立引擎，可内嵌于任何C++工程之中。</p><blockquote><p>速度是V8追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码+解释器”的引擎，优势不言而喻。在SunSpider测试中，V8的综合表现是最好的。据说Mozilla正在开发的TraceMonkey比V8还要快20%左右，可惜尚未完工。</p></blockquote><h1 id="JavaScript的发展"><a href="#JavaScript的发展" class="headerlink" title="JavaScript的发展"></a>JavaScript的发展</h1><blockquote><p>Netscape Navigator 在 90 在年代中期对 JavaScript 进行了集成，这让网页开发人员对 HTML 页面中诸如 form 、frame 和 image 之类的元素的访问变得非常容易。由此 JavaScript 很快成为了用于定制控件和添加动画的工具，到 90 年代后期的时候，大部分的 JavaScript 脚本仅仅完成像“根据用户的鼠标动作把一幅图换成另一幅图”这样简单的功能。</p><p>随着最近 AJAX 技术的兴起，JavaScript 现在已经变成了实现基于 web 的应用程序（例如我们自己的 Gmail）的核心技术。JavaScript 程序从聊聊几行变成数百 KB 的代码。JavaScript 被设计于完成一些特定的任务，虽然 JavaScript 在做这些事情的时候通常都很高效，但是性能已经逐渐成为进一步用 JavaScript 开发复杂的基于 web 的应用程序的瓶颈。</p><p>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。其中的原因在你读过这份文档余下的部分之后就会明白了。</p></blockquote><h1 id="V8-的性能提升主要来自三个关键部分："><a href="#V8-的性能提升主要来自三个关键部分：" class="headerlink" title="V8 的性能提升主要来自三个关键部分："></a>V8 的性能提升主要来自三个关键部分：</h1><ol><li>快速属性访问</li><li>动态机器码生成</li><li>高效的垃圾收集</li></ol><h2 id="快速属性访问"><a href="#快速属性访问" class="headerlink" title="快速属性访问"></a>快速属性访问</h2><p>JavaScript 是一门动态语言，属性可以在运行时添加到或从对象中删除。这意味着对象的属性经常会发生变化。大部分 JavaScript 引擎都使用一个类似于字典的数据结构来存储对象的属性，这样每次访问对象的属性都需要进行一次动态的字典查找来获取属性在内存中的位置。这种实现方式让 JavaScript 中属性的访问比诸如 Java 和 Smalltalk 这样的语言中的成员变量的访问慢了许多。成员变量在内存中的位置离对象的地址的距离是固定的，这个偏移量由编译器在编译的时候根据对象的类的定义决定下来。因此对成员变量的访问只是一个简单的内存读取或写入的操作，通常只需要一条指令即可。</p><p>为了减少 JavaScript 中访问属性所花的时间，V8 采用了和动态查找完全不同的技术来实现属性的访问：动态地为对象创建隐藏类。这并不是什么新的想法，基于原型的编程语言 Self 就用 map 来实现了类似的功能（参见 An Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language Based on Prototypes ）而且JavaScript在创建之初因为是赶时间赶出来的（10天的时间，而且还是Brendan Eich为了应付公司安排的任务的~），所以也正是借鉴了很多语言的长处，也就是上面所说的self语言和C语言等等（有一句话说的好：与其说我爱JavaScript，不如说我恨她；她是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：“她的优秀之处并非原创，她的原创之处并不优秀”）。在 V8 里，当一个新的属性被添加到对象中时，对象所对应的隐藏类会随之改变。</p><p>下面我们用一个简单的 JavaScript 函数来加以说明：</p><p><code>function Point(x, y) {    this.x = x;    this.y = y;}</code></p><p>当 new Point(x, y) 执行的时候，一个新的 Point 对象会被创建出来。如果这是 Point 对象第一次被创建，V8 会为它初始化一个隐藏类，不妨称作 C0。因为这个对象还没有定义任何属性，所以这个初始类是一个空类。到这个时候为止，对象 Point 的隐藏类是 C0。</p><p>map_trans_a<br>执行函数 Point 中的第一条语句（this.x = x;）会为对象 Point 创建一个新的属性 x。此时，V8 会：<br>在 C0 的基础上创建另一个隐藏类 C1，并将属性 x 的信息添加到 C1 中：这个属性的值会被存储在距 Point 对象的偏移量为 0 的地方。<br>在 C0 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 x 之后能够找到 C1 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C1。</p><ol><li>map_trans_b<br>执行函数 Point 中的第二条语句（this.y = y;）会添加一个新的属性 y 到对象 Point 中。同理，此时 V8 会：<br>在 C1 的基础上创建另一个隐藏类 C2，并在 C2 中添加关于属性 y 的信息：这个属性将被存储在内存中离 Point 对象的偏移量为 1 的地方。<br>在 C1 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 y 之后能够找到 C2 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C2。</li><li>map_trans_c<br>咋一看似乎每次添加一个属性都创建一个新的隐藏类非常低效。实际上，利用类转移信息，隐藏类可以被重用。下次创建一个 Point 对象的时候，就可以直接共享由最初那个 Point 对象所创建出来的隐藏类。例如，如果又一个 Point 对象被创建出来了：<br>一开始 Point 对象没有任何属性，它的隐藏类将会被设置为 C0。<br>当属性 x 被添加到对象中的时候，V8 通过 C0 到 C1 的类转移信息将对象的隐藏类更新为 C1 ，并直接将 x 的属性值写入到由 C1 所指定的位置（偏移量 0）。<br>当属性 y 被添加到对象中的时候，V8 又通过 C1 到 C2 的类转移信息将对象的隐藏类更新为 C2，并直接将 y 的属性值写入到由 C2 所指定的位置（偏移量 1）。</li></ol><p>尽管 JavaScript 比通常的面向对象的编程语言都要更加动态一些，然而大部分的 JavaScript 程序都会表现出像上述描述的那样的运行时高度结构重用的行为特征来。使用隐藏类主要有两个好处：属性访问不再需要动态字典查找了；为 V8 使用经典的基于类的优化和内联缓存技术创造了条件。</p><h2 id="动态机器码生成"><a href="#动态机器码生成" class="headerlink" title="动态机器码生成"></a>动态机器码生成</h2><p>V8 在第一次执行 JavaScript 代码的时候会将其直接编译为本地机器码，而不是使用中间字节码的形式，因此也没有解释器的存在。属性访问由内联缓存代码来完成，这些代码通常会在运行时由 V8 修改为合适的机器指令。</p><p>在第一次执行到访问某个对象的属性的代码时，V8 会找出对象当前的隐藏类。同时，V8 会假设在相同代码段里的其他所有对象的属性访问都由这个隐藏类进行描述，并修改相应的内联代码让他们直接使用这个隐藏类。当 V8 预测正确的时候，属性值的存取仅需一条指令即可完成。如果预测失败了，V8 会再次修改内联代码并移除刚才加入的内联优化。</p><p>例如，访问一个 Point 对象的 x 属性的代码如下：</p><p>point.x</p><p>在 V8 中，对应生成的机器码如下：</p><p><code>; ebx = the point objectcmp [ebx, &lt;hidden class offset&gt;], &lt;cached hidden class&gt;jne &lt;inline cache miss&gt;mov eax, [ebx, &lt;cached x offset&gt;]</code></p><p>如果对象的隐藏类和缓存的隐藏类不一样，执行会跳转到 V8 运行系统中处理内联缓存预测失败的地方，在那里原来的内联代码会被修改以移除相应的内联缓存优化。如果预测成功了，属性 x 的值会被直接读出来。</p><p>当有许多对象共享同一个隐藏类的时候，这样的实现方式下属性的访问速度可以接近大多数动态语言。使用内联缓存代码和隐藏类实现属性访问的方式和动态代码生成和优化的方式结合起来，让大部分 JavaScript 代码的运行效率得以大幅提升。</p><h2 id="高效的垃圾回收机制"><a href="#高效的垃圾回收机制" class="headerlink" title="高效的垃圾回收机制"></a>高效的垃圾回收机制</h2><p>V8 会自动回收不再被对象使用的内存，这个过程通常被称为“垃圾收集（Garbage Collection）”。为了保证快速的对象分配和缩短由垃圾收集造成的停顿，并杜绝内存碎片，V8 使用了一个 stop-the-world, generational, accurate 的垃圾收集器，换句话说，V8 的垃圾收集器：</p><ol><li>在执行垃圾回收的时候会中断程序的执行。</li><li>大部分情况下，每个垃圾收集周期只处理整个对象堆的一部分，这让程序中断造成的影响得以减轻。</li><li>总是知道内存中所有的对象和指针所在的位置，这避免了非 accurate 的垃圾收集器中普遍存在的由于错误地把对象当作指针而造成的内存溢出的情况。</li></ol><p>在 V8 中，对象堆被分成两部分：用于为新创建的对象分配空间的部分和用于存放在垃圾收集周期中生存下来的那些老的对象的部分。如果一个对象在垃圾收集的过程中被移动了，V8 会更新所有指向这个对象的指针到新的地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JavaScript之V8引擎&lt;/strong&gt;     &lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;V8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用
      
    
    </summary>
    
      <category term="认知提升" scheme="http://indexcode.cn/categories/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="JavaScript" scheme="http://indexcode.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>变化</title>
    <link href="http://indexcode.cn/2017/11/2017.11.22-%E5%8F%98%E5%8C%96-%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F.html"/>
    <id>http://indexcode.cn/2017/11/2017.11.22-变化-个人感悟.html</id>
    <published>2017-11-22T10:18:49.645Z</published>
    <updated>2017-12-20T09:41:11.433Z</updated>
    
    <content type="html"><![CDATA[<p><strong>变化</strong>   <Excerpt in index | 首页摘要><br>最近挺多时间都在看一些博客。看的最多的当属<strong>编程随想</strong>的博客了，看了这位大神写的关于计算机的好多东西，感觉收获好多，而且边看边觉的这个大神过的日子真是爽歪歪啊。可以在网上随意的发言，想说什么就说什么，不论敏感与否发表自己的看法，而且现在做的事情是自己最喜欢的工作。真是羡煞旁人啊~当然做这些的基础他也分析了，想要这样做，你还要懂得相当多的计算机的知识啊！感觉自己现在技术上还是相关的知识上还是有太多的不足啊~在阅读大神博客的时候，遇到不懂的知识我总要问一下度娘，查阅一些相关的术语，由于浏览最近浏览网页的时间很长，所以网页上的轮播图类的广告推广真的是很影响阅读啊！这就是我今天写这篇博客的原因啦~<br>给大家介绍一个屏蔽网页广告的软件，ADSafe，并且由这个软件引发了一系列的引人思考的东西~大家也可以思考一下如今的时代下广告带给我们的利弊和一系列其他的问题。</p><h1 id="ADSafe"><a href="#ADSafe" class="headerlink" title="ADSafe"></a>ADSafe</h1><p>首先介绍一下这款软件吧，这是一款可以拦截所有浏览器及视频广告，偶尔有些无法拦截的，可以自定义一下。它的自定义功能很强，能完全满足我们的需要。是由上海大摩网络科技有限公司开发的，这是一家位于上海的小公司。是个公司就要生产产品，目标就是要实现盈利，比如这家小公司，开发的这款软件真的是很好用，但是他的盈利点在哪儿呢？在网上搜索了一下，官网都没有说呢，但是在别的地方例如贴吧和个人博客等等都提及到了他的盈利点，就是隐式的注入他自己的广告。有一句话说的好，贼喊捉贼，灯下黑~真是让人不敢相信啊！遇见了这个问题，有一些人选择了立马卸载，有一些人选择了谅解和支持。透过这个问题让我想到了如今火爆非常的盗版..<br>那我们今天就来聊一聊这个盗版问题吧~<br>说起盗版或者说山寨，有人欢喜有人忧啊~欢喜的是不用花钱就能玩到开发者好不容易开发出的游戏或者其他产品，忧愁的又是谁呢？当然是开发者了，浪费了大量的人力物力，最后竹篮打水一场空，被别人非常轻易的模仿了/抄袭了..一些非常优秀的产品追其本意本就应该是让人使用的，但是开发者浪费了如此大的人力物力的成本，难道不应该为这些付出的汗水得到一些回报吗？美国自由软件运动的精神领袖理查德·马修·斯托曼，他被血多人誉为当今自由如那件的斗士、伟大的理想主义者，但同时也有好多人批评他过于固执、观点落伍。确实，在商业中的话，他就是一个固执的盈不了利的商人，但是如果在如今的现实中的话，免费软件还是非常受欢迎的。这也导致了很多商业游戏公司或者其他的一些以互联网产品为盈利的产品走向了终结，例如：在互联网初期的单机游戏是非常火爆的，而且出现了很多成功的以开发单机游戏的游戏公司，但是没过多久，随着盗版产品的猖獗，越来越多的单机游戏被盗版游戏所取代，卖不出去的单机游戏公司最后的结局相信大家都能看到了..想当时，出现了多少经典优秀的单机游戏，而现在，因为所有的东西总离不开利益的驱使，当单机游戏的开发利益与付出不成正比的时候，那么资本把这个产业弃掉也就不令人感到意外了。所以如今的游戏开发变成了什么呢？变成了网络游戏，必须连上网才能进去游戏，这样就没有了盗版这一途径的污染了，但是又出现了抄袭的风险，例如腾讯的游戏，被大众说成是什么游戏火就抄什么游戏，因为腾讯掌握着用户这把无往不利的利器，任何人都斗不过他..渠道为王的时代，也就不意外前几天报道腾讯的市值已经超半万亿美元了。</p><h1 id="有利有弊"><a href="#有利有弊" class="headerlink" title="有利有弊"></a>有利有弊</h1><p>对啊，什么事情都是有利有弊的，也许时代会回答我们的疑问，等着未来的答案吧。也许现在我们认为的弊端到了未来就成为有利的条件了。万物都不绝对，事件的两面性我们在很小的时候就懂了，不过我们真正的认识到这个事实是很难的..由理查德·斯托曼在1983年启动的GUN系统计划，带给了我们多么大的利处，发明了目前最好的操作系统，Linux的出现，运行于用户空间的软件，都可以在Linux上使用，Linux操作系统的诞生，不是一个人的力量，而是互联网史上最大规模的团队合作，而且是无偿的团队合作，完全是出自团队成员之间的编程乐趣，而这样造就出来的操作系统却成为了世上最优秀的系统，让我们感到惊奇的同时又让我们感到确实应该是这样的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;变化&lt;/strong&gt;   &lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;最近挺多时间都在看一些博客。看的最多的当属&lt;strong&gt;编程随想&lt;/strong&gt;的博客了，看了这位大神写的关于计算机的好多东西，感觉收获好多，而且边看边觉的这个大神过的
      
    
    </summary>
    
      <category term="资源分享" scheme="http://indexcode.cn/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="个人感悟" scheme="http://indexcode.cn/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>幸存者偏见</title>
    <link href="http://indexcode.cn/2017/11/2017.11.19-%E5%88%86%E4%BA%AB-%E5%B9%B8%E5%AD%98%E8%80%85%E5%81%8F%E8%A7%81.html"/>
    <id>http://indexcode.cn/2017/11/2017.11.19-分享-幸存者偏见.html</id>
    <published>2017-11-19T13:45:03.712Z</published>
    <updated>2017-12-20T09:41:12.979Z</updated>
    
    <content type="html"><![CDATA[<p><strong>幸存者偏见</strong>   <Excerpt in index | 首页摘要></p><p>今天看<strong>编程随想</strong>大神的博客，又涨了点儿姿势，分享给大家吧~<br>先说一个“股神”–巴菲特在1984年哥伦比亚大学的演讲，是为了纪念《证券分析》出版50周年的。</p><blockquote><p>我要各位设想—场全国性的抛硬币大赛。让我们假定，全美国2.25亿人，在明天早晨起床时都掷一枚硬币，并猜硬币出现的正面或反面。如果猜对了，他们将从猜错者的手中赢得一美元。而猜错的人则被淘汰。每天都有输家遭到淘汰，奖金则不断地累积。经过十个早晨的十次投掷之后，全美国约有22万人连续十次猜对抛硬币的结果。每人所赢得的资金约1000多美元。现在，这群人可能会开始炫耀自己的战绩，此乃人的天性使然。即使他们仍保持谦虚的态度，但在鸡尾酒会中，他们偶尔会以此技巧吸引异性的注意，并炫耀他们对抛硬币的奇特洞察力。游戏继续进行，再经过十天，约有215个人连续20次猜对抛硬币的结果，并且每个人赢得大约100万美元的奖金。输家总共付出2.25亿美元，赢家则得到2.25亿美元。这时候，这群赢家会完全沉迷在自己的成就中——他们可能开始著书立说：“我如何每天早晨工作30秒，并在20天之内将—美元变成100万美元。”更糟的是，他们会在全国各地主办培训班，宣传如何有效地抛硬币。对那些持怀疑态度的学者，他们会反驳说：“如果你认为这是不可能的，该如何解释，为什么会有我们这215个人呢？”但是，某些商学院的教授可能会粗鲁地指出—个事实——假如让2.25亿只猩猩参加这场比赛，结果大致上也是如此——会有215只猩猩连续赢得20次的投掷。</p><p>然而，我必须说明，前述事例和我即将提出的案例，两者之间存在着若干重大差异。首先，<br>(a)如果你所选择的2.25亿只猩猩的分布状况大致上和美国的人口分布相同；<br>(b)如果经过20天的竞赛，只剩下215只赢家；<br>(c)如果你发现其中有40只猩猩来自于奥马哈的某个动物园，则其中必有蹊跷。</p><p>于是，你会询问该动物园的猩猩管理员，问此人各种问题。比如给这些猩猩吃什么饲料？这些猩猩是否做某些特殊的运动？是否看了什么书籍？……<br>换言之，如果你发现成功案例有非比寻常的集中现象，则你希望判定此异常的特色是否是成功的原因。</p><p>科学的调查也遵循此一形态。如果你试图分析某种罕见癌症的原因——例如，美国每年只有1500个病例——而你发现蒙大拿州的某个矿区小镇便产生400个病例，则你必然对当地的饮水、病患的职业或其他种种变数产生兴趣。你知道，在—个小镇中发生400个病例，绝不是随机因素所造成。虽然你未必了解病因，但你知道从哪里着手调查。</p><p>除了地理，还有其他方式可以界定起源。除了地理的起源，还有我所谓“智力的起源”。我认为各位将会在投资领域中发现——不成比例的抛硬币赢家来自于一个极小的智力村庄．它可以称为“格雷厄姆一多德都市”。这个特殊智力村存在着许多赢家．这种集中现象绝非巧合所能够解释。</p><p>在某些情况下，即使非比寻常的集中现象也可能不重要。或许有100个只是模仿某一位极具说服力的领导者，而依其主张来猜测硬币的投掷结果。当他猜正面，这100个追随者也会自动地做相同的猜测。如果这一位领导者是属于最后215位赢家之一，则这100也便属于同一个智力起源，这项事实便不具有任何意义，因为100个案例实际上只代表一个案例。同理，假定你生活在一个父权结构极为严密的社会，而美国每一个家庭都恰好以父亲马首是瞻。20天之后，你将发现215位赢家是来自于21.5个家庭。若干天真的分析师可能因此而认为，成功地猜测硬币投掷的结果，其中具有高度的遗传因素。当然，这实际上不具有任何意义，因为你所拥有的不是215个独立的赢家，而只是21.5个随机分布的家庭。</p><p>我所要考虑的这一群成功投资者，拥有一位共同的智力族长——本杰明·格雷厄姆。但是，这些离开此智力家族的孩童，都是依据非常不同的方法猜测他们自己的“硬币”。他们各自前往不同的地方，买卖不同的股票和企业，但他们的综合绩效绝对无法用随机因素加以解释。他们做相同的猜测，并不是因为领导者下达某一项指令，因此也无法用这种方式解释他们的表现。族长只提供了猜测硬币的智力理论，每位学生都必须自行决定如何运用这项理论。<br>……</p></blockquote><p>正好我最近也想学习一下股市相关的一些东西，说不定哪一天我头脑一热就载到炒股的世界里面成为一届股神了~在这儿就给大家分享一下这个演讲的背景吧~本文开头说了，这是为了纪念《证券分析》一书的。此书被誉为“价值投资领域的圣经”；作者是“本杰明·格雷厄姆”和“大卫·多德”，两人合著的这一经典。上世纪50年代，巴菲特曾经在哥伦比亚大学选修了格雷厄姆开设的“证券分析课程”，并得了A+的成绩。据传闻：格雷厄姆在哥伦比亚大学开设这门课程22年之后，才首次有学生（巴菲特）获得A+的成绩。</p><p>好了，说完了股神巴菲特的故事，继续咱们的主题，幸存者偏差：所谓幸存者偏差就是只看到了 显示 出来的事实，而忽略了 隐式 的一些结果，错把 显示 的样本当成了总样本，而得出了错误的结论。在大神的博客中，介绍了几个非常典型的例子，在这里我就借鉴一下吧~</p><h2 id="关于打仗的例子"><a href="#关于打仗的例子" class="headerlink" title="关于打仗的例子"></a>关于打仗的例子</h2><p>话说二战时的英国空军，经常派轰炸机去袭击德国。由于德国的防空火力较猛，轰炸机损失较惨重。为了降低飞机的损失，空军的领导们决定给飞机的机身进行装甲加固。由于当时条件所限，只能用装甲加固飞机上的少数部位。<br>　　然后，英国皇家空军就着手进行研究调查。他们对执行完轰炸任务返航的飞机进行仔细的观察、分析、统计。发现一个现象：大多数的弹孔，都集中在飞机的机翼上；只有少数弹孔位于驾驶舱。<br>　　假如你负责此事，你会用装甲加固哪个部位呢？估计很多同学会想当然地说：加固机翼（因为机翼的弹孔最多）。但是答案恰恰相反，【最不需要】加固就是机翼。为啥捏？<br>　　驾驶舱的弹孔最少，说明驾驶舱一旦中弹，飞机就载了，再也回不来。所以，它才是最应该加固的部位。</p><h2 id="关于网站的例子"><a href="#关于网站的例子" class="headerlink" title="关于网站的例子"></a>关于网站的例子</h2><p>假设有2家网站A和B，都经营类似的业务，都有相当多的用户群。再假设它们都进行了类似的网站界面改版。结果改版之后，网站A没有得到用户的赞扬，反而遭到很多用户的臭骂；而网站B捏，既没有用户夸它，也没有用户骂它。现在，请你来判断一下，哪个网站得人心？<br>　　估计又有不少同学会想当然地认为，网站B更受欢迎，毕竟用户没骂它。但事实并非如此。<br>　　网站A虽然遭到很多用户痛骂，但至少说明，还有很多用户在乎它；而对于网站B，用户对它已经心灰意冷，无所谓了，所以啥反应也没有。<br>　　末了，俺悄悄告诉大伙儿：网站A指的是 Facebook，网站B影射微软旗下的 Live Spaces。这俩都属于 SNS 类网站。想当初，Facebook 稍微改动了隐私条款，差点被用户的口水淹死；反观 Live Spaces，界面越改越土鳖，功能越改越差劲（俺曾经使用 Live Spaces 搭建过镜像博客，对此深有体会）。但又有多少 Live Spaces 的用户去找微软投诉呢？</p><p>知道这个道理容易，但是真正的应用到现实生活中就没有那么简单了。因为我们看到了一个显而易见的结果之后往往就不会往深处去琢磨了，是怕累死太多的脑细胞吗？所以当我们认识到一个显而易见的答案时，要想一下有没有“沉默证据”的存在，而不要当即断言这就是真实的结果，这个时候三思而行才是硬道理啊~如果你在分析某个案例时，不清楚属于上述哪一种情况，那么你需要尝试去排除“随机性”。如果无法排除，那么你就只好认可该案例是“随机性”驱动的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;幸存者偏见&lt;/strong&gt;   &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;今天看&lt;strong&gt;编程随想&lt;/strong&gt;大神的博客，又涨了点儿姿势，分享给大家吧~&lt;br&gt;先说一个“股神”–巴菲特在1984年哥伦比亚大学的演讲，是为
      
    
    </summary>
    
      <category term="资源分享" scheme="http://indexcode.cn/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="认知提升" scheme="http://indexcode.cn/tags/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://indexcode.cn/2017/11/2017.11.16%20vue%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92.html"/>
    <id>http://indexcode.cn/2017/11/2017.11.16 vue数据交互.html</id>
    <published>2017-11-16T13:35:41.524Z</published>
    <updated>2017-12-20T08:38:55.999Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Vue</strong> <Excerpt in index | 首页摘要><br>总结一下使用vue的一些方法吧~<br>用vue-cli来创建一个vue项目的过程：<br>首先在命令行工具页面输入：vue init <code>&lt;template-name&gt;</code> [project-name];之后按提示进行就行了。<br>创建成功脚手架之后打开创建成功的文件夹，在所在的文件夹下面：cnpm install 安装开发项目所需要的所有依赖；<br>npm run dev  运行本地测试开发开一个本地服务器。</p><h1 id="VUE中h-函数和render-函数用js的简单实现："><a href="#VUE中h-函数和render-函数用js的简单实现：" class="headerlink" title="VUE中h()函数和render()函数用js的简单实现："></a>VUE中h()函数和render()函数用js的简单实现：</h1><p><code>function vElement(tagName, prop, children){  if(!(this instanceof vElement)){    return new vElement(tagName, prop, children)  }  if(Object.prototype.toString.call(prop) === &quot;[object Array]&quot;) {    children = prop;    prop = {};  }  this.tagName = tagName;  this.prop = prop;  this.children = children;  var count = 0;  this.children.forEach(function(child, index){    if(child instanceof vElement){    count += this.count;    }    count ++;  })  this.count = count;}</code></p><p><code>vElement.prototype.render = function(){  var el = document.createElement(this.tagName);  var children = this.children;  var prop = this.prop;  for(var item in prop){    var curProp = prop[item];    el.setAttribute(item, curProp);  }  children.forEach(function(child, index){    if(child instanceof vElement){    var childDom = child.render();    }else{    var childDom = document.createTextNode(child)    }    el.appendChild(childDom)  })  return el;}</code></p><h1 id="Vue的三种模板："><a href="#Vue的三种模板：" class="headerlink" title="Vue的三种模板："></a>Vue的三种模板：</h1><p>1、html模板；–&gt;  v-html  仅仅解析html样式；但是解析不出来绑定的数据。<br>2、字符串模板；–&gt;  template  <code> </code>  可以解析出绑定的数据。可以用script标签，类型改为：x/template 加上属性名就可以用属性名来调用了。<br>3、render()函数；–&gt;  render(creatElement){var dom = creatElement(‘div’,[‘hello’,creatElemnt(‘p’,[‘world’])])};<br>创建出来之后直接return创建的对象就行了！前两个本质上都是调用render函数来创建的。但是这样创建就不能插入vue的一些指令了。</p><h1 id="vue中父子组件之间的交互："><a href="#vue中父子组件之间的交互：" class="headerlink" title="vue中父子组件之间的交互："></a>vue中父子组件之间的交互：</h1><p>父组件通过props的这个接口与子组件实现交互功能，具体做法是在子组件中定义一个props属性传递数据到父组件中去；子组件通过自定义事件来与父组件进行交互，通过在父组件中调用子组件中的自定义时间来完成；但是要是嵌套的层次太深，也就是父组件中有很多层的子组件，那么他们之间的交互效率就非常的慢了，为了解决这个问题我们可以用vue官方给我们的一个库来管理这些需要交互的数据—即vuex，专为vue.js应用程序开发的状态管理模式；他采用集中式存储管理应用的所有组件的状态；并以相应的规则保证状态以一种可预测的方式发生变化。</p><h1 id="Vue中一些类似方法比较"><a href="#Vue中一些类似方法比较" class="headerlink" title="Vue中一些类似方法比较"></a>Vue中一些类似方法比较</h1><p>计算属性computed  vs  方法mothods：<br>computed刷新的时候会缓存，更加提高性能。</p><p>v-show  vs  v-if<br>v-show：直接添加一个css属性display：none；要是频繁的使用这个dom节点的话，应该使用v-show，提高性能。<br>v-if： 直接删除一个dom节点</p><p>脚手架vue-cli，顾名思义就是一般我们自己做项目要配置的一些东西。但是脚手架会帮我们配置好一套东西。非常方便有木有~工程师就是能让电脑帮我们做的就不要自己动手做了嘛~~嘿嘿嘿。懒人秘籍-必学编程技能哦~</p><p>路由设置里面有一个属性方法是mode：这个属性是加载url的方式是用history还是用hash模式，history模式需要我们跟后端去配合，因为会想后端去请求一个新页面替换掉我们现在的页面，hash模式就不用跟后端去配合，是我们想要的单页面应用，当然了，这个是我们没有用router-link这个标签时的情况。用来router-link标签后不管是哪种模式都不会像后台去请求数据了。history模式是直接在当前的url下加上/的，而hash模式是先加上#再加上/的。注意两者的区别</p><p>node 中的path路径：<br><strong>__dirname</strong>就是文件所处的当前文件夹；</p><p>created函数:在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Vue&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;总结一下使用vue的一些方法吧~&lt;br&gt;用vue-cli来创建一个vue项目的过程：&lt;br&gt;首先在命令行工具页面输入：vue init &lt;code&gt;&amp;lt;template-
      
    
    </summary>
    
      <category term="前端框架" scheme="http://indexcode.cn/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="学习笔记" scheme="http://indexcode.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="http://indexcode.cn/2017/11/2017.11.16-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://indexcode.cn/2017/11/2017.11.16-学习笔记.html</id>
    <published>2017-11-16T08:25:00.051Z</published>
    <updated>2017-12-20T09:41:15.080Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JavaScript学习笔记</strong> <Excerpt in index | 首页摘要><br>更新一下这几天学习到的新知识咯~</p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>虽然知道JSON的数据格式，但是从来没有系统的整理过。今天就来总结一下它吧~</p><ol><li>基于纯文本，跨平台传递极其简单；</li><li>JavaScript原生支持，后台语言几乎全部支持；</li><li>轻量级数据格式，占用字符数量极少，特别适合互联网传递；</li><li>可读性极强，虽然比不上XML那么一目了然，但是合理的依次缩进之后还是很容易识别的；</li><li>容易编写和解析；<br>JSON格式和规则：<br>JSON能够以非常简单的方式来描述数据结构，XML能做到的它都能做到，而且传递的效率更高。</li><li>JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号：是映射符，英文逗号,是分隔符，英文双引号””是定义符。</li><li>大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。</li><li>上述两种集合中若有多个子项，则通过英文逗号,进行分隔。</li><li>键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号””，以便于不同语言的解析。</li><li>JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。<br><strong>JSON实例：</strong></li></ol><p>`// 描述一个人</p><p>var person = {<br>    “Name”: “Bob”,<br>    “Age”: 32,<br>    “Company”: “IBM”,<br>    “Engineer”: true<br>}</p><p>// 获取这个人的信息</p><p>var personAge = person.Age;</p><p>// 描述几个人</p><p>var members = [<br>    {<br>        “Name”: “Bob”,<br>        “Age”: 32,<br>        “Company”: “IBM”,<br>        “Engineer”: true<br>    },<br>    {<br>        “Name”: “John”,<br>        “Age”: 20,<br>        “Company”: “Oracle”,<br>        “Engineer”: false<br>    },<br>    {<br>        “Name”: “Henry”,<br>        “Age”: 45,<br>        “Company”: “Microsoft”,<br>        “Engineer”: false<br>    }<br>]</p><p>// 读取其中John的公司名称</p><p>var johnsCompany = members[1].Company;</p><p>// 描述一次会议</p><p>var conference = {<br>    “Conference”: “Future Marketing”,<br>    “Date”: “2012-6-1”,<br>    “Address”: “Beijing”,<br>    “Members”:<br>    [<br>        {<br>            “Name”: “Bob”,<br>            “Age”: 32,<br>            “Company”: “IBM”,<br>            “Engineer”: true<br>        },<br>        {<br>            “Name”: “John”,<br>            “Age”: 20,<br>            “Company”: “Oracle”,<br>            “Engineer”: false<br>        },<br>        {<br>            “Name”: “Henry”,<br>            “Age”: 45,<br>            “Company”: “Microsoft”,<br>            “Engineer”: false<br>        }<br>    ]<br>}</p><p>// 读取参会者Henry是否工程师</p><p>var henryIsAnEngineer = conference.Members[2].Engineer;`</p><h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>说到JSONP，那不得不提的就是Ajax了。Ajax的大名早就在程序员的江湖上名声赫赫了，但是Ajax有一个缺点就是不能跨域进行数据的交互，所以为了解决这个遗憾，JSONP闪亮登场了，为什么JSONP可以进行跨域传输数据呢？因为这是“历史遗留”问题了。<br>1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；<br>2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>）；<br>3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；<br>4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；<br>5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。<br>6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。<br>7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。<br>如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JavaScript学习笔记&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;br&gt;更新一下这几天学习到的新知识咯~&lt;/p&gt;
&lt;h1 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://indexcode.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://indexcode.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端开发相关</title>
    <link href="http://indexcode.cn/2017/11/2017.11.12-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3.html"/>
    <id>http://indexcode.cn/2017/11/2017.11.12-前端开发相关.html</id>
    <published>2017-11-12T13:39:44.989Z</published>
    <updated>2017-12-20T09:41:55.054Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前端开发相关</strong> <Excerpt in index | 首页摘要></p><h1 id="js中多维数组转换成一维数组"><a href="#js中多维数组转换成一维数组" class="headerlink" title="js中多维数组转换成一维数组"></a>js中多维数组转换成一维数组</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, [<span class="number">2</span>], [[[<span class="number">3</span>]]], [<span class="number">4</span>, [<span class="number">5</span>] ] ];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unidimensionalArray</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> (arr + <span class="string">''</span>).split(<span class="string">','</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Number</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先转换成字符串，在转换成数字类型的。</span></span><br><span class="line"><span class="built_in">console</span>.log(unidimensionalArray(arr)); <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 以上针对数字数组的， 下面是一个针对多类型的</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> u = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> nan = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'boy'</span>;</span><br><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [bool, [str], [[num]], u, [[[nan, func]]], obj];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> unidimensionalArray = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">p1, p2</span>) =&gt;</span> p1.concat(<span class="built_in">Array</span>.isArray(p2) ? unidimensionalArray(p2) : p2), []);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(unidimensionalArray(arr)); <span class="comment">// [ true, 'boy', 1, undefined, NaN, [Function: func], &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><h1 id="求数组中的最大值"><a href="#求数组中的最大值" class="headerlink" title="求数组中的最大值"></a>求数组中的最大值</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">~<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="number">4</span>, <span class="number">-1</span>, [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">45</span>, [<span class="number">7</span>, <span class="number">123</span>, <span class="number">1</span>]],<span class="number">98</span>, [[<span class="number">123</span>]]];  </span><br><span class="line">            </span><br><span class="line">        <span class="comment">//=================================  </span></span><br><span class="line">        <span class="comment">//目标数组, 一维数组</span></span><br><span class="line">        <span class="keyword">var</span> targetArr = [];  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//=================================  </span></span><br><span class="line">        <span class="comment">//展开多维数组为一维数组的函数,递归调用  </span></span><br><span class="line">        <span class="comment">//forEach 为 ES5的数组迭代方法  </span></span><br><span class="line">        <span class="keyword">var</span> fnExpandArray = <span class="function"><span class="keyword">function</span> <span class="params">(arr)</span> </span>&#123;  </span><br><span class="line">            arr.<span class="keyword">forEach</span>( <span class="function"><span class="keyword">function</span> <span class="params">(item)</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">if</span> ( <span class="keyword">Array</span>.isArray(item) ) &#123;  </span><br><span class="line">                fnExpandArray(item);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                targetArr.push(item);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//=================================  </span></span><br><span class="line">        <span class="comment">//展开数组到 targetArr中  </span></span><br><span class="line">        fnExpandArray(arr);  </span><br><span class="line">        console.log(targetArr);  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//=================================  </span></span><br><span class="line">        <span class="comment">//求出最大值的函数,假设第一个值为最大值, 并且与后面的值进行比较  </span></span><br><span class="line">        <span class="keyword">var</span> fnMax = <span class="function"><span class="keyword">function</span> <span class="params">(arr)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">var</span> max = arr[<span class="number">0</span>];  </span><br><span class="line">            arr.<span class="keyword">forEach</span>( <span class="function"><span class="keyword">function</span> <span class="params">(item)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">if</span> (item &gt; max) &#123;  </span><br><span class="line">                max = item;  </span><br><span class="line">            &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            <span class="keyword">return</span> max;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//=================================  </span></span><br><span class="line">        <span class="comment">//最终答案  </span></span><br><span class="line">        alert(<span class="string">'最大值是:'</span> + fnMax(targetArr));  </span><br><span class="line">        </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前端开发相关&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;h1 id=&quot;js中多维数组转换成一维数组&quot;&gt;&lt;a href=&quot;#js中多维数组转换成一维数组&quot; class=&quot;headerlink&quot; title=&quot;js中多维数组
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://indexcode.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://indexcode.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>智力题总结</title>
    <link href="http://indexcode.cn/2017/11/2017.11.10-%E6%99%BA%E5%8A%9B%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>http://indexcode.cn/2017/11/2017.11.10-智力题总结.html</id>
    <published>2017-11-10T05:58:00.062Z</published>
    <updated>2017-11-28T07:16:14.905Z</updated>
    
    <content type="html"><![CDATA[<p><strong>智力题总结</strong> <Excerpt in index | 首页摘要></p><p>最近在找工作，做了一些笔试题和参加了几个面试，面试中被问到有关智力型的问题，要是你看过一些算法类型的书的话，你就会发现这些问题大同小异的都会用到算法中的一些经典的思想。其中有经典的分治法的思想等等，有些智力题真的是非常的耐人寻味。<br>今天就给大家总结一些面试中被问到的智力型问题吧~</p><h1 id="1-有1000瓶啤酒，其中有一瓶有毒，有小白鼠10只，毒药5天发作，如何在5天时间内找出那瓶毒酒。"><a href="#1-有1000瓶啤酒，其中有一瓶有毒，有小白鼠10只，毒药5天发作，如何在5天时间内找出那瓶毒酒。" class="headerlink" title="1. 有1000瓶啤酒，其中有一瓶有毒，有小白鼠10只，毒药5天发作，如何在5天时间内找出那瓶毒酒。"></a>1. 有1000瓶啤酒，其中有一瓶有毒，有小白鼠10只，毒药5天发作，如何在5天时间内找出那瓶毒酒。</h1><p>这个题是考察你对二进制的理解。<br>可以把1000瓶啤酒用二进制编号，那么最多需要10位二进制数。可以用每只小鼠验证每一位二进制数中的一位。例如：可以用第一只小鼠验证第一位数中的1，第二只小鼠验证第二位数中的1，以此类推。那么根据最后小鼠的死亡数来判断具体第几瓶酒有有毒了。</p><p>这个问题也可以有很多变种题。例如：可以测两轮，那么可以测多少瓶酒中的一瓶毒药。对于能replace的情况：2^10*2^10。对于不能replace的情况：3^10。</p><h1 id="2-有一座桥，桥长80米，你有一个背包，背包可以背60个豆子，你要从桥这边到桥那边去，但是有一个规则，你每走一步必须吃一个豆子，只能背一个背包。求最少需要多少豆子才能过桥。"><a href="#2-有一座桥，桥长80米，你有一个背包，背包可以背60个豆子，你要从桥这边到桥那边去，但是有一个规则，你每走一步必须吃一个豆子，只能背一个背包。求最少需要多少豆子才能过桥。" class="headerlink" title="2. 有一座桥，桥长80米，你有一个背包，背包可以背60个豆子，你要从桥这边到桥那边去，但是有一个规则，你每走一步必须吃一个豆子，只能背一个背包。求最少需要多少豆子才能过桥。"></a>2. 有一座桥，桥长80米，你有一个背包，背包可以背60个豆子，你要从桥这边到桥那边去，但是有一个规则，你每走一步必须吃一个豆子，只能背一个背包。求最少需要多少豆子才能过桥。</h1><p><strong>答案：160豆子</strong><br>解析：你可以先背60个豆子走到20米处，放下20个豆子放回，然后再背满豆子出发，就能走过去了。总共需要160个豆子。</p><h1 id="3-N的阶乘后面有多少个零。"><a href="#3-N的阶乘后面有多少个零。" class="headerlink" title="3. N的阶乘后面有多少个零。"></a>3. N的阶乘后面有多少个零。</h1><p>首先，我们先来看一下，结尾是0的数是由谁生成的？<br>出现0的情况就是5的倍数乘以2的倍数。但是出现0的个数是不一定的，2*5=10结果出现一个0，4*25=100结尾出现2个0，8*125=1000结尾出现3个0。以此类推，大家不难发现规律所在，4*25可以分解成2*5*2*5,8*125可以分解成2*5*2*5*2*5…<br>至于10，15，20…这些数，分解开，也只会出现1个5，也就只会出现1个0；<br>至于50，75…这些25的倍数，分解开，也只会出现2个5，与偶数相乘也只会出现2个0。<br>下面就是计算0个数了。</p><p>例如：100！<br>由上面的推理过程就能得到：<br>100/5 + 100/25 = 24<br>即：100的阶乘后面有24个0；</p><h1 id="4-扑克牌问题"><a href="#4-扑克牌问题" class="headerlink" title="4. 扑克牌问题"></a>4. 扑克牌问题</h1><p>问题：一付54张扑克牌，其中有十张是翻过来的。现在把你的眼睛蒙上（绝对没有偷看的可能），让你把扑克牌分成两叠（两叠的多少可以不一样）。要求在两叠中翻过来的扑克牌是相等的。请问该怎么做？除了扑克牌的数目，其它因数（扑克牌大小，重量，颜色，表面触摸的感觉，等等）不参与题目之中。扑克牌可以任意次重新排序、翻转。10张翻过来的扑克牌是随机分布在扑克牌中。</p><p><strong>答案：第一步，你在这54张牌中任意取出10张，现在，扑克牌分成了两叠。44张和10张；第二步，44张那叠不动，将10张这叠每张都翻过来，便得到了符合条件的两叠牌。</strong></p><p>解释：第一步之后，设44张那叠中正面牌x张，10张那叠中正面牌则为10-x张。第二步之后，44张那叠中正面牌保持x张，10张那叠反过来了：反面牌为10-x张，正面牌x张。</p><h1 id="5-分金条问题"><a href="#5-分金条问题" class="headerlink" title="5. 分金条问题"></a>5. 分金条问题</h1><p>问题：有个商人雇用了一位手艺高超的工匠了为他做一个精致产品，工作一星期七天的代价是一条金条。商人手头上有一条金条，刚好有可以付工匠一星期的工钱。但工匠要求工钱要按每天来付。虽然他并不急着用钱，每天有钱进账，老人心里总是踏实一些。但商人家中有个规矩，金条每星期只能切二刀。后来商人想出以了个切割金条的办法，满足了工匠的要求。你知道商人是怎么切割金条才能满足工匠的吗？</p><p><strong>答案：切成1、2、4。</strong></p><p>解释：这三个二进制数的组合能表示0-7中的任何一个。</p><h1 id="6-送花瓶"><a href="#6-送花瓶" class="headerlink" title="6. 送花瓶"></a>6. 送花瓶</h1><p>问题：古时候有一位商人要让伙计将一个精致的花瓶送到买主的手里。买主住在很远的地方，路途中间要经过土匪出没的地方。土匪要是见到花瓶就会抢走。但土匪不会打开锁着的东西，只要把花瓶锁在箱子里就可以安全地送到目的地（这土匪看起来还很文明）。所以商人准备了一个大箱子，在箱子上装了个很大很结实的的锁扣，足以挂几把锁。商人还准备了一把精致的铁锁将花瓶锁在箱子里。这把铁锁的钥匙是独一无二的，没有这把钥匙，按照当时的技术箱子是绝对打不开的。但问题来了，土匪只要见到钥匙就会没收。钥匙都是没法安全地送到买主的手里的。买主也不能把自己的锁送给卖主用。在几经周折后，买主终于得到了他心爱的花瓶。请问这花瓶是如何送到买主的手里的？<br>这是一个故事，但故事里的技术是实在的，也确实运用到了如今的高科技中。在互联网中怎样将信息安全地送到目的地而不被黑客在中途截获，也是成功地运用了类似的方法。你知道故事的答案吗？</p><p><strong>答案：1)、把花瓶锁在箱子里（这把锁只有商人能开，称为“锁1“)，然后运到买主手里。2)、买主收到箱子后，在箱子上再加上自己的锁（这把锁只有买主能开，称为“锁2“),然后把箱子运回给商人。3)、商人收到箱子后，把锁1找开拿走，这时候箱子上只剩下锁2，然后把箱子运给买言。4)、买主收到箱子后， 打开锁2，就成功拿到花瓶。</strong></p><h1 id="7-切蛋糕"><a href="#7-切蛋糕" class="headerlink" title="7. 切蛋糕"></a>7. 切蛋糕</h1><p>问题描述：有一个长方形的蛋糕，中间已被挖去了一个长方形的坑。这长方形的坑不在蛋糕的中央，也不与蛋糕的周边平行。两位小朋友想平分这个蛋糕，请问如何一刀将但蛋糕分成两个体积相等的部分？条件：只能切直的一刀，而且不能拦腰将蛋糕分成上下两个部分（因为蛋糕上面有好吃的糖果。</p><p><strong>答案：沿着两个矩形的中心连线切下去即可。</strong></p><p>解释：两份蛋糕图形的面积相等，都等于大矩形面积的一半减去小矩形面积的一半。</p><h1 id="8-iPhone-四位数密码"><a href="#8-iPhone-四位数密码" class="headerlink" title="8. iPhone 四位数密码"></a>8. iPhone 四位数密码</h1><p>问题描述：一个朋友打开了他的iPhone，我一把把它抓过来说：‘嗯，9、6、0，和1，对吧？’。因为有浓重的手指印在这四个数字上面，我正确地推定这与他的密码相关。他吓了一跳，因为如果我是一个贼，我可以很容易解开他的电话。因为所有的四个数字在四位数字代码中只有一次出现（据我所知，这只有4 x 3 x 2 x 1 = 24种可能）。因而，取四个不同数字作代码不是非常安全的。所以，当我设定密码时，我选择了重复的数字（如1-2-3-1）。这样一来，如果有人会看我的手机，即使他们能够探测到我的手指印，他们要么在猜想第四个数字（不存在），或者，他们如果弄清楚我只用三个独立数字，他们将不得不尝试在一个四位数代码中，列出这三个不同数字所有可能的排列。问题是：1．在一个四位数的代码中，只使用三个数字对安全是否确实有帮助？2．如果只重复使用两个独立的数字会不会更好呢？</p><p><strong>答案：用三个数字最安全，两个数字最不安全，四个数字居中。</strong></p><p>解释：1)、4个位置不同时,排列数=4<em>3</em>2<em>1=24；2)、3个位置不同时,排列数=C(4,2)</em>2*3=36；3)、2个位置不同时,排列数=3个重复情况（4+4）+两两重复情况（6）=14。</p><h1 id="9-书有多少页"><a href="#9-书有多少页" class="headerlink" title="9. 书有多少页"></a>9. 书有多少页</h1><p>问题描述：一本书有N页厚。书的页数是从1 到N。所知道的是，所有的页数总共用了1095个数码字。请问这本书有多少页？</p><p><strong>答案：401页</strong></p><p>解释：有9页个位数的书页，每页用一个数码字。90页两位数的书页，每页用2个数码字。首先假设没有四位数的书页，而三位数书页的数目为x。因为总共用了1095个数字，所以列出x的方程：9+2<em>90+3</em>x=1095。解出x=302，总的书页数=302+9+90=401。</p><h1 id="10-左轮枪"><a href="#10-左轮枪" class="headerlink" title="10. 左轮枪"></a>10. 左轮枪</h1><p>问题描述：某公司招聘员工面试时提的问题：“让我们来玩个游戏”，招聘人开始了。“你现在被牢牢地绑在椅子上不能动。这是一把枪，一把六星左轮抢，六个弹槽都空着。现在，我把两颗子弹装入弹槽。看到我把子弹装入两个相邻的弹槽了吗？我把轮子合上，然后用手拨动让轮子转动几圈。我把枪对着你的头，扣动了扳机，…，叭。你真幸运！第一枪撞针没打中子弹。然后，我要再扣一次扳机。”招聘人接着说：“我可以直接扣动扳机，或旋转轮子一下再扣扳机，你可以选择其中一种，请问，你选哪一种方法呢？”庆幸的是这只是一把想象中的枪。招聘人只是用手势做出旋转轮子和扣动扳机的样子。但不幸的是你的前程却掌握在挥舞着‘手枪’的家伙的手里。 当然，这两种方法都不是你要的，但其中一种方法的生存的机会会大一些。你到底应该选择哪一种方法呢？<br>解释：题中说：子弹是装入两个相邻的弹槽，左轮枪是一格一格往下转的，如右图所示。1) 第一枪没有打出子弹，因此，第一枪的位置只可能是A、B、C、D。那么，接连第二枪的位置就会是第一枪的下面一个，也就是：B、C、D、E，这4个位置中，只有E有子弹。所以，如果直接扣动扳机，几率=1/4。2) 如果重新把轮子转一下，左轮枪将处于随机的位置，6个格子有2颗子弹，这时挨枪的机率为2/6=1/3。3.)1/4 &lt;1/3，‘不转’死的几率更小。</p><p><strong>答案：选择‘不转’，因为被打死的概率更小。</strong></p><p>这个问题让我想到了经典的羊车门问题。有没有一点相似之处呢？</p><h1 id="11-导火索"><a href="#11-导火索" class="headerlink" title="11. 导火索"></a>11. 导火索</h1><p>问题描述：有两根导火索，它们的长度都是正好1分钟烧完。但是它们燃烧的速度是不均匀的。也就是说，你不能用一小段的长度与总长度的比值来确定燃烧完这一小段的时间。用这两根导火索和一只打火机，没有其它计时器的帮助，请你给我报告两次时间信号：开始的时间t1、结束的时间t2。时间t1和t2准确地相差45秒。</p><p>答案：将其中一根的两头，以及另一根的一头，同时点燃，这个时刻定为t1。当第一根烧完时，立即后点燃第二根的另一端，第二根烧完的时刻便是t2。</p><p>解释:见下图：第一根两头点燃，直到烧完，时间是30秒。这时第二根也烧了30秒，因第二根只点了一端，因而只烧完了一半时间，剩下的部分还能烧30秒，这时马上点燃它的另一端，变成从两头同时烧，因而烧完的时间是15 秒，加上开始的30秒，总共历时45秒。</p><h1 id="12-计时沙漏"><a href="#12-计时沙漏" class="headerlink" title="12. 计时沙漏"></a>12. 计时沙漏</h1><p>问题描述：沙漏（hourglass）是最早使用的计时仪器之一。如下图（a）中所示的沙漏，是上下对称的，可以倒来倒去地计时。比如说，如果有一个2分钟的沙漏，你便可以漏一次得到2分钟，漏完后立即倒过来，再漏完，总共得到4分钟的时间。</p><p>现在，给你一个4分钟的沙漏，和一个7分钟的沙漏，它们都是可以倒来倒去的对称沙漏。如何将它们配合使用，才能得到准确的、从开始到结束总共9分钟的时间？</p><p>用图形，我们可以更方便地说明这个问题。一个沙漏某时刻的状态可以用上下重叠的两个带数字的方格表示，例如，上图（b）所表示的是7分钟沙漏的初始状态和漏了2分钟后的状态。上图中的（c）则是要请你回答的问题。</p><p><strong>解释：设7分钟的沙漏为A，4分钟的为B，A，B同时漏，4分钟后， 状态为 （A ： 3，4）；（ B：0，4）；B倒过来， 3分钟A漏完全后， 状态为（A ： 0，7）； （B：1，3）；A倒过来， 1分钟B漏完全后， 状态为（A ： 1，6）； （B：0，4），A倒过来, 1分钟后，状态为（A ： 0，7）；</strong></p><h1 id="13-测量砖头的对角线"><a href="#13-测量砖头的对角线" class="headerlink" title="13. 测量砖头的对角线"></a>13. 测量砖头的对角线</h1><p>问题描述：单凭三个砖块和一把尺子，不使用任何公式，怎样才能测量一个砖头的立体对角线？就是穿过砖头内部的那条对角线。</p><p><strong>答案：将三块砖头如图迭起来，就可测量。</strong></p><h1 id="14-电路"><a href="#14-电路" class="headerlink" title="14. 电路"></a>14. 电路</h1><p>问题描述：12个电阻连成一个正立方体，正方体的每一条棱上有一个1欧姆的电阻，请你求出A和E之间的等效电阻。<br><strong>答案：5/6。</strong><br>解释：解此题的巧妙之处是在于利用对称性，和电学的一丁点儿基础概念，否则……见下左图，三个红点的电位应该相同，三个绿点的电位也应该相同。电位相同的点等效于连在一起。下图中，左、右的电路是互相等效的，因此：R = 1/3 + 1/6 + 1/3，R = 5/6。</p><h1 id="15-方格子"><a href="#15-方格子" class="headerlink" title="15. 方格子"></a>15. 方格子</h1><p>问题描述：有一张8×8=64个格子的格子纸，右上角和左下角各被剪去一格，如图左所示：女儿有31张长方形的卡片（中图），每张刚好是两个格子。女儿想：剪掉了两个角的格子纸面积和31张卡片总面积一样大，因此，她想用卡片作拼图，把格子纸盖起来，但她拼来拼去都不成功，你能帮帮她吗？或者……<br><strong>答案：不可能覆盖起来。</strong><br>解释：不是面积相等就能覆盖的！女儿难不倒将军。不过，8岁的女儿不懂高深的数学，将军想了一个巧妙的方法解释给她听。他将8×8的格子纸涂成黑白相间的国际象棋棋盘（下左图），又举了2×2方格纸剪去两角为例。看下面右图，剪去的两个小方块都是黑色的，剩下两个白方块处于对角的位置，怎么可能被一个黑白的卡片覆盖呢？图中一目了然，小女儿很快就明白了。</p><h1 id="17-为什么下水道的盖子是圆的？"><a href="#17-为什么下水道的盖子是圆的？" class="headerlink" title="17. 为什么下水道的盖子是圆的？"></a>17. 为什么下水道的盖子是圆的？</h1><p>参考答案:<br>主考官认为的最好回答是：正方形的盖子容易掉到洞里去。想一想，如果盖子真掉进去的话，那么不是发生伤人事故，就是盖子会掉到水里。为什么正方形的盖子容易掉下去呢？这是因为正方形的对角线是其边长的约1.414倍。如果把一个正方形盖子垂直地立起来，稍微一转，它就会很容易掉到下水道里去。与此相反，圆的直径都是等长的，这使它很难掉进去。<br>一种诙谐回答是：下水道的洞口是圆形的，盖子当然也应该是圆的。那么为什么下水道的洞口是圆形的？答案是因为圆形的洞比方形的洞好挖。<br>还有另外一种答案：在进行短距离搬运时，圆形的盖子可以很方便地通过滚动的方法来搬运，而方形的盖子就不容易搬运，你需要借助手推车或者由两个人抬着走。再有一点就是用圆形盖子盖住洞口时，不需要怎么调整就可以与洞口严丝合缝。<br><strong>这个问题恐怕是微软最为有名的面试问题了。由于“曝光率”太高，微软在面试中已经停止使用这个问题了。</strong></p><h1 id="18-美国有多少加油站（汽车）？"><a href="#18-美国有多少加油站（汽车）？" class="headerlink" title="18. 美国有多少加油站（汽车）？"></a>18. 美国有多少加油站（汽车）？</h1><p>参考答案:<br><strong>这个乍看让人有些摸不着头脑的问题时，你可能要从问这个国家有多少小汽车入手。面试者也许会告诉你这个数字，但也有可能说：”我不知道，你来告诉 我。”那么，你对自己说，美国的人口是2.75亿。你可以猜测，如果平均每个家庭 （包括单身）的规模是2.5人，你的计算机会告诉你，共有1.1亿个家庭。你回忆起在什么地方听说过，平均每个家庭拥有1.8辆小汽车，那么美国大约会有1.98亿辆小汽车。接着，只要你算出替1.98亿辆小汽车服务需要多少加油站，你就把问题解决了。重要的不是加油站的数字，而是你得出这个数字的方法。</strong></p><h1 id="19-距离问题"><a href="#19-距离问题" class="headerlink" title="19. 距离问题"></a>19. 距离问题</h1><p>有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞 行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？<br><strong>参考答案:答案很容易计算的： 假设洛杉矶到纽约的距离为s 那小鸟飞行的距离就是(s/(15+20))*30。</strong></p><h1 id="20-概率问题"><a href="#20-概率问题" class="headerlink" title="20. 概率问题"></a>20. 概率问题</h1><p>你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机 选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到 红球的准确几率是多少？<br><strong>参考答案:一个罐子放一个红球,另一个罐子放49个红球和50个蓝球,概率接近75%.这是所能达到的最大概率了。实际上，只要一个罐子放&lt;50个红球，不放篮球，另一个罐子放剩下的球，拿出红球的概率就大于50%。</strong><br>无答案，看你有没有魄力坚持自己的意见。</p><h1 id="21-重量问题"><a href="#21-重量问题" class="headerlink" title="21. 重量问题"></a>21. 重量问题</h1><p>你有四人装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被 污染的重量+1.只称量一次，如何判断哪个罐子的药被污染了？</p><p><strong>参考答案:从第一盒中取出一颗，第二盒中取出2 颗，第三盒中取出三颗。 依次类推，称其总量。再根据总重量增加多少判断污染的药罐。</strong></p><h1 id="22-夸脱的水问题"><a href="#22-夸脱的水问题" class="headerlink" title="22. 夸脱的水问题"></a>22. 夸脱的水问题</h1><p>如果你有无穷多的水，一个3夸脱的和一个5夸脱的提桶，你如何准确称出 4夸脱的水？<br><code>参考答案:先用3 夸脱的桶装满，倒入5 夸脱。以下简称3-&gt;5) 在5 夸脱桶中做好标记b1，简称b1)。 用3 继续装水倒满5 空3 将5 中水倒入3 直到b1 在3 中做标记b2 用5 继续装水倒满3 空5 将3 中水倒入5 直到b2 空3 将5 中水倒入3 标记为b3 装满5 空3 将5 中水倒入3 直到3 中水到b3结束了，现在5 中水为标准的4 夸脱水。</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;智力题总结&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;最近在找工作，做了一些笔试题和参加了几个面试，面试中被问到有关智力型的问题，要是你看过一些算法类型的书的话，你就会发现这些问题大同小异的都会用到算法中的一些经典的
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://indexcode.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="思维能力" scheme="http://indexcode.cn/tags/%E6%80%9D%E7%BB%B4%E8%83%BD%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>前端面试总结</title>
    <link href="http://indexcode.cn/2017/11/2017.11.9-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95.html"/>
    <id>http://indexcode.cn/2017/11/2017.11.9-前端面试.html</id>
    <published>2017-11-09T11:51:31.415Z</published>
    <updated>2017-11-28T07:16:00.862Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前端面试总结</strong>  <Excerpt in index | 首页摘要></p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>之前也看过一些有关tcp/ip协议的书，对HTTP协议也有一些了解，但是真要让我自己说出来的时候才发现对http协议了解的只是脑海中的印象而已，当时看书是理解了，但是回过头来想的时候又变得模糊了，总之，还是自己没有理解透彻的原因吧！<br>今天就再来简单概括一下HTTP协议的主要内容吧~同学们，好好听课，重点来了~（敲黑板~认真脸~）</p><ol><li>支持客户/服务器模式。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ol><h3 id="http请求由三部分组成，分别是：请求行、消息报头、请求正文"><a href="#http请求由三部分组成，分别是：请求行、消息报头、请求正文" class="headerlink" title="http请求由三部分组成，分别是：请求行、消息报头、请求正文"></a>http请求由三部分组成，分别是：请求行、消息报头、请求正文</h3><p>1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF<br>其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p><p>请求方法（所有方法全为大写）有多种，各个方法的解释如下：<br>GET     请求获取Request-URI所标识的资源<br>POST    在Request-URI所标识的资源后附加新的数据<br>HEAD    请求获取由Request-URI所标识的资源的响应消息报头<br>PUT     请求服务器存储一个资源，并用Request-URI作为其标识<br>DELETE  请求服务器删除Request-URI所标识的资源<br>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断<br>CONNECT 保留将来使用<br>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求<br>应用举例：<br>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)</p><p>POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。<br>eg：POST /reg.jsp HTTP/ (CRLF)<br>Accept:image/gif,image/x-xbit,… (CRLF)<br>…<br>HOST:www.guet.edu.cn (CRLF)<br>Content-Length:22 (CRLF)<br>Connection:Keep-Alive (CRLF)<br>Cache-Control:no-cache (CRLF)<br>(CRLF)         //该CRLF表示消息报头已经结束，在此之前为消息报头<br>user=jeffrey&amp;pwd=1234  //此行以下为提交的数据</p><p>HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。<br>2、请求报头后述<br>3、请求正文(略) </p><h3 id="HTTP协议详解之响应篇"><a href="#HTTP协议详解之响应篇" class="headerlink" title="HTTP协议详解之响应篇"></a>HTTP协议详解之响应篇</h3><p>在接收和解释请求消息后，服务器返回一个HTTP响应消息。</p><p>HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文<br>1、状态行格式如下：<br>HTTP-Version Status-Code Reason-Phrase CRLF<br>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。<br>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：<br>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求<br>常见状态代码、状态描述、说明：<br>200 OK      //客户端请求成功<br>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden  //服务器收到请求，但是拒绝提供服务<br>404 Not Found  //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error //服务器发生不可预期的错误<br>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br>eg：HTTP/1.1 200 OK （CRLF）</p><p>2、响应报头后述</p><p>3、响应正文就是服务器返回的资源的内容</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。</p><p><strong>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</strong></p><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p><img src="http://outwcl4zh.bkt.clouddn.com/W3C-Box.jpg" alt="W3C-Box"><br><img src="http://outwcl4zh.bkt.clouddn.com/IE-Box.jpg" alt="IE-Box"></p><h1 id="js中异步加载和同步加载的优缺点"><a href="#js中异步加载和同步加载的优缺点" class="headerlink" title="js中异步加载和同步加载的优缺点"></a>js中异步加载和同步加载的优缺点</h1><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><p>又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。<br> js 之所以要同步执行，是因为 js 中可能有输出 document 内容、修改dom、重定向等行为，所以默认同步执行才是安全的。<br>以前的一般建议是把 <strong><code>&lt;script&gt;</code>放在页面末尾<code>&lt;/body&gt;</code>之前，这样尽可能减少这种阻塞行为，而先让页面展示出来。</strong><br>简单说：同步加载的网络 timeline 是瀑布模型，而异步加载的 timeline 是并发模型。</p><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理。<br>这种方法是在页面中 <strong><code>&lt;script&gt;</code>标签内，用 js 创建一个 script 元素并插入到 document 中。这样就做到了非阻塞的下载 js 代码。</strong><br>async属性是HTML5中新增的异步支持，见后文解释，加上好（不加也不影响）。<br>此方法被称为 Script DOM Element 法，不要求 js 同源。<br>将js代码包裹在匿名函数中并立即执行的方式是为了保护变量名泄露到外部可见，这是很常见的方式，尤其是在 js 库中被普遍使用。<br>代码如下：</p><p><code>(function() {     var s = document.createElement(&#39;script&#39;);     s.type = &#39;text/javascript&#39;;     s.async = true;     s.src = &#39;http://yourdomain.com/script.js&#39;;     var x = document.getElementsByTagName(&#39;script&#39;)[0];     x.parentNode.insertBefore(s, x); })();</code></p><p> <strong>但是，这种加载方式在加载执行完之前会阻止 onload 事件的触发，而现在很多页面的代码都在 onload 时还要执行额外的渲染工作等，所以还是会阻塞部分页面的初始化处理。</strong></p><p><code>(function() {     function async_load(){         var s = document.createElement(&#39;script&#39;);         s.type = &#39;text/javascript&#39;;         s.async = true;         s.src = &#39;http://yourdomain.com/script.js&#39;;         var x = document.getElementsByTagName(&#39;script&#39;)[0];         x.parentNode.insertBefore(s, x);     }     if (window.attachEvent)         window.attachEvent(&#39;onload&#39;, async_load);     else         window.addEventListener(&#39;load&#39;, async_load, false); })();</code></p><p> 这和前面的方式差不多，但关键是它不是立即开始异步加载 js ，而是在 onload 时才开始异步加载。这样就解决了阻塞 onload 事件触发的问题。</p><p>在异步加载的时候，无法使用 document.write 输出文档内容。<br>在同步模式下，document.write 是在当前 script 所在的位置输 出文档的。而在异步模式下，浏览器继续处理后续页面内容，根本无法确定 document.write 应该输出到什么位置，所以异步模式下 document.write 不可行。而到了页面已经 onload 之后，再执行 document.write 将导致当前页面的内容被清空，因为它会自动触发 document.open 方法。<br>实际上document.write的名声并不好，最好少用。<br>替代方法：</p><ol><li>虽然异步加载不能用 document.write，但还是可以onload之后执行操作dom（创建dom或修改dom）的，这样可以实现一些自己的动态输出。比如要在页面异步创建一个浮动元素，这和它在页面中的位置就没关系了，只要创建出该dom元素添加到 document 中即可。</li><li>如果需要在固定位置异步生成元素的内容，那么可以在该固定位置设置一个dom元素作为目标，这样就知道位置了，异步加载之后就可以对这个元素进行修改。</li></ol><h1 id="如何在元素未添加到dom结构时在元素上绑定事件"><a href="#如何在元素未添加到dom结构时在元素上绑定事件" class="headerlink" title="如何在元素未添加到dom结构时在元素上绑定事件"></a>如何在元素未添加到dom结构时在元素上绑定事件</h1><p>可以用事件冒泡的形式进行处理，如下代码：</p><p><code>$(document).on(&#39;click&#39;,&#39;selector&#39;,function(){          ...      });</code></p><p>此时事件冒泡到document对象上，当检测事件的target，如果与传入的选择符（这里是selector）匹配，就触发事件，否则不触发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;前端面试总结&lt;/strong&gt;  &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;h1 id=&quot;HTTP协议&quot;&gt;&lt;a href=&quot;#HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议&quot;&gt;&lt;/a&gt;HTTP协议&lt;/h1
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://indexcode.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机基础" scheme="http://indexcode.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>诗与远方</title>
    <link href="http://indexcode.cn/2017/11/2017.11.09%20%E8%AF%97%E4%B8%8E%E8%BF%9C%E6%96%B9.html"/>
    <id>http://indexcode.cn/2017/11/2017.11.09 诗与远方.html</id>
    <published>2017-11-09T10:31:50.135Z</published>
    <updated>2017-09-24T08:39:09.526Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 诗与远方：</strong> <Excerpt in index | 首页摘要></p><h2 id="个人随笔："><a href="#个人随笔：" class="headerlink" title="个人随笔："></a>个人随笔：</h2><p>总有一代人会实现我们的梦想；<br>100多年前，在梁启超的海船上又曾复活了：“纵有千古，横有八荒，前途似海，来日方长。美哉我少年中国，与天不老！壮哉我中国少年，与国无疆！”</p><p>一个人最重要的不是拥有多少财富，和拥有多大的房子，最重要的是拥有深厚的学识和崇高的思想道德。         -康震点评《陋室铭》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 诗与远方：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;h2 id=&quot;个人随笔：&quot;&gt;&lt;a href=&quot;#个人随笔：&quot; class=&quot;headerlink&quot; title=&quot;个人随笔：&quot;&gt;&lt;/a&gt;个人随笔：&lt;/h2&gt;&lt;p&gt;总
      
    
    </summary>
    
      <category term="个人随笔" scheme="http://indexcode.cn/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="诗与远方" scheme="http://indexcode.cn/tags/%E8%AF%97%E4%B8%8E%E8%BF%9C%E6%96%B9/"/>
    
  </entry>
  
  <entry>
    <title>前端练习题</title>
    <link href="http://indexcode.cn/2017/11/%E7%BB%83%E4%B9%A0%E9%A2%98.html"/>
    <id>http://indexcode.cn/2017/11/练习题.html</id>
    <published>2017-11-09T10:31:50.124Z</published>
    <updated>2017-09-24T08:37:52.293Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 前端练习题：</strong> <Excerpt in index | 首页摘要></p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><ol><li><p>var str = false + 1;<br>document.write(str);<br>结果为：1        （false会发生隐式类型转换成数值类型的0）</p></li><li><p>var demo = false == 1;<br>document.write(demo);<br>结果为：false  （同第一题）</p></li><li><p>if(typeof(a) &amp;&amp; - true + (+ undefined) + “”) {<br>   document.write(‘基础扎实’);<br>}<br>结果为：基础扎实   （typeof()是唯一一个使用未经声明的变量，不报错的方法，并且它的六个返回结果都是字符串类型的；””空字符串起连接作用）</p></li><li><p>if(11 + “11” * 2 == 33) {<br> document.write(‘基础扎实’);<br>}<br>结果为：基础扎实     （运算符的优先级比较，先算乘除再算加减。等号优先级最低。牢记字符串的连接作用。）</p></li><li><p>!!” “ + !!”” - !!false || document.write(‘你觉得能打印，你就是猪’);<br>结果为：1</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2></li><li><p>function bar() {<br> return foo;<br> foo = 10;<br> function foo() {</p><p> }<br> var foo = 11;<br>}<br>document.write(bar());<br>结果为：function foo() {};     （牢记函数预编译的四部）</p></li><li><p>function bar() {<br> foo = 10;<br> function foo() {};<br> var foo = 11;<br> return foo;<br>}<br>console.log(bar());<br>结果为：11                     （牢记函数预编译的四部）</p></li><li><p>a = 100;<br> function demo(e) {<br> function e() {}<br> arguments[0] = 2;<br> document.write(e);<br> if(a) {</p><pre><code>var b = 123;function c() { }    </code></pre><p> }<br> var c;<br> a = 10;<br> var a;<br> document.write(b);<br> f = 123;<br> document.write(c);<br> document.write(a);<br> }<br> var a;<br> demo(1);<br> document.write(a);<br> document.write(f);<br>结果为：2 undefined undefined 10 100 123     （全局变量有两种，第一种就是直接定义在全局中的变量，第二种就是没用var直接定义出来的变量。if里面不能定义函数，以前可以，现在不合法，但是也不会报错）</p></li></ol><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><ol><li>function test(a, b) {<br> console.log(a, b);<br>}(1, 2);<br>结果：不报错，返回结果为：2。        （因为会把最后小括号当成随意写在文本中的，另外会返回括号里面最后的数）</li></ol><h2 id="new问题"><a href="#new问题" class="headerlink" title="new问题"></a>new问题</h2><ol><li>运行test()和new test()的结果分别是什么？<br>var a = 5;<br>function test() {<br> a = 0;<br> alert(a);<br> alert(this.a);<br> var a;<br> alert(a);<br>}<br>结果为：test执行结果为0、5、0   new test结果为0、undefined、0</li></ol><ol><li><p>分析下面的JavaScript代码段：<br> function employee(name, code) {</p><pre><code>this.name = &quot;wangli&quot;;this.code = &quot;A001&quot;;</code></pre><p> }<br> newemp = new employee(“zhangming”,’A002’);<br> document.write(“雇员姓名:” + newemp.name + “<br>“);<br> document.write(“雇员代号:” + newemp.code + “<br>“);<br>输出的结果是(  ).(选择一项)<br>A. 雇员姓名:wangli  雇员代码:A001<br>B. 雇员姓名:zhangming  雇员代码:A002<br>C. 雇员姓名:null, 雇员代码:null<br>D. 代码有错误，无输出结果<br>答案是：A     （因为根本就没有进行赋值、没用到传进去的参数、写死了，定式的，生成多少个都是这样的。如果想进行赋值的话应该写成  this.name = name,this.code = code）</p></li><li><p>var str = “abc”;<br>str += 1;<br>var test = typeof(str);<br>if(test.length == 6) {<br> test.sign = “typeof的返回值可能为String”;<br>}<br>document.write(test.sign);<br>结果为：undefined  (str先+=1得字符串形式的abc1.然后typeof(str)返回值是字符串形式的string，test是原始值，所以访问他的.length会形成包装类，test的长度确实是6，所以能走进if循环里。包装类保存不出来。)</p></li></ol><ol><li>function Person(name, age, sex) {<br> var a = 0;<br> this.name = name;<br> this.age = age;<br> this.sex = sex;<br> function sss() {<pre><code>a++;document.write(a);</code></pre> }<br> this.say = sss;<br>}<br>var oPerson = new Person();<br>oPerson.say();<br>oPerson.say();<br>var oPerson1 = new Person();<br>oPerson1.say();<br>结果为：1、2、1      (注意：题中的this.say = sss把sss保存出来了，与Person形成闭包 )    </li></ol><ol><li><p>var x = 1;<br>if(function f() {}) {<br> x += typeof f;<br>}<br>console.log(x);<br>结果为：1undefined    （boolean值为false的只有6个，上题中的不属于那六个，所以肯定能走进if语句中。typeof是唯一一个使用未经声明的变量不报错的方法）</p></li><li><p>(function(x) {<br> delete x;<br> return;<br>})(1);</p></li></ol><p>结果为：undefined     （可配置性。delete只能删除对象上的属性，比如在全局上定义一个 var a = 123；虽然a就相当于是window上的一个属性，但是delete window.a是删不了的。但是你要是在全局上就定义window.a = 123;或者 a = 123； delete a;结果就为真，可以删除的。这也就是可配置性一说！）</p><ol><li>var h = function a() {<br> return 23;<br>}<br>typeof a();<br>结果为：报错a is not defined</li></ol><p>重点中的重点！<br>  typeof (new Array).<strong>proto</strong>.constructor()<br>结果为：”object”     解析：先算括号里面的，再算点。优先级顺序。形式上又有typeof的两种形式的用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 前端练习题：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;h2 id=&quot;隐式类型转换&quot;&gt;&lt;a href=&quot;#隐式类型转换&quot; class=&quot;headerlink&quot; title=&quot;隐式类型转换&quot;&gt;&lt;/a&gt;隐式类型转换&lt;/h2
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://indexcode.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://indexcode.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>说说滕王阁的修建者——“混蛋王爷”李元婴</title>
    <link href="http://indexcode.cn/2017/11/%E6%BB%95%E7%8E%8B%E9%98%81%E7%9A%84%E4%BF%AE%E5%BB%BA%E8%80%85--%E6%BB%95%E7%8E%8B%E6%9D%8E%E5%85%83%E5%A9%B4.html"/>
    <id>http://indexcode.cn/2017/11/滕王阁的修建者--滕王李元婴.html</id>
    <published>2017-11-09T10:31:50.113Z</published>
    <updated>2017-11-28T07:19:14.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说说滕王阁的修建者——“混蛋王爷”李元婴"><a href="#说说滕王阁的修建者——“混蛋王爷”李元婴" class="headerlink" title="说说滕王阁的修建者——“混蛋王爷”李元婴"></a>说说滕王阁的修建者——“混蛋王爷”李元婴</h1><p>说到江西南昌的滕王阁，即使没去过的人，也一定听过它的大名，号称江南三大名楼之首，尤其是唐初诗人王勃的《滕王阁赋》，更让它名扬天下，其中的诗句“落霞与孤鹜齐飞，秋水共长天一色”流传至今。但历史上的滕王阁其实有三处，最早修建是山东滕州的滕王阁（已被毁，待复建），其次是江西南昌的滕王阁（知名度最高），最后修建是四川阆中的滕王阁。这三处滕王阁的修建者都是同一个人——即唐初的滕王李元婴。</p><p><img src="http://outwcl4zh.bkt.clouddn.com/%E6%BB%95%E7%8E%8B%E9%98%81" alt="滕王阁"><br>现在位于江西南昌的滕王阁</p><p>李元婴在历史上的知名度并不高，但要是说到他的父亲唐高祖李渊和他的哥哥唐太宗李世民，却是大家非常熟悉的历史人物。李渊共有二十二个儿子，除了隐太子李建成、唐太宗李世民等，还有这个最小的儿子李元婴。李元婴出生于公元630年，也就是贞观三年，这个时候的李渊早已禅让退位，年纪也64岁了，却也不耽误生孩子。贞观十三年，才十岁的李元婴被哥哥唐太宗封为滕王，封地在今天的山东滕州。<br>成年后，李元婴按照唐朝的制度，前往封地就蕃。只是这位王爷没有造福地方，相反却是骄奢淫逸、横征暴敛、大兴土木，引起了当地极大的民愤。根据相关的史书记载，李元婴在地方并无政绩可言，而是终日飞鹰走狗、声色犬马。据说他经常带着大队的人马在自己的领地内骑马打猎，甚至把忙于劳作的农民当靶子，玩弹弓射击，以此取乐，唐高宗李治为此还专门写信劝诫这位比自己小很多的皇叔不要用弹弓射人。<br>在生活作风方面，李元婴也是个十足的混蛋。他的王府里面不仅妻妾众多，而且特别青睐下属们的漂亮妻子。据说，在滕王李元婴待过的地方，下属官员们都明白这个“潜规则”，会自觉把自己的妻子送到王府，供这位王爷玩乐，若是不送的，则免不了被李元婴无故刁难和诬陷。<br>这位弄得“民怨沸腾”又“官怨沸腾”的贪败王爷，自然是皇帝最头疼的对象。唐太宗在位时期，对这位幺弟的各种混蛋行为往往是睁一只眼闭一只眼。唐高宗即位后，对这位小皇叔，或是当面警告，或是写信劝诫，实在没办法了，就一贬再贬，进行惩罚。先是贬到苏州，再到洪州（今江西南昌），后来又到隆州（今四川阆中），只是李元婴恶习不改，依旧我行我素，无法无天。<br>虽然品行恶劣，但李元婴却有很高的艺术造诣，这自然与他从小的宫廷艺术熏陶有关。据说他“善画”，而且“工于蛱蝶”，由此留下了著名的“滕派蝶画”。除此之外，他还非常钟情于建筑艺术，每到一处就广邀天下的能工巧匠，大肆修建行宫、楼阁。永徽四年（653年），他选址赣江之滨，修起了一座高插云天的楼阁，这就是王勃笔下的滕王阁了，为后人的宝贵的历史文化遗产。转载自 百家好 –我爱读历史</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;说说滕王阁的修建者——“混蛋王爷”李元婴&quot;&gt;&lt;a href=&quot;#说说滕王阁的修建者——“混蛋王爷”李元婴&quot; class=&quot;headerlink&quot; title=&quot;说说滕王阁的修建者——“混蛋王爷”李元婴&quot;&gt;&lt;/a&gt;说说滕王阁的修建者——“混蛋王爷”李元婴&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="历史故事" scheme="http://indexcode.cn/categories/%E5%8E%86%E5%8F%B2%E6%95%85%E4%BA%8B/"/>
    
    
      <category term="历史故事" scheme="http://indexcode.cn/tags/%E5%8E%86%E5%8F%B2%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://indexcode.cn/2017/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <id>http://indexcode.cn/2017/11/正则表达式.html</id>
    <published>2017-11-09T10:31:50.102Z</published>
    <updated>2017-11-28T07:07:16.184Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 正则表达式：</strong> <Excerpt in index | 首页摘要></p><h1 id="正则表达式-就是个规则-是个对象"><a href="#正则表达式-就是个规则-是个对象" class="headerlink" title="正则表达式   就是个规则  是个对象"></a>正则表达式   就是个规则  是个对象</h1><p><strong>RegExp正则表达式的作用：匹配特殊字符或有特殊搭配原则的字符的最佳选择。</strong></p><p>两种创建方法：直接量<code>var reg = /pattern/;</code>或者<code>var reg = new RegExp(&#39;pattern&#39;);</code>但是也可以不加new，但是这就相当于直接把RegExp(‘pattern’)拷贝过来了。而且也可以在()里面添加一个已经设置好的正则规则。如：<code>reg = /abc/;  var reg1 = new RegExp(reg);</code>这个reg1就跟reg一样了。 <strong>推荐用直接量。</strong></p><p><strong>\n换行</strong><br><strong>\r行节束缚</strong>    windows系统上是他们两个的一起作用的,一个回车就相当于\r\n  lunix上只有一个换行符,也就是只有\n<br>\t一个制表符，一个缩进，可以设置一个缩进等于几个空格</p><p><strong>\</strong> 转义字符的作用还有，如果你想打印或者使用特殊字符的话就在前面加上转义字符，让特殊符号回归成本来的意义。</p><p>如果想写特殊的格式，多行字符串，就在字符串每一行的结尾加上转义的字符就行了。可如果是字符串的话在每一行的结尾加上+号也是可以的。比如：</p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">div</span> = document.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">div</span>.innerHTML = <span class="string">"\</span></span><br><span class="line"><span class="string">&lt;div&gt;\</span></span><br><span class="line"><span class="string">&lt;span&gt;邓宝宝很萌&lt;/span&gt;\</span></span><br><span class="line"><span class="string">&lt;/div&gt;\</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure><p>另一种：</p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">div</span> = document.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">div</span>.innerHTML = <span class="string">"&lt;div&gt;"</span> +</span><br><span class="line">   <span class="string">"&lt;span&gt;邓宝宝很萌&lt;/span&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;/div&gt;"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = /abcde/;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"123abcdeabcdeabcde"</span>;</span><br></pre></td></tr></table></figure><p>reg.test(str);判断str里面是否有abcde的字符串；返回值为true<br>str.match(reg);跟上面的方法正好相反。这是字符串上的方法，找字符串上符合正则表达式reg的方法。</p><h1 id="在后面加上i-g-m"><a href="#在后面加上i-g-m" class="headerlink" title="在后面加上i g m"></a><strong>在后面加上i g m</strong></h1><p>i  表示忽略大小写ignoreCase;<br>g  表示全局找符合条件的，但是不会识别特殊符的Globle,不加g的话匹配一个就停了。全局匹配。<br>m  表示可识别多行匹配了,match;<br>例如：多行匹配<br>  <code>var reg = /^a/g  var str = &quot;abc\nabc&quot;;  str.match(reg);</code><br>结果为一个a；但是第二个a也是符合条件的，想要第二个也匹配出来就要在后面添加一个m就能多行匹配了。查找开头为a 的话识别不了两个a，但是加上m就能识别了。</p><p><code>reg = /^a/</code> 就相当于一个开头是a的字符串规则。</p><h1 id=""><a href="#" class="headerlink" title="[]"></a>[]</h1><p><code>var reg = /[abcd][bcde]/</code>  第一个里面就是查找符合第一位的条件的，[a-z]代表从a到z的字母。[^a-z]代表查找任何不在条件的字符。还可以[a-z0-9]里面写好几个条件的。[]是第一位满足什么条件，ASCII码  A 65； a 97；因为中间有26个字母之外还有一些特殊符号呢。eg：<br> <code>var reg = /[^a-g][1-9]/g; var str = &quot;ah2dfsa&quot;; str.match(reg);</code><br>结果为：h2；<br>在[]里的^号是非的意思，就是取反的意思。</p><h1 id="-1"><a href="#-1" class="headerlink" title="()"></a>()</h1><p>()在正则表达式中的意义：reg = /(abc|bcd)d/g;|代表或者的意思；()代表连着后面的条件的，可以代表和的意思。必须是abc或者bcd连着之后的d的满足条件的字符。<br>eg：<br><code>reg = /(abc|bcd)d/g;var str = &quot;abcdbcdddsahf&quot;; str.match(reg);</code><br>结果为：”abcd”  “bcdd”;</p><h1 id="元字符：一些表达式的缩写形式；"><a href="#元字符：一些表达式的缩写形式；" class="headerlink" title="元字符：一些表达式的缩写形式；"></a>元字符：一些表达式的缩写形式；</h1><p>.   所有的都包括；[^\r\n];<br>\d  查找数字;就相当于[0-9];<br>\D  查找非数字；就相当于[^0-9];<br>\w  查找单词字符；word；就相当于[A-z0-9_]<br>\W  查找非单词字符；就相当于[^w]<br>\s  查找空白字符；代表一切空白；[\t\n\f\r\v ]<br>\S  查找非空白字符；[^s]<br>\b  匹配单词边界；单词边界的意思；空格之后就是单词边界了；<br>\B  匹配非单词边界；非单词边界；<br>\O  查找NUL字符；<br>\n  查找换行符；<br>\f  查找换页符；<br>\r  查找回车符；<br>\t  查找制表符；<br>\v  查找垂直制表符；<br>\xxx    查找以八进制数xxx规定的字符；<br>\xdd    查找以十六进制dd规定的字符；<br>\uxxxx  查找以十六进制数xxxx规定的Unicode字符；<br>eg：<br><code>var reg = /[\u5000-\u6000]/g;var str = &quot;邓宝宝&quot;；  邓u90df  宝u5d00str.match(reg);</code><br>结果为：”宝”  “宝” ；</p><h1 id="贪心匹配原则：正则表达式能匹配多个就不匹配少个。"><a href="#贪心匹配原则：正则表达式能匹配多个就不匹配少个。" class="headerlink" title="贪心匹配原则：正则表达式能匹配多个就不匹配少个。"></a>贪心匹配原则：正则表达式能匹配多个就不匹配少个。</h1><p><strong>量词：</strong><br>n+    匹配人格包含至少一个n的字符串；<br>n*    匹配任何包含零个或多个n的字符串；<br>n?    匹配任何包含零个或一个n的字符串；<br>n{X}   匹配包含X个n的序列的字符串；<br>n{X,Y}  匹配包含X至Y个n的序列的字符串；<br>n{X,}   匹配包含至少X个b的序列的字符串；<br>n$      匹配任何结尾为n的字符串；<br>^n      匹配任何开头为n的字符串；<br>?=n     匹配任何其后紧接指定字符串n的字符串；<br>?!n     匹配任何其后没有紧接指定字符串n的字符串；</p><p><code>var reg = /^abc$/g;var str = &quot;abcabc&quot;str.match(reg);</code></p><p>返回结果：null;</p><h1 id="写一个正则表达式，检验字符串首尾是否含有数字？"><a href="#写一个正则表达式，检验字符串首尾是否含有数字？" class="headerlink" title="写一个正则表达式，检验字符串首尾是否含有数字？"></a>写一个正则表达式，检验字符串首尾是否含有数字？</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">reg</span> = /(^\<span class="keyword">d</span>)|(\<span class="keyword">d</span>$)/gi;</span><br><span class="line"><span class="keyword">var</span> str = '123abc321';</span><br><span class="line">str.<span class="built_in">match</span>(<span class="keyword">reg</span>);  或  <span class="keyword">reg</span>.<span class="keyword">test</span>(str);</span><br></pre></td></tr></table></figure><p>返回结果为：true；</p><h1 id="写一个正则表达式，检验字符串首和尾是否含有数字？"><a href="#写一个正则表达式，检验字符串首和尾是否含有数字？" class="headerlink" title="写一个正则表达式，检验字符串首和尾是否含有数字？"></a>写一个正则表达式，检验字符串首和尾是否含有数字？</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">reg</span> = /^\<span class="keyword">d</span>[\s\S]*\<span class="keyword">d</span>$/<span class="keyword">g</span>;   表达全集的方法有很多哦~</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"123abc           \n def321"</span>;</span><br><span class="line">str.<span class="built_in">match</span>(<span class="keyword">reg</span>);   或   <span class="keyword">reg</span>.<span class="keyword">test</span>(str);</span><br></pre></td></tr></table></figure><h1 id="RegExp-对象上的一些属性：（reg-属性）"><a href="#RegExp-对象上的一些属性：（reg-属性）" class="headerlink" title="RegExp 对象上的一些属性：（reg.属性）"></a>RegExp 对象上的一些属性：（reg.属性）</h1><p>global：  RegExp对象是否具有标志g。 返回值为：true或者false<br>ignoreCase:  RegExp对象是否具有标志i。<br>lastIndex： 一个整数，标示开始下一次匹配的字符位置。<br>multiline： RegExp对象是否具有标志m。<br>source: 正则表达式的源文本。  能把本源打出来。</p><h1 id="RegExp-对象上的方法：（reg-方法）"><a href="#RegExp-对象上的方法：（reg-方法）" class="headerlink" title="RegExp 对象上的方法：（reg.方法）"></a>RegExp 对象上的方法：（reg.方法）</h1><p>compile: 编译正则表达式。（没用）<br>exec： 检索字符串中指定的值。返回找到的值，并确定其位置。execute执行CEO中的E。和str上的match方法有点儿相似。不加全局匹配g的话就完全一样了。加上g才上这个方法的实际用处。这个方法使用时重复调用一次一次匹配才能体现出来哦~  内部能够识别游标的位置。reg.lastIndex 就是游标的位置，输出结果就是当前游标的位置。这个方法就是给exec这个方法用的。可以手动改游标的位置。必须有全局匹配g。没有g游标不会动的。</p><p><code>var reg = /a/g;var str = &quot;ababab&quot;;console.log(reg.exec(str));</code><br>结果为:[“a”, index: 0, input: “ababab”]<br><code>console.log(reg.lastIndex);</code>输出当前游标位置；<br>结果为：1<br><code>console.log(reg.exec(str));</code><br>结果为:[“a”, index: 2, input: “ababab”]<br>console.log(reg.lastIndex); 输出当前游标位置；<br>结果为：3<br><code>console.log(reg.exec(str));</code><br>结果为:[“a”, index: 4, input: “ababab”]<br><code>console.log(reg.lastIndex);</code>输出当前游标位置；<br>结果为：5</p><p><strong>test：</strong> 检索字符串中指定的值。返回true 或 false。</p><h1 id="支持正则表达式的String对象上的方法：（str-方法）"><a href="#支持正则表达式的String对象上的方法：（str-方法）" class="headerlink" title="支持正则表达式的String对象上的方法：（str.方法）"></a>支持正则表达式的String对象上的方法：（str.方法）</h1><p>search： 检索与正则表达式相匹配的值。查找位置的方法，返回的是调用该方法的位置，没有的话返回-1。<br><code>var reg = /abc/g;var str = &quot;123abcd&quot;;str.search(reg);</code></p><h1 id="—–-gt-子表达式"><a href="#—–-gt-子表达式" class="headerlink" title="()—–&gt;  子表达式"></a>()—–&gt;  子表达式</h1><p><code>var reg = /abc(d)/g;</code>  能把子表达式中记录的内容通过match的方法返回出来；<br><code>var str = &quot;123abcd&quot;;</code><br><code>console.log(str.match(reg))</code>打印出来的结果比在控制台里调试str.match(reg)<br>的结果要多一点儿(多了满足条件是光标的索引，也就是search方法，还有就是str全部的信息)。因为console会返回这个类数组的全部信息。<code>str.match(reg)</code>只是返回这个方法的实际结果。<br>这个返回的结果中就包括有子表达式的内容。<br><strong>match： 找到一个或多个正则表达式的匹配。</strong></p><p><strong>replace： 替换与正则表达式匹配的子串。</strong></p><p><code>var str = &quot;xyyx&quot;;str.replace(&#39;x&#39;, &#39;a&#39;);</code><br>这个是把字符串中的第一个x替换成a；不过改变的不是原来的字符串哦~ 因为原来的字符串是原始值，任何原始值都是不可改变的，这里又用到了包装类的知识点哦~系统内部隐式创建一个字符串但是用完就删除了，没有了，找不到了。这里的话只能通过console.log(str.replace(‘x’, ‘a’))查看这个方法。结果为：ayyx。那这么说的话这个方法还有用处吗？有用啊，可以var一个变量保存啊。匹配的只有一个哦~这里没有全局匹配的功能，没有加g的功能。想要全变了，可以用正则表达式写console.log(str.replace(/x/g, ‘a’));结果为：ayya。</p><h1 id="写一个正则表达式把原来的-xxyy-形式的-对调过来成为-yyxx的形式。"><a href="#写一个正则表达式把原来的-xxyy-形式的-对调过来成为-yyxx的形式。" class="headerlink" title="写一个正则表达式把原来的 xxyy 形式的 对调过来成为 yyxx的形式。"></a>写一个正则表达式把原来的 xxyy 形式的 对调过来成为 yyxx的形式。</h1><p><code>var reg = /(\w)\1(\w)\2/g;</code><br><code>var str = &quot;123aabb321&quot;;</code><br><code>console.log(str.replace(reg, &#39;$2$2$1$1&#39;));</code><br>结果为: “123bbaa321”<br>这里的$1代表的就是第一个子表达式引用到的内容，$2就是第二个子表达式引用到的内容。单独$什么也不是哦~   第二个参数还能填一个函数，例如：<code>console.log(str.replace(reg, function($, $1, $2){}))</code>，系统怕单纯的正则不够你用所以就给你用函数来调用满足一些复杂的要求，所以这个函数最后返回的一定还是一个字符串，系统内部给你写好了传的参数，你直接传进去就行。function中的参数第一个用$代替一下，是正则表达式匹配到的整体内容。第二个参数$1就是第一个子表达式的内容，$2就是第二个子表达式的内容。</p><h1 id="把命名的名称改成小驼峰式写法；"><a href="#把命名的名称改成小驼峰式写法；" class="headerlink" title="把命名的名称改成小驼峰式写法；"></a>把命名的名称改成小驼峰式写法；</h1><p><code>var str = &quot;the-first-name&quot;;var reg = /-(\w)/g;console.log(str.replace(reg, function ($, $1) {  return $1.toUpperCase();}));</code><br>打印结果为：theFirstName;</p><p>写出一个正则表达式满足xxyy形式的方法：这个时候必须用到子表达式了。(\w)\1 这个是第一个位置的子表达式，代表的意义就是对第一个字子表达式的重复引用。(\w)\2 这个是第二个位置的子表达式，代表的意义就是对第二个子表达式的重复引用。所以xxyy形式的正则表达式形式如下：<br><code>var reg = /(\w)\1(\w)\2/g;var str = &quot;aabbccdddddddd&quot;;str.match(reg);</code><br>控制台打印结果：(3)[“aabb”, “ccdd”, “dddd”];从当前光标所在位置继续查找下一位的。</p><p>写出一个正则表达式满足 xyyx 的形式。<br><code>var reg = /(\w)(\w)\2\1/g;var str = &quot;abbabccd&quot;;console.log(str.match(reg));</code><br>控制台打印结果为：(2)[“abba”];  看清楚了小伙子~</p><p><code>var reg = /(\w)(\w)\2\1\2\1/g;var str = &quot;abbabadeeded&quot;;console.log(str.match(reg));</code><br>控制台打印结果为：(2)[“abbaba”, “deeded”];</p><h1 id="一对方法来回转换："><a href="#一对方法来回转换：" class="headerlink" title="一对方法来回转换："></a>一对方法来回转换：</h1><p> 字符串上的方法：<br>split(‘-‘):  把字符串分割为字符串数组。默认是逗号。</p><p> 数组上的方法：<br>join(‘-‘): 把数组中的每一项的值按照所给定的符号分成字符串。默认是逗号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 正则表达式：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;h1 id=&quot;正则表达式-就是个规则-是个对象&quot;&gt;&lt;a href=&quot;#正则表达式-就是个规则-是个对象&quot; class=&quot;headerlink&quot; title=&quot;正则
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://indexcode.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://indexcode.cn/tags/JavaScript/"/>
    
  </entry>
  
</feed>
