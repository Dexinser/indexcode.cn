[{"title":"JavaScript之V8引擎","url":"/2017/11/JavaScript之V8引擎.html","content":"**{{title}}**     <Excerpt in index | 首页摘要>\nV8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用于Google Chrome中。\nV8在执行之前将JavaScript代码编译成机器码让计算机识别执行，而非字节码或者直译它，以此来提升效能，JavaScript程序与V8引擎的速度可以媲美二进制编译。在高性能JavaScript一书中作者有比较V8引擎与其他语言的执行速度，作者列成了图表很清楚的显示出JavaScript引擎V8不俗的执行速度。\n\nV8是Google Chrome浏览器内置的JavaScript脚本引擎。\nGoogle Chrome使用V8的API，但引擎的内核部分是独立于浏览器之外的。\nV8引擎编译和执行JavaScript源代码。\n速度是V8引擎追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码 + 解释器”的引擎，优势不言而喻。\nV8引擎的团队说Chrome对脚本的解析和执行速度是Firefox和Safari的10倍，是IE的56倍。当然了，自夸自家的瓜甜，都是这样的嘛~最近不是新出了Safari又比Google Chrome快了80%的速度吗~但是只是因为Safari更新的比较快，优化了最新的ES6，所以与之前未做优化的Chrome相比快了不少~也是真能吹牛哈~\n\n***\n正是由于V8的高性能，所以基于nodejs开发的引擎就是V8引擎。\n***\n\nV8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。V8的JavaScript渲染引擎亮点在于更快速更强壮的JavaScript解析。V8是一个非常反传统的JavaScript引擎，它能够在后台动态的对JS的对象进行分类——一个在其他高级语言中很常见但JS本身不支持的特性。V8对JS的解析不是基于反复loop源代码进行解释而是直接将JS代码编译成机器码运行。换句话说，V8引擎实际上可以看做是JS的扩展和编译器——而传统上类似于JS的解释型语言恰恰是不需要编译器的。最后，高级语言的内存管理效能一直是决定其运行效率的重要因素，而当前的JS虚拟机在这方面做的比较基本，对内存的回收也非常保守。V8使用的是非常强势的内存管理策略，一切在运行堆栈里无用的数据都会被强行回收，从而可以大大提高JS代码的运行效率。\n在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。\n\n和Mozilla的SpiderMonkey一样，Google Chrome浏览器的JavaScript引擎Google V8也是一个开源的独立引擎，可内嵌于任何C++工程之中。\n\n>速度是V8追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码+解释器”的引擎，优势不言而喻。在SunSpider测试中，V8的综合表现是最好的。据说Mozilla正在开发的TraceMonkey比V8还要快20%左右，可惜尚未完工。\n\n# JavaScript的发展\n>Netscape Navigator 在 90 在年代中期对 JavaScript 进行了集成，这让网页开发人员对 HTML 页面中诸如 form 、frame 和 image 之类的元素的访问变得非常容易。由此 JavaScript 很快成为了用于定制控件和添加动画的工具，到 90 年代后期的时候，大部分的 JavaScript 脚本仅仅完成像“根据用户的鼠标动作把一幅图换成另一幅图”这样简单的功能。\n \n>随着最近 AJAX 技术的兴起，JavaScript 现在已经变成了实现基于 web 的应用程序（例如我们自己的 Gmail）的核心技术。JavaScript 程序从聊聊几行变成数百 KB 的代码。JavaScript 被设计于完成一些特定的任务，虽然 JavaScript 在做这些事情的时候通常都很高效，但是性能已经逐渐成为进一步用 JavaScript 开发复杂的基于 web 的应用程序的瓶颈。\n \n>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。其中的原因在你读过这份文档余下的部分之后就会明白了。\n \n# V8 的性能提升主要来自三个关键部分：\n1. 快速属性访问\n2. 动态机器码生成\n3. 高效的垃圾收集\n\n## 快速属性访问\nJavaScript 是一门动态语言，属性可以在运行时添加到或从对象中删除。这意味着对象的属性经常会发生变化。大部分 JavaScript 引擎都使用一个类似于字典的数据结构来存储对象的属性，这样每次访问对象的属性都需要进行一次动态的字典查找来获取属性在内存中的位置。这种实现方式让 JavaScript 中属性的访问比诸如 Java 和 Smalltalk 这样的语言中的成员变量的访问慢了许多。成员变量在内存中的位置离对象的地址的距离是固定的，这个偏移量由编译器在编译的时候根据对象的类的定义决定下来。因此对成员变量的访问只是一个简单的内存读取或写入的操作，通常只需要一条指令即可。\n \n为了减少 JavaScript 中访问属性所花的时间，V8 采用了和动态查找完全不同的技术来实现属性的访问：动态地为对象创建隐藏类。这并不是什么新的想法，基于原型的编程语言 Self 就用 map 来实现了类似的功能（参见 An Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language Based on Prototypes ）而且JavaScript在创建之初因为是赶时间赶出来的（10天的时间，而且还是Brendan Eich为了应付公司安排的任务的~），所以也正是借鉴了很多语言的长处，也就是上面所说的self语言和C语言等等（有一句话说的好：与其说我爱JavaScript，不如说我恨她；她是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：“她的优秀之处并非原创，她的原创之处并不优秀”）。在 V8 里，当一个新的属性被添加到对象中时，对象所对应的隐藏类会随之改变。\n \n下面我们用一个简单的 JavaScript 函数来加以说明：\n \n`function Point(x, y) {\n    this.x = x;\n    this.y = y;\n}`\n \n当 new Point(x, y) 执行的时候，一个新的 Point 对象会被创建出来。如果这是 Point 对象第一次被创建，V8 会为它初始化一个隐藏类，不妨称作 C0。因为这个对象还没有定义任何属性，所以这个初始类是一个空类。到这个时候为止，对象 Point 的隐藏类是 C0。\n \nmap_trans_a\n执行函数 Point 中的第一条语句（this.x = x;）会为对象 Point 创建一个新的属性 x。此时，V8 会：\n在 C0 的基础上创建另一个隐藏类 C1，并将属性 x 的信息添加到 C1 中：这个属性的值会被存储在距 Point 对象的偏移量为 0 的地方。\n在 C0 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 x 之后能够找到 C1 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C1。\n1. map_trans_b\n执行函数 Point 中的第二条语句（this.y = y;）会添加一个新的属性 y 到对象 Point 中。同理，此时 V8 会：\n在 C1 的基础上创建另一个隐藏类 C2，并在 C2 中添加关于属性 y 的信息：这个属性将被存储在内存中离 Point 对象的偏移量为 1 的地方。\n在 C1 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 y 之后能够找到 C2 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C2。\n2. map_trans_c\n咋一看似乎每次添加一个属性都创建一个新的隐藏类非常低效。实际上，利用类转移信息，隐藏类可以被重用。下次创建一个 Point 对象的时候，就可以直接共享由最初那个 Point 对象所创建出来的隐藏类。例如，如果又一个 Point 对象被创建出来了：\n一开始 Point 对象没有任何属性，它的隐藏类将会被设置为 C0。\n当属性 x 被添加到对象中的时候，V8 通过 C0 到 C1 的类转移信息将对象的隐藏类更新为 C1 ，并直接将 x 的属性值写入到由 C1 所指定的位置（偏移量 0）。\n当属性 y 被添加到对象中的时候，V8 又通过 C1 到 C2 的类转移信息将对象的隐藏类更新为 C2，并直接将 y 的属性值写入到由 C2 所指定的位置（偏移量 1）。\n\n尽管 JavaScript 比通常的面向对象的编程语言都要更加动态一些，然而大部分的 JavaScript 程序都会表现出像上述描述的那样的运行时高度结构重用的行为特征来。使用隐藏类主要有两个好处：属性访问不再需要动态字典查找了；为 V8 使用经典的基于类的优化和内联缓存技术创造了条件。\n\n## 动态机器码生成\nV8 在第一次执行 JavaScript 代码的时候会将其直接编译为本地机器码，而不是使用中间字节码的形式，因此也没有解释器的存在。属性访问由内联缓存代码来完成，这些代码通常会在运行时由 V8 修改为合适的机器指令。\n \n在第一次执行到访问某个对象的属性的代码时，V8 会找出对象当前的隐藏类。同时，V8 会假设在相同代码段里的其他所有对象的属性访问都由这个隐藏类进行描述，并修改相应的内联代码让他们直接使用这个隐藏类。当 V8 预测正确的时候，属性值的存取仅需一条指令即可完成。如果预测失败了，V8 会再次修改内联代码并移除刚才加入的内联优化。\n \n例如，访问一个 Point 对象的 x 属性的代码如下：\n \npoint.x\n \n在 V8 中，对应生成的机器码如下：\n \n`; ebx = the point objectcmp [ebx, <hidden class offset>], <cached hidden class>\njne <inline cache miss>\nmov eax, [ebx, <cached x offset>]`\n \n如果对象的隐藏类和缓存的隐藏类不一样，执行会跳转到 V8 运行系统中处理内联缓存预测失败的地方，在那里原来的内联代码会被修改以移除相应的内联缓存优化。如果预测成功了，属性 x 的值会被直接读出来。\n \n当有许多对象共享同一个隐藏类的时候，这样的实现方式下属性的访问速度可以接近大多数动态语言。使用内联缓存代码和隐藏类实现属性访问的方式和动态代码生成和优化的方式结合起来，让大部分 JavaScript 代码的运行效率得以大幅提升。\n\n## 高效的垃圾回收机制\nV8 会自动回收不再被对象使用的内存，这个过程通常被称为“垃圾收集（Garbage Collection）”。为了保证快速的对象分配和缩短由垃圾收集造成的停顿，并杜绝内存碎片，V8 使用了一个 stop-the-world, generational, accurate 的垃圾收集器，换句话说，V8 的垃圾收集器：\n\n1. 在执行垃圾回收的时候会中断程序的执行。\n2. 大部分情况下，每个垃圾收集周期只处理整个对象堆的一部分，这让程序中断造成的影响得以减轻。\n3. 总是知道内存中所有的对象和指针所在的位置，这避免了非 accurate 的垃圾收集器中普遍存在的由于错误地把对象当作指针而造成的内存溢出的情况。\n\n在 V8 中，对象堆被分成两部分：用于为新创建的对象分配空间的部分和用于存放在垃圾收集周期中生存下来的那些老的对象的部分。如果一个对象在垃圾收集的过程中被移动了，V8 会更新所有指向这个对象的指针到新的地址。","tags":["JavaScript"],"categories":["认知提升"]},{"title":"The Tipping Point","url":"/2018/2018.01.28 The Tipping Point.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n《引爆点》这本书是格拉德威尔在2000年出版的。一经出版就火爆全球，书中介绍的“引爆点”和流行三法则，已经成为当下的商业理论新经典。\n思考是这本书的主旋律，作者对生活中的一些常见现象，并没有去听从各种专家所说的，不能让人信服的观点，例如：经济学家所说的是由于经济的好转所以就是年代的纽约市犯罪行为的减少；犯罪学家所说的是由于纽约市警察局的警力部署的加强所导致的犯罪行为的减少等等。作者深入思考了这些社会现象之后，认为那些专家所说的理由并不能成为形成这种现象的原因，进而自己来进行寻找和探索，由此而诞生的这本书，进而解读我们社会中的一些流行事件的原因，真的是让我们这些读者打开思想的大门，教给我们各种新奇规律的同时，也教给了我们思考问题的方式和方法。\n书中的很多著名的专家学者在开篇点评这本书，看完这本书之后重新看这些评语，真是另一种感受：格拉德威尔不愧为2005年《时代》杂志评为世界最有影响力的100人之一，普通人的回答，很少能超出几个大脑早已作出的界定，如：亚当斯密的“看不见的手”、凯恩斯的“调控”、哈耶克的“自发生成秩序”、马克思的辩证唯物主义和历史唯物主义、弗洛伊德的心理分析...而变革者则提出理解世界的新方法：凯恩斯对亚当斯密进行修补；弗洛伊德另辟蹊经；毕加索挑战马蒂斯；爱因斯坦修订牛顿为大自然的“立法”，德鲁克对组织进行研究，提出“知识工人”与受雇阶层的理论。本质上，格拉德威尔与上面提到的为人是一类人，也是一个有新意的变革者。书中开创性的提出了很多名词：流行三法则（个别人物法则[联系员、内行和推销员---保罗·里维尔骑马夜行]、附着力法则[影响事情的主要原因跟我们所想的不一样，往往是很微小的因素所形成的---金盒子广告和打破伤风疫苗、芝麻街和蓝狗线索]、环境威力法则[人们往往会在心里对一个人有一种印象，而往往忽视了环境的不同造成的影响因素；而在事实与我们印象中的不同时我们又会找一个我们自己所能够理解的方式来解释，而保留对一个人印象的唯一性；思维定势中的我们往往又会夸大一些环境因素对我们的影响，例如：家庭因素对我们的影响等等，其实并没有那么大的影响---流言、破窗理论、地铁涂鸦、地铁逃票...]）\n\n引爆点教给了我们什么道理？就像作者总结的一样总共有三个。\n\n# 集中有限的力量，全力以赴。\n我们大多数人做事，一般都是差不多的思维模式，相同的老办法。而往往这种老方法有时候并不是最优的，这种方法可能会包含着太多的浪费我们有限的资源的情况。思维定式之下，我们很难跳出这种限制，而格拉德威尔的这本书中就教给了我们很多方法，去找出事情的引爆点，往往就能付出最小的代价做成很多事情。美国独立战争时期，保罗·里维尔骑马夜行是成功的，但是另一个方向出发的威廉·戴维斯却是失败的，他没有成为历史上有名的人物...取巧之计用在这儿挺合适的，在编程中我们想要成长我们必须要取巧，各种自动化工具的使用，让电脑代替我们去处理重复繁琐的事情；在生活中取巧是我们做事情之前先要想到这件事情成功的引爆点在哪儿，尽量用最少的资源完成事情，不加选择地付出努力并非总是可行的，我们要尽可能的找到到达终点的捷径，以达到事半功倍的效果。\n\n# 世界并非是我们一厢情愿的直觉中的世界\n我们总是在杂乱与黑暗之中行事，所以造成了很多的不必要的步骤。我们所认知的范畴限制了我们所看待世界的方式和误解我们所接触到的超出我们理解范围的事情。以抽象方式被表述成形象的社会问题，我们解决起来将会毫无困难。人类思维的特殊之处，在于我们能很好的处理同类之间复杂的关系。我们遇到问题的第一想法是先看一下我们的大脑中有没有储存以前类似的相关问题，类比之前的类似问题来进行处理现在所遇到的问题，但是我们又往往会忽略当下的条件下的不同，或是局限与我们知识储备的不足，处理当下的事情进而使用了错误的方法。\n\n","tags":["认知提升"],"categories":["读书笔记"]},{"title":"磁盘格式","url":"/2018/2018.01.21 磁盘格式.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n好久没更博客了，虽然没什么人看，但是作为练习自己写作能力的锻炼和提升，也不能荒废我的博客更新哈~\n说一下我最近的个人动态吧~ 现在学校放假有两个星期了，学校一放假就跑到实习公司来实习了，一进公司报到当天就给我配置了2015年的mac pro顶配版，不得不说真是开心哈~而且是2017年产的新开封的哦~不要羡慕哦~哈哈哈，你们以后工作也会有的。然后新进公司第一周就一直在熟悉mac本的一些基础操作，没办法，谁让我没用过这种高大上的苹果笔记本呢。我是刚把Windows系统的笔记本用到稍微熟练一点儿，就让我接触mac真是有点儿不熟悉呢，不过经过一周的操作训练，越来越觉的mac的人性化，怪不得办公的大公司的白领啦、管理者啦、领导啦什么的，都喜欢用苹果本办公呢，真的比Windows好用多了，当然了，这只是我个人的一些浅显小想法，大家不同意就当我没说，我的人生阅历还是很少，不能确定说的对哈~\n\n好了，接下来就来说一下写这篇博客的由来吧~换上了mac本之后，看到了mac自带的时间机器，感觉好高大上啊，可以自动保存快照，想什么时候回退到哪儿都行，真是太强大的一个功能了。虽然这个说是不占用mac上剩余的内存，不过我还是担心影响我的笔记本日常所使用的性能，万一影响我的使用体验都不好，在说了我也有一个自己的硬盘，为什么不用我自己的硬盘当作是Time Machien的保存磁盘呢；想到就去做了，第二天就把我的磁盘带过来了，兴致勃勃的插上去却让我失望了，居然是只能读的权限，然后我才知道Windows下的保存文件格式与mac下的保存文件格式是不同的。啊啊啊，要想用做mac的时间机器的御用磁盘必须先把磁盘数据全部格式化了，但是我的磁盘上还有好多我都珍贵的资源呢，怎么能删除掉呢，所以只能先把数据保存到其他的地方，到时候把磁盘的格式改回来在存进去。然后就又把磁盘带回去了，把数据拷贝到了我的Windows电脑上，然后在mac上把磁盘格式化了，终于能用作备份磁盘了，真是好不容易啊。但是这样的话又变成了磁盘只能在mac上用了，所以我索性把我的1T硬盘，分成3个区，一个单独的用作mac数据备份区，另两个一个用作Windows存放数据区，另一个用作mac存放数据区。这样总算大功告成了吧，谁知道原来我把Windows上使用的存放数据格式给改成了Fat32格式的，不是我想要的NTFS格式的，但是这个时候我已经把原先的数据都已经导回来了，实在不想再折腾了，啊啊啊，好伤心啊！接下来就让我介绍一下他俩的区别吧~\n\n# FAT32与NTFS的区别\n在推出FAT32文件系统之前，通常PC机使用的文件系统是FAT16。像基于MS-DOS，Win 95等系统都采用了FAT16文件系统。在Win 9X下，FAT16支持的分区最大为2GB。我们知道计算机将信息保存在硬盘上称为“簇”的区域内。使用的簇越小，保存信息的效率就越高。在FAT16的情况下，分区越大簇就相应的要增大，存储效率就越低，势必造成存储空间的浪费。并且随着计算机硬件和应用的不断提高，FAT16文件系统已不能很好地适应系统的要求。在这种情况下，推出了增强的文件系统FAT32。同FAT16相比，FAT32主要具有以下特点：\n1. 同FAT16相比FAT32最大的优点是可以支持的磁盘大小达到2TB（2047GB），但是不能支持小于512MB的分区。基于FAT32的Win 2000可以支持分区最大为32GB；而基于 FAT16的Win 2000支持的分区最大为4GB。\n2. 由于采用了更小的簇，FAT32文件系统可以更有效率地保存信息。如两个分区大小都为2GB，一个分区采用了FAT16文件系统，另一个分区采用了FAT32文件系统。采用FAT16的分区的簇大小为32KB，而FAT32分区的簇只有4KB的大小。这样FAT32就比FAT16的存储效率要高很多，通常情况下可以提高15%。\n3. FAT32文件系统可以重新定位根目录和使用FAT的备份副本。另外FAT32分区的启动记录被包含在一个含有关键数据的结构中，减少了计算机系统崩溃的可能性。\nNTFS文件系统\nNTFS文件系统是一个基于安全性的文件系统，是Windows NT所采用的独特的文件系统结构，它是建立在保护文件和目录数据基础上，同时照顾节省存储资源、减少磁盘占用量的一种先进的文件系统。使用非常广泛的Windows NT 4.0采用的就是NTFS 4.0文件系统，相信它所带来的强大的系统安全性一定给广大用户留下了深刻的印象。Win 2000采用了更新版本的NTFS文件系统??NTFS 5.0，它的推出使得用户不但可以像Win 9X那样方便快捷地操作和管理计算机，同时也可享受到NTFS所带来的系统安全性。\nNTFS 5.0的特点主要体现在以下几个方面：\n1. NTFS可以支持的分区(如果采用动态磁盘则称为卷)大小可以达到2TB。而Win 2000中的FAT32支持分区的大小最大为32GB。\n2. NTFS是一个可恢复的文件系统。在NTFS分区上用户很少需要运行磁盘修复程序。NTFS通过使用标准的事物处理日志和恢复技术来保证分区的一致性。发生系统失败事件时，NTFS使用日志文件和检查点信息自动恢复文件系统的一致性。\n3. NTFS支持对分区、文件夹和文件的压缩。任何基于Windows的应用程序对NTFS分区上的压缩文件进行读写时不需要事先由其他程序进行解压缩，当对文件进行读取时,文件将自动进行解压缩；文件关闭或保存时会自动对文件进行压缩。\n4. NTFS采用了更小的簇,可以更有效率地管理磁盘空间。在Win 2000的FAT32文件系统的情况下,分区大小在2GB～8GB时簇的大小为4KB；分区大小在8GB～16GB时簇的大小为8KB；分区大小在16GB～32GB时,簇的大小则达到了16KB。而Win 2000的NTFS文件系统，当分区的大小在2GB以下时,簇的大小都比相应的FAT32簇小;当分区的大小在2GB以上时(2GB～2TB),簇的大小都为4KB。相比之下，NTFS可以比FAT32更有效地管理磁盘空间，最大限度地避免了磁盘空间的浪费。\n5. 在NTFS分区上,可以为共享资源、文件夹以及文件设置访问许可权限。许可的设置包括两方面的内容：一是允许哪些组或用户对文件夹、文件和共享资源进行访问；二是获得访问许可的组或用户可以进行什么级别的访问。访问许可权限的设置不但适用于本地计算机的用户,同样也应用于通过网络的共享文件夹对文件进行访问的网络用户。与FAT32文件系统下对文件夹或文件进行访问相比，安全性要高得多。另外,在采用NTFS格式的Win 2000中,应用审核策略可以对文件夹、文件以及活动目录对象进行审核，审核结果记录在安全日志中，通过安全日志就可以查看哪些组或用户对文件夹、文件或活动目录对象进行了什么级别的操作，从而发现系统可能面临的非法访问,通过采取相应的措施，将这种安全隐患减到最低。这些在FAT32文件系统下,是不能实现的。\n6. 在Win 2000的NTFS文件系统下可以进行磁盘配额管理。磁盘配额就是管理员可以为用户所能使用的磁盘空间进行配额限制，每一用户只能使用最大配额范围内的磁盘空间。设置磁盘配额后，可以对每一个用户的磁盘使用情况进行跟踪和控制，通过监测可以标识出超过配额报警阈值和配额限制的用户，从而采取相应的措施。磁盘配额管理功能的提供，使得管理员可以方便合理地为用户分配存储资源，避免由于磁盘空间使用的失控可能造成的系统崩溃，提高了系统的安全性。\n7. NTFS使用一个“变更”日志来跟踪记录文件所发生的变更。\n\n# 小提示(选取FAT32和NTFS的建议)\n在系统的安全性方面，NTFS文件系统具有很多FAT32文件系统所不具备的特点，而且基于NTFS的Win 2000运行要快于基于FAT32的Win 2000；而在与Win 9X的兼容性方面，FAT32优于NTFS。所以在决定Win 2000中采用什么样的文件系统时应从以下几点出发：\n1. 计算机是单一的Win 2000系统，还是采用多启动的Win 2000系统；\n2. 本地安装的磁盘的个数和容量；\n3. 是否有安全性方面的考虑等。\n基于以上的考虑，如果要在Win 2000中使用大于32GB的分区的话，那么只能选择NTFS格式。如果计算机作为单机使用，不需要考虑安全性方面的问题，更多地注重与Win 9X的兼容性，那么FAT32是最好的选择。如果计算机作为网络工作站或更多的追求系统的安全性，而且可以在单一的Win 2000模式下运行，强烈建议所有的分区都采用NTFS格式；如果要兼容以前的应用，需要安装Win 9X或其它的操作系统，建议做成多启动系统，这就需要两个以上的分区，一个分区采用NTFS格式，另外的分区采用FAT32格式，同时为了获得最快的运行速度建议将Win 2000的系统文件放置在NTFS分区上，其它的个人文件则放置在FAT32分区中。\n回答字数10000字以内\n参考资料：\n如果您的回答是从其他地方引用，请表明出处。\n--------------------------------------------------------------------------------\n# FAT分区与NTFS分区有什么区别？\n## NTFS\n在选择 NTFS 时可以使用的功能有：\nActive Directory，可用来方便地查看和控制网络资源。\n域，它是 Active Directory 的一部分，在简化管理的同时，依然可以使用域来调整安全选项。域控制器需要 NTFS 文件系统。\n文件加密，它极大地增强了安全性。\n可以对单个文件设置权限，而不仅仅是对文件夹进行设置。\n稀疏文件，这些是由应用程序创建的非常大的文件，以这种方式创建的文件只受磁盘空间的限制。也就是，NTFS 只为写入的文件部分分配磁盘空间。\n远程存储，通过使可移动媒体（如磁带）更易访问，从而扩展了硬盘空间。\n磁盘活动恢复记录，可帮助您在断电或发生其他系统问题时，尽快地还原信息。\n磁盘配额，可用来监视和控制单个用户使用的磁盘空间量。\n可更好地支持大驱动器，NTFS 支持的最大驱动容量比 FAT 支持的容量大得多，但随着驱动器容量得增大，NTFS 的性能并不随之降低，而 FAT 的性能却急速下降。\n这只是最新版 NTFS 的部分功能列表。有关新功能的详细信息，请参阅 Windows 2000 Advanced Server 的新特性。\n安装程序可以方便地将分区转换为新版的 NTFS，即使该分区以前使用的是 FAT 或 FAT32 文件系统，这种转换可保持文件的完整性（与格式化分区不同）。安装程序通过从检查现有的文件系统开始运行。如果文件系统是 NTFS，转换会自动发生。如果是 FAT 或 FAT32，安装程序可让您选择是否要将它们转换为 NTFS。如果不想保留文件，且有一个 FAT 或 FAT32 分区，建议使用 NTFS 格式化该分区，而不是转换 FAT 或 FAT32 文件系统。格式化分区会删除该分区上所有的数据，但使用 NTFS 格式化的分区与从 FAT 或 FAT32 转换来的分区相比，磁盘碎片较少，且性能更快。\n但是使用 NTFS 依然有缺点，不论该分区是用 NTFS 格式化还是从以前的文件系统转换而来。在安装完成之后，也可以使用 Convert.exe 转换分区的文件系统。有关 Convert.exe 的详细信息，在结束安装之后，单击“开始”，再单击“运行”，键入 cmd 并按回车键键即可查阅它的信息。在命令窗口，键入 help convert，然后按回车键。FAT 和 FAT32\nFAT 和 FAT32 是可选的文件系统选项。如果必须将计算机安装为有时使用以前的操作系统（有时使用 Windows 2000），则将要使用这些文件系统。其他信息，请参阅：\n决定计算机是否包含多个操作系统\n多个操作系统和文件系统的兼容性\n包含 Windows NT 4.0 和 Windows 2000 Advanced Server 的计算机\n在 NTFS、FAT 和 FAT32 间选择\n有关 FAT 和 FAT32 之间区别的详细信息，请参阅在 NTFS、FAT 和 FAT32 间选择中的表格。如果要在 FAT 和 FAT32 之间做出选择，基本的标准是安装分区的大小。如果分区容量是 2 GB 或更大，应使用 FAT32 而不是 FAT 分区。\n注意\nWindows 2000 支持任意大小的由 Windows 95 或 Windows 98 创建的 AT32 卷。但是，Windows 2000 格式化的 FAT32 卷最大容量只能达到 32 GB。NTFS 是更好的选择，可应用在容量大于 32 GB 的卷上。\n如果在安装过程中，选择使用 FAT 格式化分区，且该分区大于 2 GB，那么安装程序会自动用 FAT32 文件系统格式化。\n在 NTFS、FAT 和 FAT32 间选择\n可以为 Windows 2000 Advanced Server 计算机的磁盘分区选择下列之一的文件系统：NTFS、FAT 和 FAT32。NTFS 是推荐的文件系统。FAT 和 FAT32 彼此相似，但与 FAT 相比，FAT32 可用在容量较大的磁盘上。（最容易使用大磁盘的文件系统是 NTFS。）本节介绍的信息可帮助您比较这些文件系统，有关每种文件系统的其他信息，请参阅：\nNTFS\n##FAT 和 FAT32\nNTFS 与 FAT 和 FAT32 相比，它是最强大的文件系统。Windows 2000 Advanced Server 包括新版本的 NTFS，它支持各种新功能（包括 Active Directory），而域、用户帐户和其他重要的安全特性都需要 Active Directory 功能。\n安装程序可以方便地将分区转换为新版的 NTFS，即使该分区以前使用的是 FAT 或 FAT32 文件系统，这种转换可保持文件的完整性（与格式化分区不同）。如果不想保留文件，且有一个 FAT 或 FAT32 分区，建议使用 NTFS 格式化该分区，而不是转换 FAT 或 FAT32 文件系统。格式化分区会删除该分区上所有的数据，但使用 NTFS 格式化的分区与从 FAT 或 FAT32 转换来的分区相比，磁盘碎片较少，且性能更快。\n但是使用 NTFS 依然有缺点，不论该分区是用 NTFS 格式化还是从以前的文件系统转换而来。在安装完成之后，也可以使用 Convert.exe 转换分区的文件系统。有关 Convert.exe 的详细信息，在结束安装之后，单击“开始”，再单击“运行”，键入 cmd 并按回车键即可查阅它的信息。在命令窗口，键入 help convert，然后按回车键。\n注意\n只有通过选择 NTFS 作为您的文件系统，才能使用诸如 Active Directory 和基于域的安全性等重要功能。\n有一种情况可能需要将 FAT 或 FAT32 选为您的文件系统。如果需要让计算机有时运行早期的操作系统，有时运行 Windows 2000，则需要将 FAT 或 FAT32 分区作为硬盘上的主（或启动）分区。这是因为早期的操作系统（只有一个例外），都无法访问使用最新版 NTFS 格式化的分区。例外是带有 Service Pack 4 或更高版本的 Windows NT 4.0，它可以访问使用最新版 NTFS 格式化的分区，但也有一些限制。Windows NT 4.0 无法访问那些用在 Windows NT 4.0 发布时，还没出现的 NTFS 功能存储的文件。详细信息，请参阅：\n决定计算机是否包含多个操作系统\n多个操作系统和文件系统的兼容性\n但对于其他包含多个操作系统的情况，推荐的文件系统依然是 NTFS。\n下面的表格介绍了每个文件系统与各种操作系统的兼容性。\nNTFS FAT FAT32\n运行 Windows 2000 的计算机可以访问 NTFS 分区上的文件。运行带有 Service Pack 4 或更高版本的 Windows NT 4.0计算机可能可以访问某些文件。其他操作系统则无法访问。 可以通过 MS-DOS、所有版本的 Windows、 Windows NT、 Windows 2000 和 OS/2 访问。 只能通过 Windows 95 OSR2、Windows 98 和 Windows 2000 访问。\n下表比较了每个文件系统支持的磁盘和文件大小。\nNTFS FAT FAT32\n推荐最小的容量为 10 MB，\n推荐实际最大的容量为 2 TB，并可支持更大的容量。\n无法用在软盘上。\n容量可从软盘大小到最大 4 GB。\n不支持域。\n容量从 512 MB 到 2 TB。\n在 Windows 2000 中，可以格式化一个不超过 32 GB 的 FAT32 卷。\n不支持域。","tags":["认知提升"],"categories":["资源分享"]},{"title":"Amour-影评","url":"/2017/12/2017.12.08 Amour.html","content":"**{{title}}**   <Excerpt in index | 首页摘要>\n我今年23岁，在我的这有限的人生阅历中，只经历过一次亲人的离世--我的姥爷。昨天看完了法国2012年上映的电影《Amour》，让我有很大的感触，也让我回想起了我的姥爷。人生生老病死本是常态，但是当一个人慢慢变老，而由变老带来的一系列问题真的是很让人无奈又不甘心的吧！与天斗，与地斗，与人斗，最后变成了与自己斗！\n影片中的两位主人公都是已经退休的80多岁的音乐老师，本来在安享晚年的时候，却横遭变故，女主角Anne毫无征兆的突然中风，而后右半身偏瘫，直至最后的卧床不起..而后是男主角Georges照顾Anne的一系列平常的事情，但是也正是在平常的生活中才能见证两个人的感情..以及各自的心理变化，到最后男主的妥协..\n这部电影讲的太过于真实，以至于直敲心灵深处。看完这部电影就像影片中男主角说他小时候看过的电影一样，看的过程中很触动感情，看完之后再回想的时候更是一发不可收拾。昨天晚上看完这部电影，今天早上再回想起来的时候眼泪更是止不住的留下来，真的跟男主角说的一样..难道这也是导演做的对这部电影的铺垫吗？\n这部电影从头到尾都是平铺直叙式的拍摄方式，背景音乐也只是再特定的时候才用到了钢琴曲，我不敢去看第二遍了，所以这是我大概的记忆，不知道对不对。没有生活中的大起大落，只是平常生活中的平平淡淡的像极了平常人的老年生活，但是也正是这样，才直指人内心深处的感触，才能激起泪腺啊！才让我对爱有了更为真实的定义。\n# 女主角的心理历程\n从一开始的病情征兆的出现，女主角对自己的病情很害怕，因为是80对岁的人了，做手术风险很高，对一般人来说几乎没什么风险的手术，都年纪很大的女主角来说风险很高了。影片中男主角也说到了做手术的风险很低，但是不巧的是女主角正好是那风险很低的5%的一部分里。做完手术后身体半瘫，从刚开始的难以接受，自尊心受到了极大的打击，乃至于男主角有一天去参加一个朋友的葬礼，提前回来之后发现女主角倒在开着的窗台下面，男主角没有问为什么会发生这样的事，他应该也能猜到Anne的想法，觉得自己是一个累赘，不如一死了之。再到Anne看相册时说的一句话：人生真是太过漫长了。听到这儿，Georges不知该说什么，明白了Anne的心思。\n\n片中的一幕死亡引起了不少观众的非议，这不禁让我想起“安乐死”的议题。笔者所在的荷兰是最早通过“安乐死”的国家，“安乐死”其实是对生者权利和意愿的尊重。电影中的这一幕，有区别，却也有类同。许多观众无法对片中展示的价值观进行认同，其实我看《Amour》的时候，当乔治拿起枕头时，也先是吃惊，不解，随后心中却升起无尽的悲凉。电影中的细节已经无数次提醒观众：Anne去意已决，当George回家看到Anne跌坐在窗口，Anne已有了跳楼离世之心；当Anne翻起相册时，她不是已经说过，人生之于她，已经太过于漫长了么？当她彻夜喊着“痛”，喊着“妈妈”时，她难道不是已经无法再忍受下去了么？当George给Anne喂汤时，她莫非不也是无法接受最后的怜悯了么？巴掌打在Anne的脸上，却也重重打在了George的心上，这样下去的苟延残喘，只会带来互相伤害，保姆已经用梳头和镜子彻底摧毁了Anne仅剩的一点点自尊心，他又能带给她什么呢？\n\n于是我泪流满面，明白了George的用意，与其让爱人痛苦着死去，不如让她快乐地活在他心里。一辈子的相濡以沫，又怎么会不懂得爱人的心意呢？那些只看到“谋杀”的观众，恐怕涉世未深，对“爱”无法理解吧。\n","tags":["影评"],"categories":["个人分享"]},{"title":"Js中一些相似方法/属性的区别","url":"/2017/12/2017.12.05 js中一些方法的比较与区别.html","content":"**{{title}}**   <Excerpt in index | 首页摘要>\n# forEach 与 map 方法比较\nforEach()和map()两个方法都是ECMA5中Array引进的新方法，主要作用是对数组的每个元素都执行一次所提供的函数，但是它们之间还是有区别的。jQuery也有一个方法$.each(),长得和forEach()有点像，功能也类似。但是从本质上还是有很大的区别的。\n\n`//forEach\narray.forEach(callback(currentValue, index, array){\n    //do something\n}, this)\n \n//或者\narray.forEach(callback(currentValue, index, array){\n    //do something\n})　　\n \n//map:\nvar new_array = arr.map(callback[, thisArg])　\n \n//$.each()\n$(selector).each(function(index,element))  //注意参数的顺序`\n\ncallback: 为数组中每个元素执行的函数,该函数接收三个参数，\n\n**参数一：当前数组中元素；参数二：索引； 参数三：当前数组。**\n\n**this：可选，执行会掉时候，this的指向。**\n***\n区别：\n1. forEach()返回值是undefined，不可以链式调用。\n\n2. map()返回一个新数组，原数组不会改变。\n\n3. 没有办法终止或者跳出forEach()循环，除非抛出异常，所以想执行一个数组是否满足什么条件，返回布尔值，可以用一般的for循环实现，或者用Array.every()或者Array.some();\n\n4. $.each()方法规定为每个匹配元素规定运行的函数，可以返回 false 可用于及早停止循环。\n***\nArray 在 Javascript 中是一个对象， Array 的索引是属性名。\n事实上， Javascript 中的 “array” 有些误导性， Javascript 中的 Array 并不像大部分其他语言的数组。首先， Javascript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。\n实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 \"0\" 。\n所以，在 Javascript 中从来就没有 Array 的索引，而只有类似 \"0\" 、 \"1\" 等等的属性。有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。\n但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。\n\nmap可以做链式操作，forEach不可以，\nfor不用担心兼容性的问题，还有可以break跳出循环，是基础循环，可以有for...in,foo...of,for(let i=0;i<len;i++)等。可以用continue和break控制\nforEach是for(let i=0;i<len;i++)的缩写，不支持continue和break，可以return来控制循环，forEach是不能退出循环本身的\nmap循环当前可循环对象，并且返回新的可循环对象，而forEach没有返回值\nforEach只有在火狐和谷歌浏览器中Array有这个方法，在IE中就米有，需要用prototype手动添加这个方法。\n\n# 类数组与数组的区别\n类数组对象：\nconsole.log(typeof a);//object 注意：数组也是对象哦\nconsole.log(a); //  Object {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81} 很明显对象啊\nconsole.log(a.length); //undefined  区别就在这了  类数组对象没有长度的属性和数组的方法\nconsole.log(Object.prototype.toString.call(a));//[object Object] \n数组对象：\nconsole.log(typeof b);//object\nconsole.log(b);//  [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]  很明显数组啊 \nconsole.log(b.length); //8\nconsole.log(Object.prototype.toString.call(b));//[object Array]","tags":["学习笔记"],"categories":["JavaScript"]},{"title":"彗星来的那一夜-影评","url":"/2017/12/2017.12.04 彗星来的那一夜-影评.html","content":"**{{title}}**   <Excerpt in index | 首页摘要>\n\n**想象一下我们生活在一个多平行空间中，有无数个平行空间中的我们，每做一个选择就会在另一个平行世界中发生另一种我们的人生..**\n\n转载一篇我认可的影评吧，不看这篇影评我都注意不到电影中的这些细微之处的细节。转载自--豆瓣   [原文地址](https://movie.douban.com/review/7109306/)\n\n1. 全片的关键词是片名“Coherence”，而不是“薛定谔的猫”\n\n我得说，原片名《Coherence》比中文译名《彗星来的那一夜》逼格高很多。\n\nCoherence，直译就是“相干性”。经典物理中最简单的定义就是：这是一种让两列波产生干涉的性质。而在量子物理中，coherence可以从很多种角度去定义，后面再讲。\n\n我不同意有人说的这是一部披着科幻外衣的人文片。相反，这片子的科学内核硬得很。用“Coherence”作片名，就说明编剧对量子物理的了解已经超过了简单卖弄一下“薛定谔的猫”这个概念或是不管三七二十一拿过“平行世界”的概念就来用的水平。我倒觉得最后女主黑化，展现“人性”的那一段，反而是副主题而已。\n\n那么，“薛定谔的猫”和“平行世界”有什么关系？Coherence在这里又是什么含义？\n\n简单来说，“薛定谔的猫”不是“平行世界”导致的结果。“平行世界”只是用来诠释“薛定谔的猫”的理论之一，更通行的说法是“多世界诠释” （many-worlds interpretation）。\n\n这部片子其实是在量子力学的多世界诠释是正确的设定下，描写了“多世界”（平行世界）发生相干（coherence）时发生的事。\n\n“薛定谔的猫”，让很多人迷惑的多半是在人开门观察之前，猫所处的那种不死不活又死又活的状态。其实，这种状态虽然诡异，但理论上总可以用一个波函数来表示。这个波函数在物理学家眼中具有很好的性质，因为它随时间的变化遵循薛定谔方程。门一开，“诡异\"的状态立刻解除，我们得到了一个确定的状态：死或者活。开门瞬间猫的状态改变了，这意味着猫的波函数也有了一个突变，这个突变几乎是瞬时的，且不遵循薛定谔方程，是一种看上去由我们的观察（测量）而导致的突如其来的变化——这种由测量导致的突变才是更诡异的地方。\n\n这种突变的本质是什么？就是量子力学如何诠释的问题了。两种最流行的诠释就是：哥本哈根诠释和多世界诠释。\n\n哥本哈根诠释的核心在于波函数会“塌缩”，也就是测量瞬间，波函数以一定概率“突变”到一个确定的状态。在这种诠释下，不存在“平行世界”。猫死掉或是活着，完全是我们所在的唯一的宇宙里发生的一个随机的现象。\n\n而在多世界诠释里，开门之前，一切和哥本哈根诠释一样。开门的一瞬间，波函数并没有塌缩，但宇宙却一分为二。在一个宇宙里猫是死的，在另一个宇宙里猫是活的。关键是，活猫的宇宙和死猫的宇宙在很短的时间里就“退相干”（decoherence)了，因此，这两个宇宙不会重叠——或者说它们退相干的速度非常之快，以至于一个宇宙中的人不可能觉察另一个宇宙的存在。\n\n很明显，这部片子讨论的不是猫在开门之前的又死又活的状态（刘慈欣的《球状闪电》讨论的倒是这个），而是“开门之后”发生的事情。影片的设定里，量子力学的多世界诠释是正确的，而哥本哈根诠释是不正确的。因此，开门之后，各种可能的宇宙同时产生。只不过彗星发挥了神奇的作用，将这些可能的宇宙保持在一个相干的状态，里面的人可以看到甚至进入另一个宇宙。\n\n其实，这一点在Hugh读那本书的时候已经说的很明白了。因此，最后天亮，彗星解体，世界看似回到正常的时候，发生的也不是“塌缩”，而是多世界之间“退相干”了。\n\n结论：很多评论里都在用薛定谔的猫来解释这片子，其实这片子跟薛定谔的猫那种又死又活的状态没有什么关系。全片没有任何地方发生了“塌缩”，即使到最后天亮了一切看似恢复正常了，也不代表其他平行宇宙塌缩掉了。而只是说明所有的平行宇宙都退相干了，不再处于coherence的状态了。\n\n所以，那诡异的一夜，发生的事情，就是平行宇宙间的coherence，以此作片名，还是相当精准的。\n\n——————————————————————\n\n2. 谁制造了平行世界？\n\n个人理解，彗星可能开了个头（有的宇宙里Hugh的手机裂了，有的没有），但绝大多数的平行世界都是那八个人自己制造的。\n\n回到薛定谔的猫。宇宙的分裂和平行世界的产生，都是由“开门观察”这一行为造成的。也就是说，一次“测量”可能的结果有多少种，就会造成多少个平行世界。\n\n讨论这部电影的时候，我们当然不必太过拘泥于“测量”的精确定义。我们只要记住，当他们每一次就某件事做出选择，他们就制造出了对应这个选择不同结果的平行宇宙。\n\n一开头宇宙就分裂了，有的宇宙里Hugh的手机裂了，有的世界里没有（最后打成一团的时候就看到了）。 这个分裂的原因没有明说，可能是彗星。\n\n而其中一次明显的人为选择，就是Hugh选择创可贴的种类。两种选择，制造出两个平行宇宙。\n\n第二次明显的人为选择，就是荧光棒的颜色。主视角的那个世界里他们选了蓝色，于是就必然有选择红色和绿色的平行世界在他们作出选择的时刻同时产生。所以，在这个蓝色荧光棒宇宙里，在他们做出新的选择之前，他们出去看到的另一个宇宙里的自己手里拿的荧光棒必然是不同的颜色——比如红色。\n\n如果就此止步，两种创可贴的选择造成两个平行世界，这两个平行世界里又各自有三种荧光棒的选择，于是这里就有2乘3也就是6个平行世界。\n\n接下来就疯狂了。他们八个人要用骰子人为制造随机性来标记自己。要知道，8个人掷骰子，每个人有6种可能，于是总共有6的8次方种可能的排列组合，这么一来，他们在之前的6个平行世界的每一个世界里又一下子制造出了6的8次方个平行宇宙，再加上照片的选择和随机物品的选择，这样下来平行宇宙的数量就多到令人发指的几千万个了。\n\n所以，这么细抠下来，片子里平行宇宙的总数并不是一开始就有许多个，而是随着他们的选择一次次增长的。\n\n另一个角度也可以说，让角色们做出不同的选择，不光是为了标记各个宇宙让观众不至于晕菜，事实上，每一个选择都创造了新的平行宇宙，是剧情向前推进的重要节点。\n\n进一步想，其实除了前面那些很明显的选择，还有许多暗含的选择比如去不去贴那个留言，Mike去不去给自己留威胁信，要不要去把另一个自己揍一顿，等等。再比如一开始，停电之后要不要出去看，这是一个很重要的选择。很显然，女主最后进入的那个“幸福”的平行世界里，他们没有选择出去看，可以注意到那个世界里Hugh的头上没有创可贴。\n\n所以，如果我们画出一幅平行世界的“进化树”的话，第一个很大的早期节点就是“要不要出去看”。选择不出去看的那个平行宇宙是一大分支，之后一切太平，没有因为选择产生新的分叉; 而选择了出去看的平行宇宙是另一个大分支，在其上又因为荧光棒、创可贴、骰子和随机物品的各种选择迅速地产生大量的分叉。\n\n甚至可以猜测，那个“幸福”的平行世界是早在女主选择是否要放弃那个替补席位的时候就已经分裂出去的平行宇宙。这个宇宙早就分裂了，比那个晚上才产生的诸多宇宙“辈份”高得多。\n\n而这颗彗星的作用，就是让这些本应该在非常短的时间里就退相干的平行宇宙保持长时间的相干状态。相干的表现，就是不同平行宇宙中的人可以看到、进入并且最终互相影响彼此的历史进程。\n\n这颗彗星能把宏观世界的相干态保持那么长时间，研究量子计算的人肯定很感兴趣。\n\n————————————————————————\n\n3. 各个平行世界之间的时间差与因果链。\n\n有人也许会说，只有在别的宇宙里面掷完骰子把东西放进箱子以后才可能让Amir捡回那个箱子来啊。也就是说有的宇宙比别的宇宙时间进程快的多，那么到底是哪一家掷的骰子制造了平行宇宙呢？\n\n我的答案是每一家都创造了平行宇宙，每一家也都是被别人创造的。平行世界之间存在时间差，并不能推翻之前所说“选择产生平行宇宙”的假设。\n\n平行宇宙存在时间差应该是很自然的结果。比如一个宇宙里你选择了走路去约会，另一个宇宙里你选择开车。结果走路比较快，准时到达，开车的宇宙里你被堵了半天，迟到了。于是，两个宇宙里你们见面的时间不同，见面以后再做下一个选择的时间和之后的进程（比如女朋友是否同意跟你啪啪啪）当然也就不同了。\n\n前面说了，因为coherence，那个晚上，不同平行宇宙中的人互相影响了彼此的历史进程。再细想下去，正是因为它们互相影响，才会导致里面的人去作出选择，而这些选择又是产生其他平行宇宙的原因。于是我们陷入了这么一个因果关系的怪圈：\n\n作出选择——产生平行宇宙——平行宇宙互相影响——作出选择——产生平行宇宙——平行宇宙互相影响——……\n\n而且，这个怪圈的存在形式不是简单地一个圈，而是在几百万个平行宇宙之间互相交织、错综复杂的网状结构。\n\n更有意思的是，正是因为他们对确定性的追求，造成了更大的不确定性：\n\n那么多平行宇宙造成困扰——想到掷骰子确定自己——掷骰子创造了更多的平行宇宙——有那么多的平行宇宙让他们感到困扰——想到用掷骰子来区别自己……\n\n所以，当你投身其中，事件的先后是永远理不清的，这些平行宇宙共享一段互相交错而又自洽的历史。平行宇宙之间不仅不分彼此，而且不分先后。在这个自洽历史包含着的所有宇宙里，这八个人都会去做那几件关键的事——必然会扔骰子，Amir必然会去拍那张照片，必然会去选某种颜色的荧光棒……这些“关键事件”在哪个宇宙里发生在先，哪个宇宙里发生在后，根本不重要。这些平行宇宙是自己的因，也是自己的果。如果在某一个宇宙中他们不去做这些选择中的某一项，那么这个宇宙就会脱离这个自洽历史，而剩下的所有宇宙的历史自洽性依然不受影响。\n\n所以，里面有一个角色说的话很好：我们总觉得另一个平行世界里的我们是\"dark version\", 但是, “What if we are the dark version?”这句话显然是编剧想要把主题提升到人性的层面，但也说明一点：影片的拍摄必然要选取某个平行世界做为主视角，而我们要记住所有的平行世界都是平权的。既然这些平行宇宙在空间上通过那一块黑暗地带交织在了一起，那么它们的时间线互相纠缠，都不再保持独立和线性，也就是一件很自然的事情了。","tags":["个人分享"],"categories":["影评"]},{"title":"寂静岭-影评","url":"/2017/12/2017.12.04 寂静岭-影评.html","content":"**{{title}}**   <Excerpt in index | 首页摘要>\n\n看完电影寂静岭之后想自己写一篇影评但是由于自己腹中实在没有什么干货，写不出来~~~（还是得多看书啊）\n从网上看到了一篇讲解的非常全面的影评，看了这个影评才感觉电影中的好多东西都没有理解到位~转载到自己的博客上，以后想回看方便一些~\n\n转载自--豆瓣 [原文地址](http://blog.sina.com.cn/s/blog_6707d64e0100h50g.html)\n\n本文从2006年底笔者看过该片到完成该文，共看过该电影三次，构思并创作全文大约用了半年的时间。\n现作者本人将原文全部发于豆瓣，特此说明。\n\n2006年4月，由曾经指导过电影《狼族盟约》的法国著名导演克里斯多夫·甘斯（Christophe Gans)制作的恐怖电影《寂静岭》（英文名《Silent Hill》,中国台湾译为《沉默之丘》），在上映三天内就突破了2000万美元大关。作为同样是由同名计算机游戏改编的电影，《寂静岭》一雪《生化危机》和《古墓丽影》等影片的前耻，受到游戏玩家的一致好评，《寂静岭》也由此成为了电影界和以游戏改编的电影中里程碑式的作品。\n\n尽管《寂静岭》获得了巨大的成功，但是仍有对其批评的声音。例如就有新闻认为《寂静岭》是一部“恶评如潮”但却票房高的影片（听起来怎么像在评价某些中国“大片”？），还有影评人称“看不懂”《寂静岭》，更有人想象力颇为丰富地将《寂静岭》与《无极》相比并认为其是一路货色。其实在文化全球化和后现代的今天，出现让每个人都拍手叫好的电影几乎是不可能的，何况还有那么多别有用心哗众取宠的人和不明就里盲从潮流的大众。《生化危机》和《古墓丽影》仅就电影本身来说，我个人认为并非“烂片”。而之所以它们被大加诛伐，就是因为与原游戏脱节严重，批评它们的人也多以游戏玩家为主。《寂静岭》之所以被玩家看好，就是因为它很真实地还原了同名游戏中推理解谜的特点和血腥、肮脏、恐怖、压抑的环境气氛。何况无论是电影还是游戏，《寂静岭》都绝对不是一个简单的、为渲染恐怖而生的“鬼域”或“血腥美学”，它是一个充满深刻人文内涵的地方，包括宗教、道德、哲学、性等多种元素和象征、隐喻、暗示等多种手法。因而对于没有玩过《寂静岭》这部系列游戏（截止拍电影时已有四部《寂静岭》游戏，现已出第五部）的人或者对这些不了解的人来说，“看不懂”实属正常。\n既然有人说“有一千个观众就有一千个哈姆雷特，所以有一千个观众就有一千个寂静岭”，那么现在就让我们回到寂静岭：\n\n寂静岭的世界观：“三元论”、“二元论”与“二元主义”\n看过《寂静岭》的人可能都应该感受到电影中不止存在着一个空间。对于寂静岭究竟有几个空间的问题，普遍存在“已死论”、“二元论”和“三元论”三种观点。持“已死论”（也就是认为寂静岭就是“阴间”，进入寂静岭中的人实际已在片头车祸中死亡）的观众可能是“没看懂”电影或者受到一句被错误翻译的台词字幕——“你们都已经死了”（实际应为“你们都已经被诅咒了”）的误导。“三元论”则是广受支持的一种观点，更有文章用“黄澄澄”、“灰蒙蒙”、“黑漆漆”三个词简明而传神地概括了寂静岭的三个世界。但是我认为，虽然寂静岭存在三个世界，但是“三元论”这个说法却是不准确的。\n首先可以区分一下寂静岭的三个世界都是什么：\n1.真实世界：就是真实的世界，在这个世界中的寂静岭就是一个被废弃的小镇，即“黄澄澄”的世界，这是由于电影中多数表现真实的白天都采用了一种温暖阳光的色调。\n2.“表世界”：即“灰蒙蒙”的世界，就是女主人公罗丝（Rose）在车祸醒来后发现自己身处的世界，仿佛冬天的样子，实际上是由恶魔化之后的阿莱莎（Alessa)用邪恶的力量营造的世界，将一切“罪有应得”的人困在了里面。\n3.“里世界”：即“黑漆漆”的世界，就是表世界响过警报之后不定期转化后的世界，一派血腥、肮脏的景象并有各种怪物出没，实际是阿莱莎内心痛苦和压抑的反映并由其邪恶的力量和仇恨的情绪控制。表世界和里世界都是从《寂静岭》游戏中借鉴来的概念。\n存在三个世界这一点似乎没有问题了。但经过分析之后，我们会发现，如果从“次元对立”的角度看，那么只有两个对立的空间。在这之前，要看一个概念：二元主义。\n“二元主义”（Dualism)在哲学中作为一种思想通常指承认两种根本的，不可再分且互异的元素，它们彼此冲突或者相互补充，又分为将这两种基本要素应用于认识活动中的“认识论意义上的二元主义”和用于解释一切广义上的客观现象的“形而上学意义上的二元主义”。“二元主义”本身也是西方历史文化自我否定式的发展规律自近代以来的产物，是对中世纪基督教唯灵主义的否定。\n寂静岭的世界本身就存在表里世界的二元对立，这样以来加上真实世界，似乎“三元论”是成立了。但是对立的表里世界二者却不能同时与真实世界构成对立。因为寂静岭的世界要么是表世界要么是里世界，二者相互转化不能并存，所以导致要么是真实世界与表世界共同存在且对立，要么是真实世界与里世界共同存在且对立，无法存在真实世界、表世界、里世界同时存在并且对立的情况。需要说明的是，在里世界中的教堂只是由于信仰的原因使怪物无法进入而已，它并不具备表世界的特征，因而不是表世界，只能算里世界中的一个特殊地点；而阿莱莎所在医院的地下室也只是表世界里的一个特殊地点而已，还不能因为医院地下室有怪物和黑漆一片就认为那是里世界，因为表世界也有怪物，而地下室没有光自然是一片黑；而游戏《寂静岭》中表里世界的创造、形成原因与电影中不同，也不能作为解释电影《寂静岭》的依据。所以可以得出结论，寂静岭确实存在三个世界，但是从“对立”的角度看，只有二元对立。因而《寂静岭》中的世界观是存在三个世界的“二元论”，或者也可以认为实际只存在两个世界：真实的世界和变化着的寂静岭的世界。作为西方带有宗教题材的恐怖片，《寂静岭》也没有脱离二元主义的规律。\n其实片中的这种二元对立在电影一开始就已经暗示了，那就是罗丝的女儿莎仁（Sharon)梦游时险些摔下悬崖的镜头，构成了上下的对立，水上和水下的对立，真实世界与虚幻世界的对立，善良的莎仁与阿莱莎的邪恶面的对立，甚至原来是水下世界却存在幻境中的烈火这样水与火的对立。当阿莱莎的邪恶面从悬崖上高速下坠的镜头出现时，我承认确实被吓到了，虽然据说这个停留的镜头只持续了0.7秒，但是那恐怖的笑容着实让人一震，真很难想象到可爱的阿莱莎的形象与这个恐怖的邪恶的阿莱莎是同一个小演员出演的！实在不得不佩服她的演技！\n\n三个阿莱莎：\n影片中就“小女孩”的角色问题，可能有人梳理不清阿莱莎、莎仁等人物的关系，参照一些公认的定论，我们可以明确有三个不同形式的“阿莱莎”存在。\n1.阿莱莎：即在三十多年前被施以火刑的小女孩，也是后来在教堂进行屠杀的“终极怪物”，从她后来的身形可以的知她一直处于生长中。\n2.阿莱莎的邪恶面：即引发罗丝车祸的人影，后来一直引导罗丝追踪、解谜，以燃烧的形式消失并在医院地下室与罗丝融为一体的小女孩，以一身阿莱莎当年穿的蓝紫色校服出现。她就是阿莱莎被严重烧伤后，在医院极度的恐惧和仇恨所产生的邪恶力量形象的具体化，她使阿莱莎拥有了恶魔的力量。\n3.阿莱莎的善良面：即罗丝的女儿莎仁，由阿莱莎以分娩的形式产出，并由阿莱莎的邪恶面送出到真实世界的修道院，后由罗丝领养（由此得知阿莱莎的邪恶面有自由穿行于三个世界之间的能力）。有人根据阿莱莎曾被强奸过这一情节认为莎仁是阿莱莎的亲生女儿，这根本就是缺乏基本生活逻辑：以当时阿莱莎的年龄不可能有生育能力，另外以莎仁的年龄看，阿莱莎不可能怀孕二十年再生孩子，而莎仁一再梦游想回寂静岭就是受到神秘力量的召唤，回去与阿莱莎的邪恶面“结合”。\n\n《寂静岭》中的人文内涵\n《寂静岭》的人文内涵很大一部分来源于宗教元素的存在。就在片头罗丝发疯般寻找莎仁并最后与赶来的丈夫抱在一起时，画面背景就出现了一个亮着灯的十字架，为什么那边不出来一些别的东西呢？比如亮着灯的摩天轮？亮着灯的建筑？因为这本来就是一个暗示，告诉你本片涉及的宗教题材。而罗丝带莎仁去寂静岭的路上出现的一块牌子，镜头特地在上面停留，上面的内容是，“Do you not know that we will judge angels?Do you not konw that the saints will judge the world？（岂不知我们要审判天使么？岂不知教徒要审判世界么？）”这些句子本来就是《圣经·哥林多前书》中的内容，原文是“Do you not know that the saints will judge the world? And if you are to judge the world, are you not competent to judge trivial cases?Do you not know that we will judge angels? How much more the things of this life!（岂不知教徒要审判世界么？若世界为你们所审，难道你们不配审判这最小的事么？岂不知我们要审判天使么？何况今生的事呢？）”这就是在预示她们此去寂静岭的前景，被一群自宗教偏执狂“审判”，但是最终却是在暗示整个影片的结尾，就是魔鬼对教徒进行的审判，那些为恶而自认为正义的人，最终会被上帝抛弃——别告诉我你没有注意到牌子的外形就是一本书，别告诉我你看见那书的外形没有想到那是《圣经》！还有罗丝在寂静岭学校时候，门框上文字的一个镜头：“The foes of the righteous will be condemned.”这是《圣经·诗篇》中的内容，原文为：“Evil will slay the wicked；the foes of the righteous will be condemned（恶必害死恶人；恨恶义人的，必被定罪）。”已经不用多说了，那些自以为信仰上帝的人的命运，被定罪审判，已经再一次提前告知观众了。\n从电影中我们可以得知，寂静岭是1974年11月因为地下煤矿的火灾而被废弃的小镇，至今地下的锅炉和矿脉还在燃烧着熊熊大火，因而寂静岭的空气中飘浮着致命的污染物。这一点在真实世界中表现的不明显。而在表世界则表现为似乎是不断落下来的“雪”，后来罗丝发现其实那是飘落的“煤灰”。而《圣经》中的《圣约翰启示录》是怎样描写“地狱”的呢？“它是一个永久的火湖，它的空气来自祸害的煤炭，光来自闪烁的火焰。夜晚一片漆黑，被诅咒之人的处所毒蛇横行。他们的希望是绝望。啊，永生之死！无生之生！啊，无尽的痛苦！”《圣经·福音书》中耶稣对地狱的描绘中也有“火是不灭的”字样。\n里世界那些残破的墙壁，锈迹斑斑的管道和门，铁制的楼梯，转动的风扇，不知从何处产生的铿锵作响的金属撞击声和烟雾或蒸汽，似乎只存在铁黑和火红这两种颜色的压抑环境，正是大机器生产的工业时代的再现！这都是电影在以后工业时代的艺术风格对没落的工业时代以一种末世的悲凉形象进行的渲染。\n对于《寂静岭》来说，后工业时代的艺术风格只是它的表象，《圣经》中的宗教隐喻才是它的实质。在里世界被开启之后，教堂中的教徒们祈祷所要阻止的也正是《圣经》中的“末日审判”，或电影中所谓的“天启”的到来。\n《寂静岭》中的怪物也是一大看点。它们的外形和特征等都是严重烧伤的阿莱莎恐惧、痛苦、仇恨、愤怒心理的形象具体化之后的表现。无论电影中还是游戏中，这些怪物都不是仅为了引起恐怖的视觉效果而往“怎么丑陋怎么设计”出来的产物，宗教内涵与性暗示足以使这些怪物受到弗洛伊德信徒们的鼎礼膜拜！\n罗丝进入里世界后首先看到的第一个恐怖景象就是一张铁床上的物体，具体是什么我看了好几次也没看出来，据说是一个死得很惨的人，这是对游戏场景的一个还原。罗丝后来发现铁丝网墙上挂着的是一个穿着“防护服”的教徒（人还活着）。如果我没有看错，他已经断了一只手，而且他就是以十字架的形式挂在那里（又是一个宗教暗示）。接下来冒出的那些还处于半燃烧残骸状态的怪物，就从它们的形体大小和发出类似孩童的嘶叫声音的角度看，其实它们就是当年在学校欺负阿莱莎的同学，这些孩子在被阿莱莎拥有的邪恶力量引发的火灾烧成焦炭以后，就以这种怪物的恐怖方式存在于里世界中。\n第二个出场的怪物被游戏玩家称为“紧身衣”，也是电影中表世界出现的唯一怪物。从它被女警察西比尔用枪击毙时喷出的红血基本可以推测出那是一个被困在自己皮肤里的人。据说在拍摄这个怪物时也是用真人穿上无臂的紧身衣然后再用电脑合成的。这个怪物是游戏《寂静岭2》中男主角长年自我束缚在生病妻子身边痛苦心理的写照，搬到这里一样也可以有合理的解释。因为阿莱莎受到火刑时也被强制束缚。其实在这里我们可否认为“紧身衣”也具有某种性暗示的意义？阿莱莎被强奸这是片中的事实，而这个无臂的怪物光溜的躯体本身就像一个可以来回行走的男性生殖器。这个怪物就是阿莱莎被强奸时恐惧和痛苦心态的形象具体化。而怪物本身可以喷射出带有强腐蚀性的液体可否被看作是还不谙世事的阿莱莎对男人精液的恐惧印象？后来这个极具性暗示外形的怪物确实喷出了这些液体，而且是向女性喷射的，别告诉我你看不出这里的意思... ...\n从厕所中爬出来的怪物，就是当年阿莱莎被同学欺负躲进厕所后强奸了她的清洁工，电影中两次用身份牌上的名字柯林（Colin）暗示出他与怪物的关系。这个怪物被以扭曲的形式用铁丝网捆绑，应该是阿莱莎以被强奸时的心理对其的报复。而怪物的眼睛被铁丝网蒙住则是阿莱莎对柯林强奸时看了她身体的惩罚。只有怪物身上的输液瓶让人觉得奇怪，也可能是对游戏细节的尊重。怪物爬行时手臂所及之处会产生藤蔓般的血管并伴有毒泡产生，它不断“吐舌头”的动作则是性暗示的标志，而按照它那样两腿被高高吊起地爬行方式，每爬动一次，生殖器就会被严重摩擦，让它经受如此的痛苦也是阿莱莎对他的报复。\n在罗丝于里世界的镜头中，出现很多笼子中倒挂的成年男性的尸体。为什么都是成年男人，我只能用阿莱莎本身是私生女、从小没有父亲所以很少接触男人，后来又被男人强奸而导致她对男性产生了极不信任感和仇视来解释了。随着罗丝下楼梯的镜头我发现其中一具男尸是没有生殖器的（被割去了？），或许这也就是因为上述原因导致阿莱莎对男人的报复。也是因为这种不信任和仇视也是阿莱莎没有将罗丝的丈夫拉入寂静岭世界的原因。而那些被倒挂的尸体，其实在《圣经》中的《彼得启示录》中就有很容易找到的答案。那里描写的地狱里被惩罚的人以不同罪恶的原因被施以不同的刑罚，但是被“吊起来”或“倒挂”却是很共同的一种。其实寂静岭的里世界就是“地狱”！\n之后，多灾多难的罗丝遇上了一大群圣甲虫或被称为“人面虫”的怪物。三个来不及逃跑的教徒被虫子吃掉，看来他们身上看似结实厚实的防护服也不怎么样，顶多应该能抵挡下表世界“紧身衣”怪物喷出的毒液。关于这些虫子的来历，有人认为是阿莱莎重伤时被甲虫咬过或感觉身上像被甲虫咬的感觉幻化出的，其实这些都是没有任何根据的，至少电影中没有这些情节。认为虫子是阿莱莎以前同学的说法也似乎有些牵强，而且我没有怎么看出甲虫的脸怎么像人脸。其实这些虫子就是圣甲虫，古埃及神话中被认为是太阳神科何普拉的化身（当然，古埃及神话中太阳神不止他一个），原因是古埃及人看见这些乌黑的甲虫反射的阳光就认为它们是太阳神的化身。有人认为这些虫子是尸虫而不是圣甲虫，其实这点并不矛盾，因为古埃及人确实将这种被认为能避免尸体受到恶灵侵害的虫子倒入棺材。圣甲虫在古埃及神话中的另一意义就是“复活”，在电影中它们它们代表了经受火刑之后几乎死掉的阿莱莎“复活”时产生的仇恨。或者也可以揣摩一下这些虫子的宗教隐喻，《圣经·福音书》中耶稣对地狱的描述中就提到了地狱中“虫是不死的”（圣甲虫可以随着寂静岭表里世界的转换而复生），而《圣经》中《彼得启示录》更写到了迫害正义之士的人要“站在火焰中”，“受到不死之虫的吞噬”，而谋杀犯和帮凶则“被扔进满是恶毒害虫的狭小之地，他们受到那些生物的折磨，不停痛苦地扭动着。黑云一般的害虫向他们频频袭来。被谋杀之人的灵魂在一旁站立，目睹自己仇人受罚，并对他们说道，主啊，你的惩罚公正无比。”以上内容有没有让人想起那三个教徒被圣甲虫吃掉时候的场面？这些人里哪个当时不是想烧死阿莱莎的谋杀犯，哪个不是女教主克蕾丝（Ghristabella）的帮凶呢？\n接下来出场的就是极具视觉冲击力的“大铁头”怪物了。这个在游戏《寂静岭2》中代表南主角自身的暴力倾向和对罪孽的自我审判的象征，据说其典型的特征“三角铁头”来源于寂静岭历史上美国南北战争时期一座监狱中的刽子手形象。在电影中，这个拖着沉重步伐游走于里世界并且见人就杀的怪物也着实让人感到恐怖和震撼。其极具男性特征的粗壮躯体正表达了阿莱莎复仇的渴望，之所以阿莱莎会被同学欺负、被强奸、被施以火刑而无法反抗，就是以为内她是一个弱小的女孩，而如此强悍的外形则正好符合阿莱莎复仇的条件。有人曾对电影里三角头的武器由游戏中极具性暗示作用的长矛换成大刀而感到遗憾，但是我觉得这大可不必，因为根据弗洛伊德的理论，不仅是长矛，一切长形、凸起、竖起、坚硬有穿刺力的物体，尤其是武器本身都是极具性暗示的。当罗丝和女警察西比尔（Cybil）在小屋的铁门后面躲避铁头怪物的剧情里，当铁头怪物用极具性暗示作用的大刀“刺破”关着两个“女性”的铁门，并将已经“进入”铁门的大刀来回“搅动”时，这里的“大刀”、“小屋”、“铁门”、大铁头伸进来的“手”和“门闩”，甚至被放进来的几只圣甲虫本身就带上了弗洛伊德性暗示的暧昧色彩。再联想到大铁头在教堂门前因为安娜（Anna）曾经向阿莱莎的生母扔石头而石头而将安娜撕成两半的情节里，你说铁头怪物你要撕就撕好了，为什么还要把安娜衣服扒光了再撕呢？大铁头扒人家衣服时干净利落地简直有几分强奸的神韵，这是否是阿莱莎对自己被强奸的报复呢？弗洛伊德又在微笑了... ...\n就那把大刀看，似乎《圣经》也要来分一杯羹。《圣约翰启示录》中写到末日审判中，羔羊（本指耶稣，在电影中能否是对柔弱的阿莱莎的暗喻？）揭开七印，倾斜出愤怒（此处与电影一致），放出四个人，第一个被赐予“冠冕”（铁制三角吗？），第二个被赐予大刀... ...看来这下，上帝要与弗洛伊德一起微笑了。\n那群护士怪物，本来也是游戏《寂静岭2》中男主角长期性压抑的产物或者《寂静岭1》中阿莱莎对医院的反感的产物，在电影中就只能解释为阿莱莎得到邪恶力量时由于极度愤怒而将身边的人都杀死并变成怪物，从片中也可以得知当年寂静岭的大火也确实烧死了一些无辜的人。那个没有眼睛的红衣护士是因为好奇而看了重伤之后阿莱莎后被阿莱莎挖去了眼睛并一直照顾阿莱莎的生活。护士怪物们用利器相互切杀并不是自相残杀，而是感觉到身边有人但却因为无光（片中说到它们只对光有反应）的反应而已，而这些护士怪物走路时的动作被誉为“痉挛芭蕾”，据说她们都是由艳舞女郎和爵士舞蹈家扮演。\n在教堂最后那场稍显“华丽”的屠杀中，被罗丝（或者说阿莱莎的邪恶面）的血腐蚀的教堂地板上，真正的阿莱莎从满是暗红色烈火和钢铁设备的地下出现了。她在杀死克蕾丝教主的时候，很明显可以看见，最早刺进其身体的铁丝网是从裙子下面伸入直接刺进下体的，这又是一个明显的性暗示。从克蕾丝那身蓝紫色的衣着与阿莱莎就读学校学生校服的颜色一致我们可以得知克蕾丝有可能是那所学校的老师，如果要宣传一种宗教，那么从孩子抓起完全是可能的，何况在西方并不是没有教会学校。那么也就是说孩子们认为阿莱莎是女巫除了有片中提到“父母的灌输”以外，很有可能有克蕾丝老师的教唆和命令。其中克蕾丝找阿莱莎的生母谈话时曾关门推走了几个好奇的学生，由此得知她们谈话的地点就是学校，能在学校召见家长的，除了老师还有谁呢？而正是因为学生们被克蕾丝唆使欺负阿莱莎，她才会躲进厕所而遭强奸，因而完全可以得知阿莱莎这样杀死克蕾丝是对其行为导致自己遭到强奸的报复。最后，阿莱莎将克蕾丝一分为二，正是让其知道阿莱莎受火刑而痛苦地分裂为一个善良体和一个邪恶体的感受，所谓以其人之道还其人之身，而教堂这场屠杀正是犹太教末世论和条顿化基督教对最后审判日观念的体现，或许走进寂静岭就是打开了《圣经》。\n其实片中众多的性暗示除了可以从阿莱莎的经历解释外，也可以从影片导演的话看出一些内容——“我喜欢女人，喜欢和美国婊子做爱。我想拍一部到处都是性感女人的电影，没一个男人。我不想处理和男人有关的东西。”只是可怜了这些女演员们一次又一次成为了导演们“意淫”的对象。\n\n对于《寂静岭》中杂项的解释试探：\n1.寂静岭中的真实世界与表世界，真实世界与里世界都可以以一定方式联系，此处可以从罗丝给丈夫的电话，女警察发给总部的求救，丈夫闻到罗丝的香水味得知。\n2.阿莱莎是通过自己邪恶面造成的车祸的方式，用神秘的力量将罗丝和女警察拉进寂静岭表世界空间里的，这可以从很多相关资料中得到证明。女警察很有可能是阿莱莎故意拉进寂静岭以用来保护罗丝完成任务的。女警察跟踪母女俩的原因是女警察曾去寂静岭调查过一个杀人狂将一男孩塞进煤矿通风管道的案件，进而对想去被废弃小镇的大人加小孩的组合加以怀疑。对于有资料认为曾有克蕾丝身边一个塑料女模特是暗指女警察这点不予支持，我认为之所以有这种想法是因为女警察头发短而塑料人正好没头发导致看起来相似而已，而且到不如说那塑料是在暗指克蕾丝自己，被控制在寂静岭而又不自知的“傀儡”。\n3.注意女警察的名字，西比尔，英文为“Cybil”，乍看来就是一个普通的英文名字而已。但是英文中“女巫”一词，除了常用的“witch”以外，还有两个词，分别是“sybil”和“sibyl”，为女巫、女算命师和女预言师的意思。有没有发现，其实这两个词中第一个词与女警察的名字“Cybil”只相差了一个首字母而且它们的发音是一致的？有没有发现第二个词“sibyl”仅仅是把第一个词“sybil”中间的两个字母“y”和“i”调换了一下位置，而且它的发音也与“Cybil”一致呢？也就是说，女警察的名字本身就是“女巫”或者说被设定为“女巫”的谐音，这又是一个暗示，暗示女警察Cybil被烧死（与女巫被处死的方式一致）的结果。\n4.真实世界转换与表世界怪物出现时会造成收音机、手机等电子产品噪音这点是对游戏的还原，无科学解释。\n5.里世界经常出现的风扇的喻义：一个是工业生产本身必须的通风设备，也是后工业艺术风格的元素，也是里世界压抑的工业运行声音的来源，也是对里世界就是“绞肉机”的暗示，而且也有宗教观点认为地狱的运行就是“铁轮”来回转动的原因。\n6.教徒们用来对表里世界转换的报警工具是笼子里的鸟，这也是今天用于监测煤矿一氧化碳含量的工具。\n7.片中寂静岭的世界周围都是悬崖，这也是被困在这个空间里的人跑不出去的原因。即使能跑出去，另外的地方也是表世界也是表世界的延伸，会转成里世界，所以不如老老实实呆在教堂里避难。\n8.不支持片头NATHAN旅馆下的“DRUGS”（药的意思，也指毒品）是对小镇贩毒的暗示。这是游戏里的情节，电影中没有交代。这最多就是对游戏的还原，如果是暗示也只能是暗示教徒们对他们宗教的信仰如吸毒一般。\n9.片中出现的男警察就是当年在寂静岭从火刑架上救下阿莱莎的男警察，因为是好人，所以没有被阿莱莎困在寂静岭世界的空间里。\n10.罗丝拿到画的信箱号是111，后来在旅馆中找到火刑画后面的房间（就是当年阿莱莎受火刑的房间）也是111，一处明显的暗示。\n11.女警察护送罗丝下电梯时与几个穿防护服的教徒发生打斗，她曾经将一人隔着防护服打得头部直接喷血，这样的人还能再爬起来对女警察进行殴打，我觉得施瓦辛格也不行！坚定为硬伤！\n12.不清楚这点应该如何解释：片中已经告知，阿莱莎拥有邪恶力量引发的大火使寂静岭废弃是在1974年，罗丝来寂静岭已经是2006年，中间已经有32年时间。但是从片中克蕾丝前后32年的模样我们可以发现她几乎没有什么变化，也就是说有可能被困在寂静岭的人已经停止生长了，因为从寂静岭表世界建筑的破旧可以得知如果不是有年头的话是不会出现这种情况的。而且认为安娜就是阿莱莎以前同学的说法也是不可能的，因为她怎么看也就二十多岁，绝对不像三十多岁或者四十多岁的人，1974年可能她还没有出生呢。而阿莱莎只可能把迫害过她的教徒拉进她的空间，因此看来教徒从1974年以来就停止生长是正确的，而奇怪的是最后屠杀时的阿莱莎本体却已经是成年人的体形了，可以可见她却是一直生长的。疑问就在于即使人不生长了，但是片中的人还是得出来找食物的，在寂静岭那样的环境中任何种植和食品加工都是不可能的，我们也看到安娜找的都是一些以前寂静岭剩下的食品罐头。但是请注意！什么罐头的保质期能保证32年呢？寂静岭里又有多少罐头能供那么多人维持32年呢？而且寂静岭里的人的水又从哪里来的？自来水厂肯定是一片废墟了，片中说寂静岭边的河也被绝壁隔住了。里世界似乎下雨，但是里世界的雨水能喝吗？即使能喝，能供应这么多人吗？里世界的雨水会不会随着世界的转化一样消失掉？如果说寂静岭的人是被“延缓”而不是被“停止”以解释教徒的年龄的话，那么当年解救过阿莱莎的男警察又怎么解释呢？假设1974年他只有20岁，2006年他也有52岁了，但是片中他最多三十多岁而已，他不在寂静岭的世界怎么年龄也被“延缓”了呢？\n13.罗丝带着阿莱莎开车回家，虽然出了寂静岭，世界也仍是一片灰色，来寂静岭的路上热闹的加油站也空无一人。回到家时，电影用罗丝在灰蒙蒙的寂静岭与丈夫所在的黄澄澄的真实世界的反复交替出现来说明罗丝其实是被永远困在了寂静岭的表世界里。原因很简单，当时的莎仁其实是阿莱莎的邪恶面通过对视与莎仁融为一体之后的人，或者说，莎仁已经不存在了。没有发现回家后的莎仁有一种成人的眼神，并且仿佛从来没有来过自己的家一样，进屋之后有种好奇感？阿莱莎就是因为曾经被自己的生母抛弃给教徒，而从罗丝这里感受到真正母爱，而想把罗丝永远困在寂静岭的世界里以独享母爱！“莎仁”上车之后吸手指的动作就是在使用神秘力量，她吸手指之后，原本不能发动的汽车发动了。有文章认为车是从悬崖上“飞”出去的，我觉得不是，从车经过悬崖的画面明显可以发现原来的绝壁上已经出现了一座桥梁，这也是车上的莎仁吸手指使用神秘力量延伸出来的结果，最后表世界的空间被一直延伸到罗丝的家。我认为，劫难之后的罗丝其实已经知道自己的女儿不是原来的莎仁了，也知道自己将永远被困在寂静岭的表世界，否则她怎么就上去去试图开动这辆之前已经开过但却无效的车呢？罗丝原本也知道寂静岭四周是无路可走的虚悬，怎么就敢开车往外走呢？原因就是她知道“莎仁”或者说阿莱莎不会让车掉进悬崖而一定会让自己开车出寂静岭。世界仍是一片灰色和加油站的空落罗丝不可能没有察觉，最后她进屋后直愣地望着沙发，就是她感觉到了自己丈夫的存在，但却也知道这种“两个空间”的存在是咫尺天涯了。其实者这一切都是阿莱莎安排好的，她将自己的善良面莎仁送出寂静岭险恶的地方被人收养，长大到自己受火刑的年龄再招回寂静岭，复仇并完成合体，然后独享母爱。\n\n寂静岭所要表达的主题：\n1.母爱：体现在罗丝面对如此艰险的环境还义无返顾地寻找女儿，阿莱莎的生母无论在里世界还是在最后审判中都安然无恙。女警察一句“在孩子的眼中，母亲就是上帝”和罗丝对其的引用，以及女警察被烧死时也喊母亲、都揭示了这一点。\n2.后工业时代：一如美国甚至世界各国在后工业时代没落的工业城市，寂静岭也象征一个时代的终结。\n3.宗教反思：阿莱莎是因为私生女所以才被当地的“邪教”组织所不容，类似的还有旧中国某些某些地区女人未婚先孕就要被淹死的陋习。美国本身是一个新教国家，而中世纪天主教在欧洲烧死的“女巫”则不计其数，无数无辜的人被以各种名义施以火刑处死，沦为宗教狂热和愚昧的牺牲品。最荒谬的更有1474年巴塞尔城曾因为一只公鸡下蛋（公鸡中的战斗机？）被视为“女巫”而烧死！美国本身在成立之前也有从欧洲大陆来的各种教派，导致今天美国各种名目繁多的宗教组织。在美国建国前的混乱状态，各教派都认为对方是“异端”，结果就是更多人因为“异端”或“女巫”被推上火刑架。所以《寂静岭》不仅是基督教新教对天主教的反思，也是美国新教本身对自己的反思，一如阿莱莎生母说：“我们的信仰是我们的掘墓人。”\n4.对善恶的思考：电影中借男警察之口道出“魔鬼也有自己的正义”，如果正义用邪恶的手段摧毁邪恶，那么它究竟是正义还是邪恶？究竟什么是善和恶？是否存在一个绝对的标准？\n5.赎罪/审判之地：这本来是游戏《寂静岭2》所要表达的主题，在这里同样适用。寂静岭其实就是每个人心中的道德底线，是每个人最后都要受到的自我拷问。那些做了坏事的人最终都要被最后审判，赎罪的方式就是接受审判，就像电影中那些教徒，那些为恶又自我开脱而不自知的人，早晚都要受到魔鬼的最后审判！\n寂静岭是一个恐怖、压抑而又充满魅力的地方，我不知道为什么我给文章标题鬼使神差地写上了“带我回到寂静岭”，仿佛我曾经去过，或许那里对人的内心有种神秘的感召力。李安导演在奥斯卡获奖时曾经说人人心中都有一座断臂山，如果真是这样的话，那么我认为每个人心中也有一座寂静岭，那是每个人心中的自我审判，是每个人最后都要回到的地方..","tags":["个人分享"],"categories":["影评"]},{"title":"狩猎-影评","url":"/2017/12/2017.12.04 狩猎-影评.html","content":"**{{title}}**   <Excerpt in index | 首页摘要>\n好几天没更博了，想着总要写点儿什么，锻炼一下我的写作能力，嘿嘿嘿~\n不得不说的是，这几天我过的很爽哈，一下看了好几天的电影，都是名气很高的电影，看完电影之后就想着写一下影评抒发一下我的看法~不过自己的文笔不太好，所以就转载一篇吧~\n\n看完了《狩猎》，这是一部丹麦的电影；导演托马斯·温特伯格，曾是丹麦电影学院有史以来最年轻的入学学生，而且表现出色。\n\n影片最让我动容的是对人性的刻画。好了，就让我转载一个我所认同的影评吧~ [原文地址](https://movie.douban.com/review/5818670/)\n\n一部寒冷彻骨的电影。不温不火的叙事和冷静理智镜头之中酝酿了近乎绝望的压抑、狂躁与寒冷，这部丹麦电影就像北欧的冬天一样寒冷，在颤栗中毫不留情的在人性与社会道德划上深入骨头的一刀。\n\n\n这部电影的观影过程绝对不是一个愉快的过程，片中酝酿的一种冷而近乎绝望的氛围让整部电影张力饱满，郁结到近乎暴戾的怨气充斥胸腔，让人意志中的理智与情感大乱阵脚，剧情爆炸式的张力让整部电影的氛围处在一种极其微妙、一触即发的精确位置，而这种微妙张力来源于人内心之间的斗争。所谓三人成虎，但这部电影不仅仅是一个三人成虎的故事，儿童在影片中游离于天使与恶魔之间的设置，让这个三人成虎的故事变得更加深刻和让人不寒而栗，西方国家对儿童的保护和重视也在此片中可见一斑，孩子的话往往是纯真而无意的，但是这种无意的“孩子话”要是沾上社会道德禁区，并被误解，那纯真便可以变成剧毒的毒药，很遗憾，影片中的主人公就是一个不幸中毒的倒霉蛋，孩子自然可以不为自己的话负责，短浅的人生阅历让他们在社会的地位中一无所有，而对于一个成年人来说，社会中的一席之地近乎可以是他们的全部，当这些被毁灭时，就意味着个人的社会性被抹掉，对于一个有理智成年人来说，这是一种变相的谋杀。片中男主角的反应似乎略显迟钝，自我维护也是到了最后才迸发，可是细心的可以发现，在铺垫段落，男主角与孩子的互动之中，与女朋友的交往之中，我看到了男主角身上隐隐约约的被动性格，这种人，往往木讷而善良。\n\n\n孩子算社会中的特殊的弱势群体，他们在生理和心理上都不成熟，保护自我的能力薄弱，所以一旦发生疑似侵犯儿童的事，社会群体总是会毫无保留的站在孩子的这一端而群起攻之，但是当这种社会性的毫无保留被曲解和误用的时候，孩子就由天使变成了魔鬼，孩子尚未健全的人格和辨识力让社会常规、合理的解决途径在此无路可通，于是他们的话往往带来巨大的破坏性，影片中卢卡斯的生活就被一两句近似胡话的童呓毁灭，但毁灭过程最大的破坏力并不是由孩子直接带来的，而是由社会群体的排斥和异化所带来的，人毕竟还是群居动物，当一个人被孤立和异化的时候，这种隔阂带来的对人的伤害是巨大的，更何况这种排斥和有意的异化是冤屈的，影片的张力便是建立在这种排斥和冤屈的对立上，精准到位的把这种恶毒的人际对立和人物内心的崩塌完美的展现了出来。谣言猛于虎，而当社会伦理禁区的谣言来自天真的孩子，这种破坏力则更加猛烈，影片中，在丑闻和随之而来的各种谣言面前，社会群体之间的对立逐渐变得立体而猛烈，从开始的将信将疑留有余地，到最后近乎整个社会群体的排斥，影片在似乎平静的氛围中酝酿下了更大的恶意，当观众以男主角为第一人称带入故事时，这种慢慢酝酿而来的恶意和仇恨近乎可以演化成反社会的暴戾情绪，一股积郁的愤怒迟迟无法爆炸最终竟成了彻骨的寒意。\n\n\n影片的前半个小时感觉有点云里雾里不知所云，切入过慢，但是一过这个节点，影片便开始展开其爆炸性的张力，导演对镜头的处理平静而理智，就像影片中主人公开始对自己理智的克制一样，但是到了后半段，主人公的理智开始摇晃时，影片的镜头仍然平静如初，这种镜头内的躁动和镜头外的平静理智，让观众产生一种由内及外的愤怒，甚至萌生反社会的暴戾情绪，正是因为镜头冷峻的袖手旁观与故事内的爆炸张力产生的强烈对比，为主人公鸣不平却无可奈何而产生的强烈观影共鸣，带来了极大的带入感和精准的人物塑造。本片的导演托马斯•温特伯格轻松的把观众的情绪玩弄于鼓掌之中，这正是这位丹麦导演的功力所在。这种沉重的社会题材电影往往可以给人带来更多的思考，不论是去年的《爱》还是以往的更多欧洲社会题材电影。影片最让我印象深刻的是在教堂的一幕，男主角非常讽刺来到教堂这个乞求救赎的地方，顶着上帝普世之爱的光环这或许是唯一能让他这个“罪人”和一社区“善人”平静共处一室的地方，当孩子们用天使般的声音开始唱圣诞颂歌时，这种恶与纯真的巨大反差让男主角的理智处于崩溃边缘，但是终究理智还是没有崩溃，这种人社会性的属性永远也抹不去，不然他会去绕过卡拉的爸爸，直接对孩子下手，理智告诉卢卡斯孩子是无辜的，卢卡斯只能找卡拉的爸爸出气，我想这是终究个错误的判断，因为最后的一幕非常明确的说明了，这整个闹剧最大的罪魁祸首，并不是卡拉，也不是卡拉做出错误判断的父亲，而是卢卡斯所处的这整个社会的偏见，影片结尾成人仪式非常值得玩味，猎枪的承接和周遭暧昧不清的笑容让人寒颤，成年意味着力量和责任，而也意味着代价，社会族群可以这样接纳你，给予你一定的位置，也可以迅速的像对卢卡斯那般，残忍的把你除名。电影最后那意味深长的一枪是谁开的其实并不重要，它最大的价值便是打醒那些做梦的人，而背后的开枪者，只是一个模糊的轮廓，导演的意图很明确，这个轮廓是为所有人设计的。\n\n\n“狩猎”这个片名有一定的意味，显然卢卡斯就是社会群体森林中那只被追猎的麋鹿，毫无防备，甚至心怀感激的袒露在黑暗森林之中，无数躲在暗中的猎人可以中伤他，而最后那惊人心魄的一枪，既可以视为恶意的中伤，也可视为善意的警告，但想要表达的暗示都是同一点：走吧，这片森林再也不欢迎你了。这种无意引起的社会群体对个人的排斥，让人看清社会的部分阴暗面貌，深刻见底，暂时不提娈童的恶，说说群体性的排斥，在浩荡历史上，这种多数人对少数人偏见和迫害又能少到哪去？从异教徒到同性恋，从布鲁诺到图灵，这种恶毒的幽灵一直活着，至今伊朗仍对同性恋处予恶毒的石刑，别以为它们离我们很远很远，即使到了今天，它仍然活生生在我们周围匍匐着，无法忽略卡拉作为导火索在事件中起的恶劣作用，但是最可恶的并不是孩子，而是那群虚伪的，带有偏见的，先入为主的，自封卫道士的傲慢大人们，要知道无知并不是文明最大的障碍，傲慢才是。影片的所谓的刻意其实并不过分，这种滑稽天方夜谭似的连锁事件时刻在我们所处的世界上演，如果你细心留意。感谢最后的一枪把我所有的幻想和美好愿景都打了个粉碎。心中郁结已久的戾气最后居然被这突然而来的枪声惊吓冻结成了冰块，一股彻骨的寒意弥漫全身。","tags":["个人分享"],"categories":["影评"]},{"title":"JavaScript之V8引擎","url":"/2017/11/2017.11.25 JavaScript之V8引擎.html","content":"**{{title}}**     <Excerpt in index | 首页摘要>\nV8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用于Google Chrome中。\nV8在执行之前将JavaScript代码编译成机器码让计算机识别执行，而非字节码或者直译它，以此来提升效能，JavaScript程序与V8引擎的速度可以媲美二进制编译。在高性能JavaScript一书中作者有比较V8引擎与其他语言的执行速度，作者列成了图表很清楚的显示出JavaScript引擎V8不俗的执行速度。\n\nV8是Google Chrome浏览器内置的JavaScript脚本引擎。\nGoogle Chrome使用V8的API，但引擎的内核部分是独立于浏览器之外的。\nV8引擎编译和执行JavaScript源代码。\n速度是V8引擎追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码 + 解释器”的引擎，优势不言而喻。\nV8引擎的团队说Chrome对脚本的解析和执行速度是Firefox和Safari的10倍，是IE的56倍。当然了，自夸自家的瓜甜，都是这样的嘛~最近不是新出了Safari又比Google Chrome快了80%的速度吗~但是只是因为Safari更新的比较快，优化了最新的ES6，所以与之前未做优化的Chrome相比快了不少~也是真能吹牛哈~\n\n***\n正是由于V8的高性能，所以基于nodejs开发的引擎就是V8引擎。\n***\n\nV8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。V8的JavaScript渲染引擎亮点在于更快速更强壮的JavaScript解析。V8是一个非常反传统的JavaScript引擎，它能够在后台动态的对JS的对象进行分类——一个在其他高级语言中很常见但JS本身不支持的特性。V8对JS的解析不是基于反复loop源代码进行解释而是直接将JS代码编译成机器码运行。换句话说，V8引擎实际上可以看做是JS的扩展和编译器——而传统上类似于JS的解释型语言恰恰是不需要编译器的。最后，高级语言的内存管理效能一直是决定其运行效率的重要因素，而当前的JS虚拟机在这方面做的比较基本，对内存的回收也非常保守。V8使用的是非常强势的内存管理策略，一切在运行堆栈里无用的数据都会被强行回收，从而可以大大提高JS代码的运行效率。\n在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。\n\n和Mozilla的SpiderMonkey一样，Google Chrome浏览器的JavaScript引擎Google V8也是一个开源的独立引擎，可内嵌于任何C++工程之中。\n\n>速度是V8追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码+解释器”的引擎，优势不言而喻。在SunSpider测试中，V8的综合表现是最好的。据说Mozilla正在开发的TraceMonkey比V8还要快20%左右，可惜尚未完工。\n\n# JavaScript的发展\n>Netscape Navigator 在 90 在年代中期对 JavaScript 进行了集成，这让网页开发人员对 HTML 页面中诸如 form 、frame 和 image 之类的元素的访问变得非常容易。由此 JavaScript 很快成为了用于定制控件和添加动画的工具，到 90 年代后期的时候，大部分的 JavaScript 脚本仅仅完成像“根据用户的鼠标动作把一幅图换成另一幅图”这样简单的功能。\n \n>随着最近 AJAX 技术的兴起，JavaScript 现在已经变成了实现基于 web 的应用程序（例如我们自己的 Gmail）的核心技术。JavaScript 程序从聊聊几行变成数百 KB 的代码。JavaScript 被设计于完成一些特定的任务，虽然 JavaScript 在做这些事情的时候通常都很高效，但是性能已经逐渐成为进一步用 JavaScript 开发复杂的基于 web 的应用程序的瓶颈。\n \n>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。其中的原因在你读过这份文档余下的部分之后就会明白了。\n \n# V8 的性能提升主要来自三个关键部分：\n1. 快速属性访问\n2. 动态机器码生成\n3. 高效的垃圾收集\n\n## 快速属性访问\nJavaScript 是一门动态语言，属性可以在运行时添加到或从对象中删除。这意味着对象的属性经常会发生变化。大部分 JavaScript 引擎都使用一个类似于字典的数据结构来存储对象的属性，这样每次访问对象的属性都需要进行一次动态的字典查找来获取属性在内存中的位置。这种实现方式让 JavaScript 中属性的访问比诸如 Java 和 Smalltalk 这样的语言中的成员变量的访问慢了许多。成员变量在内存中的位置离对象的地址的距离是固定的，这个偏移量由编译器在编译的时候根据对象的类的定义决定下来。因此对成员变量的访问只是一个简单的内存读取或写入的操作，通常只需要一条指令即可。\n \n为了减少 JavaScript 中访问属性所花的时间，V8 采用了和动态查找完全不同的技术来实现属性的访问：动态地为对象创建隐藏类。这并不是什么新的想法，基于原型的编程语言 Self 就用 map 来实现了类似的功能（参见 An Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language Based on Prototypes ）而且JavaScript在创建之初因为是赶时间赶出来的（10天的时间，而且还是Brendan Eich为了应付公司安排的任务的~），所以也正是借鉴了很多语言的长处，也就是上面所说的self语言和C语言等等（有一句话说的好：与其说我爱JavaScript，不如说我恨她；她是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：“她的优秀之处并非原创，她的原创之处并不优秀”）。在 V8 里，当一个新的属性被添加到对象中时，对象所对应的隐藏类会随之改变。\n \n下面我们用一个简单的 JavaScript 函数来加以说明：\n \n`function Point(x, y) {\n    this.x = x;\n    this.y = y;\n}`\n \n当 new Point(x, y) 执行的时候，一个新的 Point 对象会被创建出来。如果这是 Point 对象第一次被创建，V8 会为它初始化一个隐藏类，不妨称作 C0。因为这个对象还没有定义任何属性，所以这个初始类是一个空类。到这个时候为止，对象 Point 的隐藏类是 C0。\n \nmap_trans_a\n执行函数 Point 中的第一条语句（this.x = x;）会为对象 Point 创建一个新的属性 x。此时，V8 会：\n在 C0 的基础上创建另一个隐藏类 C1，并将属性 x 的信息添加到 C1 中：这个属性的值会被存储在距 Point 对象的偏移量为 0 的地方。\n在 C0 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 x 之后能够找到 C1 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C1。\n1. map_trans_b\n执行函数 Point 中的第二条语句（this.y = y;）会添加一个新的属性 y 到对象 Point 中。同理，此时 V8 会：\n在 C1 的基础上创建另一个隐藏类 C2，并在 C2 中添加关于属性 y 的信息：这个属性将被存储在内存中离 Point 对象的偏移量为 1 的地方。\n在 C1 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 y 之后能够找到 C2 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C2。\n2. map_trans_c\n咋一看似乎每次添加一个属性都创建一个新的隐藏类非常低效。实际上，利用类转移信息，隐藏类可以被重用。下次创建一个 Point 对象的时候，就可以直接共享由最初那个 Point 对象所创建出来的隐藏类。例如，如果又一个 Point 对象被创建出来了：\n一开始 Point 对象没有任何属性，它的隐藏类将会被设置为 C0。\n当属性 x 被添加到对象中的时候，V8 通过 C0 到 C1 的类转移信息将对象的隐藏类更新为 C1 ，并直接将 x 的属性值写入到由 C1 所指定的位置（偏移量 0）。\n当属性 y 被添加到对象中的时候，V8 又通过 C1 到 C2 的类转移信息将对象的隐藏类更新为 C2，并直接将 y 的属性值写入到由 C2 所指定的位置（偏移量 1）。\n\n尽管 JavaScript 比通常的面向对象的编程语言都要更加动态一些，然而大部分的 JavaScript 程序都会表现出像上述描述的那样的运行时高度结构重用的行为特征来。使用隐藏类主要有两个好处：属性访问不再需要动态字典查找了；为 V8 使用经典的基于类的优化和内联缓存技术创造了条件。\n\n## 动态机器码生成\nV8 在第一次执行 JavaScript 代码的时候会将其直接编译为本地机器码，而不是使用中间字节码的形式，因此也没有解释器的存在。属性访问由内联缓存代码来完成，这些代码通常会在运行时由 V8 修改为合适的机器指令。\n \n在第一次执行到访问某个对象的属性的代码时，V8 会找出对象当前的隐藏类。同时，V8 会假设在相同代码段里的其他所有对象的属性访问都由这个隐藏类进行描述，并修改相应的内联代码让他们直接使用这个隐藏类。当 V8 预测正确的时候，属性值的存取仅需一条指令即可完成。如果预测失败了，V8 会再次修改内联代码并移除刚才加入的内联优化。\n \n例如，访问一个 Point 对象的 x 属性的代码如下：\n \npoint.x\n \n在 V8 中，对应生成的机器码如下：\n \n`; ebx = the point objectcmp [ebx, <hidden class offset>], <cached hidden class>\njne <inline cache miss>\nmov eax, [ebx, <cached x offset>]`\n \n如果对象的隐藏类和缓存的隐藏类不一样，执行会跳转到 V8 运行系统中处理内联缓存预测失败的地方，在那里原来的内联代码会被修改以移除相应的内联缓存优化。如果预测成功了，属性 x 的值会被直接读出来。\n \n当有许多对象共享同一个隐藏类的时候，这样的实现方式下属性的访问速度可以接近大多数动态语言。使用内联缓存代码和隐藏类实现属性访问的方式和动态代码生成和优化的方式结合起来，让大部分 JavaScript 代码的运行效率得以大幅提升。\n\n## 高效的垃圾回收机制\nV8 会自动回收不再被对象使用的内存，这个过程通常被称为“垃圾收集（Garbage Collection）”。为了保证快速的对象分配和缩短由垃圾收集造成的停顿，并杜绝内存碎片，V8 使用了一个 stop-the-world, generational, accurate 的垃圾收集器，换句话说，V8 的垃圾收集器：\n\n1. 在执行垃圾回收的时候会中断程序的执行。\n2. 大部分情况下，每个垃圾收集周期只处理整个对象堆的一部分，这让程序中断造成的影响得以减轻。\n3. 总是知道内存中所有的对象和指针所在的位置，这避免了非 accurate 的垃圾收集器中普遍存在的由于错误地把对象当作指针而造成的内存溢出的情况。\n\n在 V8 中，对象堆被分成两部分：用于为新创建的对象分配空间的部分和用于存放在垃圾收集周期中生存下来的那些老的对象的部分。如果一个对象在垃圾收集的过程中被移动了，V8 会更新所有指向这个对象的指针到新的地址。","tags":["JavaScript"],"categories":["认知提升"]},{"title":"变化","url":"/2017/11/2017.11.22-变化-个人感悟.html","content":"**{{title}}**   <Excerpt in index | 首页摘要>\n最近挺多时间都在看一些博客。看的最多的当属__编程随想__的博客了，看了这位大神写的关于计算机的好多东西，感觉收获好多，而且边看边觉的这个大神过的日子真是爽歪歪啊。可以在网上随意的发言，想说什么就说什么，不论敏感与否发表自己的看法，而且现在做的事情是自己最喜欢的工作。真是羡煞旁人啊~当然做这些的基础他也分析了，想要这样做，你还要懂得相当多的计算机的知识啊！感觉自己现在技术上还是相关的知识上还是有太多的不足啊~在阅读大神博客的时候，遇到不懂的知识我总要问一下度娘，查阅一些相关的术语，由于浏览最近浏览网页的时间很长，所以网页上的轮播图类的广告推广真的是很影响阅读啊！这就是我今天写这篇博客的原因啦~\n给大家介绍一个屏蔽网页广告的软件，ADSafe，并且由这个软件引发了一系列的引人思考的东西~大家也可以思考一下如今的时代下广告带给我们的利弊和一系列其他的问题。\n# ADSafe\n首先介绍一下这款软件吧，这是一款可以拦截所有浏览器及视频广告，偶尔有些无法拦截的，可以自定义一下。它的自定义功能很强，能完全满足我们的需要。是由上海大摩网络科技有限公司开发的，这是一家位于上海的小公司。是个公司就要生产产品，目标就是要实现盈利，比如这家小公司，开发的这款软件真的是很好用，但是他的盈利点在哪儿呢？在网上搜索了一下，官网都没有说呢，但是在别的地方例如贴吧和个人博客等等都提及到了他的盈利点，就是隐式的注入他自己的广告。有一句话说的好，贼喊捉贼，灯下黑~真是让人不敢相信啊！遇见了这个问题，有一些人选择了立马卸载，有一些人选择了谅解和支持。透过这个问题让我想到了如今火爆非常的盗版..\n那我们今天就来聊一聊这个盗版问题吧~\n说起盗版或者说山寨，有人欢喜有人忧啊~欢喜的是不用花钱就能玩到开发者好不容易开发出的游戏或者其他产品，忧愁的又是谁呢？当然是开发者了，浪费了大量的人力物力，最后竹篮打水一场空，被别人非常轻易的模仿了/抄袭了..一些非常优秀的产品追其本意本就应该是让人使用的，但是开发者浪费了如此大的人力物力的成本，难道不应该为这些付出的汗水得到一些回报吗？美国自由软件运动的精神领袖理查德·马修·斯托曼，他被血多人誉为当今自由如那件的斗士、伟大的理想主义者，但同时也有好多人批评他过于固执、观点落伍。确实，在商业中的话，他就是一个固执的盈不了利的商人，但是如果在如今的现实中的话，免费软件还是非常受欢迎的。这也导致了很多商业游戏公司或者其他的一些以互联网产品为盈利的产品走向了终结，例如：在互联网初期的单机游戏是非常火爆的，而且出现了很多成功的以开发单机游戏的游戏公司，但是没过多久，随着盗版产品的猖獗，越来越多的单机游戏被盗版游戏所取代，卖不出去的单机游戏公司最后的结局相信大家都能看到了..想当时，出现了多少经典优秀的单机游戏，而现在，因为所有的东西总离不开利益的驱使，当单机游戏的开发利益与付出不成正比的时候，那么资本把这个产业弃掉也就不令人感到意外了。所以如今的游戏开发变成了什么呢？变成了网络游戏，必须连上网才能进去游戏，这样就没有了盗版这一途径的污染了，但是又出现了抄袭的风险，例如腾讯的游戏，被大众说成是什么游戏火就抄什么游戏，因为腾讯掌握着用户这把无往不利的利器，任何人都斗不过他..渠道为王的时代，也就不意外前几天报道腾讯的市值已经超半万亿美元了。\n# 有利有弊\n对啊，什么事情都是有利有弊的，也许时代会回答我们的疑问，等着未来的答案吧。也许现在我们认为的弊端到了未来就成为有利的条件了。万物都不绝对，事件的两面性我们在很小的时候就懂了，不过我们真正的认识到这个事实是很难的..由理查德·斯托曼在1983年启动的GUN系统计划，带给了我们多么大的利处，发明了目前最好的操作系统，Linux的出现，运行于用户空间的软件，都可以在Linux上使用，Linux操作系统的诞生，不是一个人的力量，而是互联网史上最大规模的团队合作，而且是无偿的团队合作，完全是出自团队成员之间的编程乐趣，而这样造就出来的操作系统却成为了世上最优秀的系统，让我们感到惊奇的同时又让我们感到确实应该是这样的结果。\n","tags":["个人感悟"],"categories":["资源分享"]},{"title":"幸存者偏见","url":"/2017/11/2017.11.19-分享-幸存者偏见.html","content":"**{{title}}**   <Excerpt in index | 首页摘要>\n\n今天看**编程随想**大神的博客，又涨了点儿姿势，分享给大家吧~\n先说一个“股神”--巴菲特在1984年哥伦比亚大学的演讲，是为了纪念《证券分析》出版50周年的。\n\n> 我要各位设想—场全国性的抛硬币大赛。让我们假定，全美国2.25亿人，在明天早晨起床时都掷一枚硬币，并猜硬币出现的正面或反面。如果猜对了，他们将从猜错者的手中赢得一美元。而猜错的人则被淘汰。每天都有输家遭到淘汰，奖金则不断地累积。经过十个早晨的十次投掷之后，全美国约有22万人连续十次猜对抛硬币的结果。每人所赢得的资金约1000多美元。现在，这群人可能会开始炫耀自己的战绩，此乃人的天性使然。即使他们仍保持谦虚的态度，但在鸡尾酒会中，他们偶尔会以此技巧吸引异性的注意，并炫耀他们对抛硬币的奇特洞察力。游戏继续进行，再经过十天，约有215个人连续20次猜对抛硬币的结果，并且每个人赢得大约100万美元的奖金。输家总共付出2.25亿美元，赢家则得到2.25亿美元。这时候，这群赢家会完全沉迷在自己的成就中——他们可能开始著书立说：“我如何每天早晨工作30秒，并在20天之内将—美元变成100万美元。”更糟的是，他们会在全国各地主办培训班，宣传如何有效地抛硬币。对那些持怀疑态度的学者，他们会反驳说：“如果你认为这是不可能的，该如何解释，为什么会有我们这215个人呢？”但是，某些商学院的教授可能会粗鲁地指出—个事实——假如让2.25亿只猩猩参加这场比赛，结果大致上也是如此——会有215只猩猩连续赢得20次的投掷。\n\n> 然而，我必须说明，前述事例和我即将提出的案例，两者之间存在着若干重大差异。首先，\n(a)如果你所选择的2.25亿只猩猩的分布状况大致上和美国的人口分布相同；\n(b)如果经过20天的竞赛，只剩下215只赢家；\n(c)如果你发现其中有40只猩猩来自于奥马哈的某个动物园，则其中必有蹊跷。\n\n> 于是，你会询问该动物园的猩猩管理员，问此人各种问题。比如给这些猩猩吃什么饲料？这些猩猩是否做某些特殊的运动？是否看了什么书籍？……\n换言之，如果你发现成功案例有非比寻常的集中现象，则你希望判定此异常的特色是否是成功的原因。\n\n> 科学的调查也遵循此一形态。如果你试图分析某种罕见癌症的原因——例如，美国每年只有1500个病例——而你发现蒙大拿州的某个矿区小镇便产生400个病例，则你必然对当地的饮水、病患的职业或其他种种变数产生兴趣。你知道，在—个小镇中发生400个病例，绝不是随机因素所造成。虽然你未必了解病因，但你知道从哪里着手调查。\n\n> 除了地理，还有其他方式可以界定起源。除了地理的起源，还有我所谓“智力的起源”。我认为各位将会在投资领域中发现——不成比例的抛硬币赢家来自于一个极小的智力村庄．它可以称为“格雷厄姆一多德都市”。这个特殊智力村存在着许多赢家．这种集中现象绝非巧合所能够解释。\n\n> 在某些情况下，即使非比寻常的集中现象也可能不重要。或许有100个只是模仿某一位极具说服力的领导者，而依其主张来猜测硬币的投掷结果。当他猜正面，这100个追随者也会自动地做相同的猜测。如果这一位领导者是属于最后215位赢家之一，则这100也便属于同一个智力起源，这项事实便不具有任何意义，因为100个案例实际上只代表一个案例。同理，假定你生活在一个父权结构极为严密的社会，而美国每一个家庭都恰好以父亲马首是瞻。20天之后，你将发现215位赢家是来自于21.5个家庭。若干天真的分析师可能因此而认为，成功地猜测硬币投掷的结果，其中具有高度的遗传因素。当然，这实际上不具有任何意义，因为你所拥有的不是215个独立的赢家，而只是21.5个随机分布的家庭。\n\n> 我所要考虑的这一群成功投资者，拥有一位共同的智力族长——本杰明·格雷厄姆。但是，这些离开此智力家族的孩童，都是依据非常不同的方法猜测他们自己的“硬币”。他们各自前往不同的地方，买卖不同的股票和企业，但他们的综合绩效绝对无法用随机因素加以解释。他们做相同的猜测，并不是因为领导者下达某一项指令，因此也无法用这种方式解释他们的表现。族长只提供了猜测硬币的智力理论，每位学生都必须自行决定如何运用这项理论。\n> ......\n\n正好我最近也想学习一下股市相关的一些东西，说不定哪一天我头脑一热就载到炒股的世界里面成为一届股神了~在这儿就给大家分享一下这个演讲的背景吧~本文开头说了，这是为了纪念《证券分析》一书的。此书被誉为“价值投资领域的圣经”；作者是“本杰明·格雷厄姆”和“大卫·多德”，两人合著的这一经典。上世纪50年代，巴菲特曾经在哥伦比亚大学选修了格雷厄姆开设的“证券分析课程”，并得了A+的成绩。据传闻：格雷厄姆在哥伦比亚大学开设这门课程22年之后，才首次有学生（巴菲特）获得A+的成绩。\n\n好了，说完了股神巴菲特的故事，继续咱们的主题，幸存者偏差：所谓幸存者偏差就是只看到了 显示 出来的事实，而忽略了 隐式 的一些结果，错把 显示 的样本当成了总样本，而得出了错误的结论。在大神的博客中，介绍了几个非常典型的例子，在这里我就借鉴一下吧~\n\n## 关于打仗的例子\n话说二战时的英国空军，经常派轰炸机去袭击德国。由于德国的防空火力较猛，轰炸机损失较惨重。为了降低飞机的损失，空军的领导们决定给飞机的机身进行装甲加固。由于当时条件所限，只能用装甲加固飞机上的少数部位。\n　　然后，英国皇家空军就着手进行研究调查。他们对执行完轰炸任务返航的飞机进行仔细的观察、分析、统计。发现一个现象：大多数的弹孔，都集中在飞机的机翼上；只有少数弹孔位于驾驶舱。\n　　假如你负责此事，你会用装甲加固哪个部位呢？估计很多同学会想当然地说：加固机翼（因为机翼的弹孔最多）。但是答案恰恰相反，【最不需要】加固就是机翼。为啥捏？\n　　驾驶舱的弹孔最少，说明驾驶舱一旦中弹，飞机就载了，再也回不来。所以，它才是最应该加固的部位。\n## 关于网站的例子\n假设有2家网站A和B，都经营类似的业务，都有相当多的用户群。再假设它们都进行了类似的网站界面改版。结果改版之后，网站A没有得到用户的赞扬，反而遭到很多用户的臭骂；而网站B捏，既没有用户夸它，也没有用户骂它。现在，请你来判断一下，哪个网站得人心？\n　　估计又有不少同学会想当然地认为，网站B更受欢迎，毕竟用户没骂它。但事实并非如此。\n　　网站A虽然遭到很多用户痛骂，但至少说明，还有很多用户在乎它；而对于网站B，用户对它已经心灰意冷，无所谓了，所以啥反应也没有。\n　　末了，俺悄悄告诉大伙儿：网站A指的是 Facebook，网站B影射微软旗下的 Live Spaces。这俩都属于 SNS 类网站。想当初，Facebook 稍微改动了隐私条款，差点被用户的口水淹死；反观 Live Spaces，界面越改越土鳖，功能越改越差劲（俺曾经使用 Live Spaces 搭建过镜像博客，对此深有体会）。但又有多少 Live Spaces 的用户去找微软投诉呢？\n\n知道这个道理容易，但是真正的应用到现实生活中就没有那么简单了。因为我们看到了一个显而易见的结果之后往往就不会往深处去琢磨了，是怕累死太多的脑细胞吗？所以当我们认识到一个显而易见的答案时，要想一下有没有“沉默证据”的存在，而不要当即断言这就是真实的结果，这个时候三思而行才是硬道理啊~如果你在分析某个案例时，不清楚属于上述哪一种情况，那么你需要尝试去排除“随机性”。如果无法排除，那么你就只好认可该案例是“随机性”驱动的。","tags":["认知提升"],"categories":["资源分享"]},{"title":"Vue","url":"/2017/11/2017.11.16 vue数据交互.html","content":"**{{title}}** <Excerpt in index | 首页摘要>\n总结一下使用vue的一些方法吧~\n用vue-cli来创建一个vue项目的过程：\n首先在命令行工具页面输入：vue init `<template-name>` [project-name];之后按提示进行就行了。\n创建成功脚手架之后打开创建成功的文件夹，在所在的文件夹下面：cnpm install 安装开发项目所需要的所有依赖； \nnpm run dev  运行本地测试开发开一个本地服务器。\n\n# VUE中h()函数和render()函数用js的简单实现：\n\n`function vElement(tagName, prop, children){\n  if(!(this instanceof vElement)){\n    return new vElement(tagName, prop, children)\n  }\n  if(Object.prototype.toString.call(prop) === \"[object Array]\") {\n    children = prop;\n    prop = {};\n  }\n  this.tagName = tagName;\n  this.prop = prop;\n  this.children = children;\n  var count = 0;\n  this.children.forEach(function(child, index){\n    if(child instanceof vElement){\n\tcount += this.count;\n    }\n    count ++;\n  })\n  this.count = count;\n}`\n\n`vElement.prototype.render = function(){\n  var el = document.createElement(this.tagName);\n  var children = this.children;\n  var prop = this.prop;\n  for(var item in prop){\n    var curProp = prop[item];\n    el.setAttribute(item, curProp);\n  }\n  children.forEach(function(child, index){\n    if(child instanceof vElement){\n\tvar childDom = child.render();\n    }else{\n\tvar childDom = document.createTextNode(child)\n    }\n    el.appendChild(childDom)\n  })\n  return el;\n}`\n\n# Vue的三种模板：\n1、html模板；-->  v-html  仅仅解析html样式；但是解析不出来绑定的数据。\n2、字符串模板；-->  template  ` `  可以解析出绑定的数据。可以用script标签，类型改为：x/template 加上属性名就可以用属性名来调用了。\n3、render()函数；-->  render(creatElement){var dom = creatElement('div',['hello',creatElemnt('p',['world'])])};\n创建出来之后直接return创建的对象就行了！前两个本质上都是调用render函数来创建的。但是这样创建就不能插入vue的一些指令了。\n\n\n# vue中父子组件之间的交互：\n父组件通过props的这个接口与子组件实现交互功能，具体做法是在子组件中定义一个props属性传递数据到父组件中去；子组件通过自定义事件来与父组件进行交互，通过在父组件中调用子组件中的自定义时间来完成；但是要是嵌套的层次太深，也就是父组件中有很多层的子组件，那么他们之间的交互效率就非常的慢了，为了解决这个问题我们可以用vue官方给我们的一个库来管理这些需要交互的数据---即vuex，专为vue.js应用程序开发的状态管理模式；他采用集中式存储管理应用的所有组件的状态；并以相应的规则保证状态以一种可预测的方式发生变化。\n\n# Vue中一些类似方法比较\n计算属性computed  vs  方法mothods：\ncomputed刷新的时候会缓存，更加提高性能。\n\nv-show  vs  v-if\nv-show：直接添加一个css属性display：none；要是频繁的使用这个dom节点的话，应该使用v-show，提高性能。\nv-if： 直接删除一个dom节点\n\n脚手架vue-cli，顾名思义就是一般我们自己做项目要配置的一些东西。但是脚手架会帮我们配置好一套东西。非常方便有木有~工程师就是能让电脑帮我们做的就不要自己动手做了嘛~~嘿嘿嘿。懒人秘籍-必学编程技能哦~\n\n路由设置里面有一个属性方法是mode：这个属性是加载url的方式是用history还是用hash模式，history模式需要我们跟后端去配合，因为会想后端去请求一个新页面替换掉我们现在的页面，hash模式就不用跟后端去配合，是我们想要的单页面应用，当然了，这个是我们没有用router-link这个标签时的情况。用来router-link标签后不管是哪种模式都不会像后台去请求数据了。history模式是直接在当前的url下加上/的，而hash模式是先加上#再加上/的。注意两者的区别\n\n\nnode 中的path路径：\n**__dirname**就是文件所处的当前文件夹；\n\ncreated函数:在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。\n","tags":["学习笔记"],"categories":["前端框架"]},{"title":"JavaScript学习笔记","url":"/2017/11/2017.11.16-学习笔记.html","content":"\n**{{title}}** <Excerpt in index | 首页摘要>\n更新一下这几天学习到的新知识咯~\n# JSON\n虽然知道JSON的数据格式，但是从来没有系统的整理过。今天就来总结一下它吧~\n1. 基于纯文本，跨平台传递极其简单；\n2. JavaScript原生支持，后台语言几乎全部支持；\n3. 轻量级数据格式，占用字符数量极少，特别适合互联网传递；\n4. 可读性极强，虽然比不上XML那么一目了然，但是合理的依次缩进之后还是很容易识别的；\n5. 容易编写和解析；\nJSON格式和规则：\nJSON能够以非常简单的方式来描述数据结构，XML能做到的它都能做到，而且传递的效率更高。\n1. JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号：是映射符，英文逗号,是分隔符，英文双引号\"\"是定义符。\n2. 大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。\n3. 上述两种集合中若有多个子项，则通过英文逗号,进行分隔。\n4. 键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号\"\"，以便于不同语言的解析。\n5. JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。\n__JSON实例：__\n\n`// 描述一个人\n\nvar person = {\n    \"Name\": \"Bob\",\n    \"Age\": 32,\n    \"Company\": \"IBM\",\n    \"Engineer\": true\n}\n\n// 获取这个人的信息\n\nvar personAge = person.Age;\n\n// 描述几个人\n\nvar members = [\n    {\n        \"Name\": \"Bob\",\n        \"Age\": 32,\n        \"Company\": \"IBM\",\n        \"Engineer\": true\n    },\n    {\n        \"Name\": \"John\",\n        \"Age\": 20,\n        \"Company\": \"Oracle\",\n        \"Engineer\": false\n    },\n    {\n        \"Name\": \"Henry\",\n        \"Age\": 45,\n        \"Company\": \"Microsoft\",\n        \"Engineer\": false\n    }\n]\n\n// 读取其中John的公司名称\n\nvar johnsCompany = members[1].Company;\n\n// 描述一次会议\n\nvar conference = {\n    \"Conference\": \"Future Marketing\",\n    \"Date\": \"2012-6-1\",\n    \"Address\": \"Beijing\",\n    \"Members\": \n    [\n        {\n            \"Name\": \"Bob\",\n            \"Age\": 32,\n            \"Company\": \"IBM\",\n            \"Engineer\": true\n        },\n        {\n            \"Name\": \"John\",\n            \"Age\": 20,\n            \"Company\": \"Oracle\",\n            \"Engineer\": false\n        },\n        {\n            \"Name\": \"Henry\",\n            \"Age\": 45,\n            \"Company\": \"Microsoft\",\n            \"Engineer\": false\n        }\n    ]\n}\n\n// 读取参会者Henry是否工程师\n\nvar henryIsAnEngineer = conference.Members[2].Engineer;`\n\n# JSONP\n说到JSONP，那不得不提的就是Ajax了。Ajax的大名早就在程序员的江湖上名声赫赫了，但是Ajax有一个缺点就是不能跨域进行数据的交互，所以为了解决这个遗憾，JSONP闪亮登场了，为什么JSONP可以进行跨域传输数据呢？因为这是“历史遗留”问题了。\n1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；\n2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有\"src\"这个属性的标签都拥有跨域的能力，比如`<script>`、`<img>`、`<iframe>`）；\n3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；\n4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；\n5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。\n6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。\n7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。\n如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"前端开发相关","url":"/2017/11/2017.11.12-前端开发相关.html","content":"\n**{{title}}** <Excerpt in index | 首页摘要>\n\n# js中多维数组转换成一维数组\n```\nvar arr = [ 1, [2], [[[3]]], [4, [5] ] ];\n \nfunction unidimensionalArray (arr) {\n　　return (arr + '').split(',').map(x => Number(x));\n}\n// 先转换成字符串，在转换成数字类型的。\nconsole.log(unidimensionalArray(arr)); // [ 1, 2, 3, 4, 5 ]\n \n// 以上针对数字数组的， 下面是一个针对多类型的\nvar obj = {};\nvar func = function() {};\nvar u = undefined;\nvar nan = NaN;\nvar num = 1;\nvar str = 'boy';\nvar bool = true;\nvar arr = [bool, [str], [[num]], u, [[[nan, func]]], obj];\n \nvar unidimensionalArray = function(arr) {\n    return arr.reduce((p1, p2) => p1.concat(Array.isArray(p2) ? unidimensionalArray(p2) : p2), []);\n};\nconsole.log(unidimensionalArray(arr)); // [ true, 'boy', 1, undefined, NaN, [Function: func], {} ]\n```\n# 求数组中的最大值\n```\n~function(){\n        var arr = [[1, 3, 5], 4, -1, [11, 22, 33, 45, [7, 123, 1]],98, [[123]]];  \n            \n        //=================================  \n        //目标数组, 一维数组\n        var targetArr = [];  \n        \n        //=================================  \n        //展开多维数组为一维数组的函数,递归调用  \n        //forEach 为 ES5的数组迭代方法  \n        var fnExpandArray = function (arr) {  \n            arr.forEach( function (item) {  \n                if ( Array.isArray(item) ) {  \n                fnExpandArray(item);  \n                } else {  \n                targetArr.push(item);  \n                }  \n            });  \n        };  \n        \n        //=================================  \n        //展开数组到 targetArr中  \n        fnExpandArray(arr);  \n        console.log(targetArr);  \n        \n        //=================================  \n        //求出最大值的函数,假设第一个值为最大值, 并且与后面的值进行比较  \n        var fnMax = function (arr) {  \n            var max = arr[0];  \n            arr.forEach( function (item) {  \n            if (item > max) {  \n                max = item;  \n            }  \n            });  \n            return max;  \n        };  \n        \n        //=================================  \n        //最终答案  \n        alert('最大值是:' + fnMax(targetArr));  \n        \n}()\n```\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"智力题总结","url":"/2017/11/2017.11.10-智力题总结.html","content":"**{{title}}** <Excerpt in index | 首页摘要>\n\n最近在找工作，做了一些笔试题和参加了几个面试，面试中被问到有关智力型的问题，要是你看过一些算法类型的书的话，你就会发现这些问题大同小异的都会用到算法中的一些经典的思想。其中有经典的分治法的思想等等，有些智力题真的是非常的耐人寻味。\n今天就给大家总结一些面试中被问到的智力型问题吧~\n\n# 1. 有1000瓶啤酒，其中有一瓶有毒，有小白鼠10只，毒药5天发作，如何在5天时间内找出那瓶毒酒。\n这个题是考察你对二进制的理解。\n可以把1000瓶啤酒用二进制编号，那么最多需要10位二进制数。可以用每只小鼠验证每一位二进制数中的一位。例如：可以用第一只小鼠验证第一位数中的1，第二只小鼠验证第二位数中的1，以此类推。那么根据最后小鼠的死亡数来判断具体第几瓶酒有有毒了。\n\n这个问题也可以有很多变种题。例如：可以测两轮，那么可以测多少瓶酒中的一瓶毒药。对于能replace的情况：2^10*2^10。对于不能replace的情况：3^10。\n\n# 2. 有一座桥，桥长80米，你有一个背包，背包可以背60个豆子，你要从桥这边到桥那边去，但是有一个规则，你每走一步必须吃一个豆子，只能背一个背包。求最少需要多少豆子才能过桥。\n\n**答案：160豆子**\n解析：你可以先背60个豆子走到20米处，放下20个豆子放回，然后再背满豆子出发，就能走过去了。总共需要160个豆子。\n\n# 3. N的阶乘后面有多少个零。\n首先，我们先来看一下，结尾是0的数是由谁生成的？\n出现0的情况就是5的倍数乘以2的倍数。但是出现0的个数是不一定的，2\\*5=10结果出现一个0，4\\*25=100结尾出现2个0，8\\*125=1000结尾出现3个0。以此类推，大家不难发现规律所在，4\\*25可以分解成2\\*5\\*2\\*5,8\\*125可以分解成2\\*5\\*2\\*5\\*2\\*5...\n至于10，15，20...这些数，分解开，也只会出现1个5，也就只会出现1个0；\n至于50，75...这些25的倍数，分解开，也只会出现2个5，与偶数相乘也只会出现2个0。\n下面就是计算0个数了。\n\n例如：100！\n由上面的推理过程就能得到：\n100/5 + 100/25 = 24\n即：100的阶乘后面有24个0；\n\n# 4. 扑克牌问题\n问题：一付54张扑克牌，其中有十张是翻过来的。现在把你的眼睛蒙上（绝对没有偷看的可能），让你把扑克牌分成两叠（两叠的多少可以不一样）。要求在两叠中翻过来的扑克牌是相等的。请问该怎么做？除了扑克牌的数目，其它因数（扑克牌大小，重量，颜色，表面触摸的感觉，等等）不参与题目之中。扑克牌可以任意次重新排序、翻转。10张翻过来的扑克牌是随机分布在扑克牌中。\n\n**答案：第一步，你在这54张牌中任意取出10张，现在，扑克牌分成了两叠。44张和10张；第二步，44张那叠不动，将10张这叠每张都翻过来，便得到了符合条件的两叠牌。**\n\n解释：第一步之后，设44张那叠中正面牌x张，10张那叠中正面牌则为10-x张。第二步之后，44张那叠中正面牌保持x张，10张那叠反过来了：反面牌为10-x张，正面牌x张。\n# 5. 分金条问题\n问题：有个商人雇用了一位手艺高超的工匠了为他做一个精致产品，工作一星期七天的代价是一条金条。商人手头上有一条金条，刚好有可以付工匠一星期的工钱。但工匠要求工钱要按每天来付。虽然他并不急着用钱，每天有钱进账，老人心里总是踏实一些。但商人家中有个规矩，金条每星期只能切二刀。后来商人想出以了个切割金条的办法，满足了工匠的要求。你知道商人是怎么切割金条才能满足工匠的吗？\n\n**答案：切成1、2、4。**\n\n解释：这三个二进制数的组合能表示0-7中的任何一个。\n# 6. 送花瓶\n问题：古时候有一位商人要让伙计将一个精致的花瓶送到买主的手里。买主住在很远的地方，路途中间要经过土匪出没的地方。土匪要是见到花瓶就会抢走。但土匪不会打开锁着的东西，只要把花瓶锁在箱子里就可以安全地送到目的地（这土匪看起来还很文明）。所以商人准备了一个大箱子，在箱子上装了个很大很结实的的锁扣，足以挂几把锁。商人还准备了一把精致的铁锁将花瓶锁在箱子里。这把铁锁的钥匙是独一无二的，没有这把钥匙，按照当时的技术箱子是绝对打不开的。但问题来了，土匪只要见到钥匙就会没收。钥匙都是没法安全地送到买主的手里的。买主也不能把自己的锁送给卖主用。在几经周折后，买主终于得到了他心爱的花瓶。请问这花瓶是如何送到买主的手里的？\n这是一个故事，但故事里的技术是实在的，也确实运用到了如今的高科技中。在互联网中怎样将信息安全地送到目的地而不被黑客在中途截获，也是成功地运用了类似的方法。你知道故事的答案吗？\n\n**答案：1)、把花瓶锁在箱子里（这把锁只有商人能开，称为“锁1“)，然后运到买主手里。2)、买主收到箱子后，在箱子上再加上自己的锁（这把锁只有买主能开，称为“锁2“),然后把箱子运回给商人。3)、商人收到箱子后，把锁1找开拿走，这时候箱子上只剩下锁2，然后把箱子运给买言。4)、买主收到箱子后， 打开锁2，就成功拿到花瓶。**\n# 7. 切蛋糕\n问题描述：有一个长方形的蛋糕，中间已被挖去了一个长方形的坑。这长方形的坑不在蛋糕的中央，也不与蛋糕的周边平行。两位小朋友想平分这个蛋糕，请问如何一刀将但蛋糕分成两个体积相等的部分？条件：只能切直的一刀，而且不能拦腰将蛋糕分成上下两个部分（因为蛋糕上面有好吃的糖果。\n\n**答案：沿着两个矩形的中心连线切下去即可。**\n\n解释：两份蛋糕图形的面积相等，都等于大矩形面积的一半减去小矩形面积的一半。\n# 8. iPhone 四位数密码\n问题描述：一个朋友打开了他的iPhone，我一把把它抓过来说：‘嗯，9、6、0，和1，对吧？’。因为有浓重的手指印在这四个数字上面，我正确地推定这与他的密码相关。他吓了一跳，因为如果我是一个贼，我可以很容易解开他的电话。因为所有的四个数字在四位数字代码中只有一次出现（据我所知，这只有4 x 3 x 2 x 1 = 24种可能）。因而，取四个不同数字作代码不是非常安全的。所以，当我设定密码时，我选择了重复的数字（如1-2-3-1）。这样一来，如果有人会看我的手机，即使他们能够探测到我的手指印，他们要么在猜想第四个数字（不存在），或者，他们如果弄清楚我只用三个独立数字，他们将不得不尝试在一个四位数代码中，列出这三个不同数字所有可能的排列。问题是：1．在一个四位数的代码中，只使用三个数字对安全是否确实有帮助？2．如果只重复使用两个独立的数字会不会更好呢？\n\n**答案：用三个数字最安全，两个数字最不安全，四个数字居中。**\n\n解释：1)、4个位置不同时,排列数=4*3*2*1=24；2)、3个位置不同时,排列数=C(4,2)*2*3=36；3)、2个位置不同时,排列数=3个重复情况（4+4）+两两重复情况（6）=14。\n# 9. 书有多少页\n问题描述：一本书有N页厚。书的页数是从1 到N。所知道的是，所有的页数总共用了1095个数码字。请问这本书有多少页？\n\n**答案：401页**\n\n解释：有9页个位数的书页，每页用一个数码字。90页两位数的书页，每页用2个数码字。首先假设没有四位数的书页，而三位数书页的数目为x。因为总共用了1095个数字，所以列出x的方程：9+2*90+3*x=1095。解出x=302，总的书页数=302+9+90=401。\n# 10. 左轮枪\n问题描述：某公司招聘员工面试时提的问题：“让我们来玩个游戏”，招聘人开始了。“你现在被牢牢地绑在椅子上不能动。这是一把枪，一把六星左轮抢，六个弹槽都空着。现在，我把两颗子弹装入弹槽。看到我把子弹装入两个相邻的弹槽了吗？我把轮子合上，然后用手拨动让轮子转动几圈。我把枪对着你的头，扣动了扳机，…，叭。你真幸运！第一枪撞针没打中子弹。然后，我要再扣一次扳机。”招聘人接着说：“我可以直接扣动扳机，或旋转轮子一下再扣扳机，你可以选择其中一种，请问，你选哪一种方法呢？”庆幸的是这只是一把想象中的枪。招聘人只是用手势做出旋转轮子和扣动扳机的样子。但不幸的是你的前程却掌握在挥舞着‘手枪’的家伙的手里。 当然，这两种方法都不是你要的，但其中一种方法的生存的机会会大一些。你到底应该选择哪一种方法呢？\n解释：题中说：子弹是装入两个相邻的弹槽，左轮枪是一格一格往下转的，如右图所示。1) 第一枪没有打出子弹，因此，第一枪的位置只可能是A、B、C、D。那么，接连第二枪的位置就会是第一枪的下面一个，也就是：B、C、D、E，这4个位置中，只有E有子弹。所以，如果直接扣动扳机，几率=1/4。2) 如果重新把轮子转一下，左轮枪将处于随机的位置，6个格子有2颗子弹，这时挨枪的机率为2/6=1/3。3.)1/4 <1/3，‘不转’死的几率更小。\n\n**答案：选择‘不转’，因为被打死的概率更小。**\n\n这个问题让我想到了经典的羊车门问题。有没有一点相似之处呢？\n# 11. 导火索\n问题描述：有两根导火索，它们的长度都是正好1分钟烧完。但是它们燃烧的速度是不均匀的。也就是说，你不能用一小段的长度与总长度的比值来确定燃烧完这一小段的时间。用这两根导火索和一只打火机，没有其它计时器的帮助，请你给我报告两次时间信号：开始的时间t1、结束的时间t2。时间t1和t2准确地相差45秒。\n\n答案：将其中一根的两头，以及另一根的一头，同时点燃，这个时刻定为t1。当第一根烧完时，立即后点燃第二根的另一端，第二根烧完的时刻便是t2。\n\n解释:见下图：第一根两头点燃，直到烧完，时间是30秒。这时第二根也烧了30秒，因第二根只点了一端，因而只烧完了一半时间，剩下的部分还能烧30秒，这时马上点燃它的另一端，变成从两头同时烧，因而烧完的时间是15 秒，加上开始的30秒，总共历时45秒。\n# 12. 计时沙漏\n问题描述：沙漏（hourglass）是最早使用的计时仪器之一。如下图（a）中所示的沙漏，是上下对称的，可以倒来倒去地计时。比如说，如果有一个2分钟的沙漏，你便可以漏一次得到2分钟，漏完后立即倒过来，再漏完，总共得到4分钟的时间。\n\n现在，给你一个4分钟的沙漏，和一个7分钟的沙漏，它们都是可以倒来倒去的对称沙漏。如何将它们配合使用，才能得到准确的、从开始到结束总共9分钟的时间？\n\n用图形，我们可以更方便地说明这个问题。一个沙漏某时刻的状态可以用上下重叠的两个带数字的方格表示，例如，上图（b）所表示的是7分钟沙漏的初始状态和漏了2分钟后的状态。上图中的（c）则是要请你回答的问题。\n\n__解释：设7分钟的沙漏为A，4分钟的为B，A，B同时漏，4分钟后， 状态为 （A ： 3，4）；（ B：0，4）；B倒过来， 3分钟A漏完全后， 状态为（A ： 0，7）； （B：1，3）；A倒过来， 1分钟B漏完全后， 状态为（A ： 1，6）； （B：0，4），A倒过来, 1分钟后，状态为（A ： 0，7）；__\n\n# 13. 测量砖头的对角线\n问题描述：单凭三个砖块和一把尺子，不使用任何公式，怎样才能测量一个砖头的立体对角线？就是穿过砖头内部的那条对角线。\n\n__答案：将三块砖头如图迭起来，就可测量。__\n# 14. 电路\n问题描述：12个电阻连成一个正立方体，正方体的每一条棱上有一个1欧姆的电阻，请你求出A和E之间的等效电阻。\n**答案：5/6。**\n解释：解此题的巧妙之处是在于利用对称性，和电学的一丁点儿基础概念，否则……见下左图，三个红点的电位应该相同，三个绿点的电位也应该相同。电位相同的点等效于连在一起。下图中，左、右的电路是互相等效的，因此：R = 1/3 + 1/6 + 1/3，R = 5/6。\n# 15. 方格子\n问题描述：有一张8×8=64个格子的格子纸，右上角和左下角各被剪去一格，如图左所示：女儿有31张长方形的卡片（中图），每张刚好是两个格子。女儿想：剪掉了两个角的格子纸面积和31张卡片总面积一样大，因此，她想用卡片作拼图，把格子纸盖起来，但她拼来拼去都不成功，你能帮帮她吗？或者……\n**答案：不可能覆盖起来。**\n解释：不是面积相等就能覆盖的！女儿难不倒将军。不过，8岁的女儿不懂高深的数学，将军想了一个巧妙的方法解释给她听。他将8×8的格子纸涂成黑白相间的国际象棋棋盘（下左图），又举了2×2方格纸剪去两角为例。看下面右图，剪去的两个小方块都是黑色的，剩下两个白方块处于对角的位置，怎么可能被一个黑白的卡片覆盖呢？图中一目了然，小女儿很快就明白了。\n# 17. 为什么下水道的盖子是圆的？\n参考答案:\n主考官认为的最好回答是：正方形的盖子容易掉到洞里去。想一想，如果盖子真掉进去的话，那么不是发生伤人事故，就是盖子会掉到水里。为什么正方形的盖子容易掉下去呢？这是因为正方形的对角线是其边长的约1.414倍。如果把一个正方形盖子垂直地立起来，稍微一转，它就会很容易掉到下水道里去。与此相反，圆的直径都是等长的，这使它很难掉进去。 \n一种诙谐回答是：下水道的洞口是圆形的，盖子当然也应该是圆的。那么为什么下水道的洞口是圆形的？答案是因为圆形的洞比方形的洞好挖。 \n还有另外一种答案：在进行短距离搬运时，圆形的盖子可以很方便地通过滚动的方法来搬运，而方形的盖子就不容易搬运，你需要借助手推车或者由两个人抬着走。再有一点就是用圆形盖子盖住洞口时，不需要怎么调整就可以与洞口严丝合缝。 \n__这个问题恐怕是微软最为有名的面试问题了。由于“曝光率”太高，微软在面试中已经停止使用这个问题了。__\n# 18. 美国有多少加油站（汽车）？\n参考答案:\n**这个乍看让人有些摸不着头脑的问题时，你可能要从问这个国家有多少小汽车入手。面试者也许会告诉你这个数字，但也有可能说：\"我不知道，你来告诉 我。\"那么，你对自己说，美国的人口是2.75亿。你可以猜测，如果平均每个家庭 （包括单身）的规模是2.5人，你的计算机会告诉你，共有1.1亿个家庭。你回忆起在什么地方听说过，平均每个家庭拥有1.8辆小汽车，那么美国大约会有1.98亿辆小汽车。接着，只要你算出替1.98亿辆小汽车服务需要多少加油站，你就把问题解决了。重要的不是加油站的数字，而是你得出这个数字的方法。**\n# 19. 距离问题\n有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞 行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？\n**参考答案:答案很容易计算的： 假设洛杉矶到纽约的距离为s 那小鸟飞行的距离就是(s/(15+20))\\*30。**\n# 20. 概率问题\n你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机 选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到 红球的准确几率是多少？\n**参考答案:一个罐子放一个红球,另一个罐子放49个红球和50个蓝球,概率接近75%.这是所能达到的最大概率了。实际上，只要一个罐子放<50个红球，不放篮球，另一个罐子放剩下的球，拿出红球的概率就大于50%。**\n无答案，看你有没有魄力坚持自己的意见。\n# 21. 重量问题\n你有四人装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被 污染的重量+1.只称量一次，如何判断哪个罐子的药被污染了？\n\n**参考答案:从第一盒中取出一颗，第二盒中取出2 颗，第三盒中取出三颗。 依次类推，称其总量。再根据总重量增加多少判断污染的药罐。**\n# 22. 夸脱的水问题\n如果你有无穷多的水，一个3夸脱的和一个5夸脱的提桶，你如何准确称出 4夸脱的水？\n`参考答案:\n先用3 夸脱的桶装满，倒入5 夸脱。以下简称3->5) 在5 夸脱桶中做好标记b1，简称b1)。 \n用3 继续装水倒满5 空3 将5 中水倒入3 直到b1 在3 中做标记b2 \n用5 继续装水倒满3 空5 将3 中水倒入5 直到b2 \n空3 将5 中水倒入3 标记为b3 \n装满5 空3 将5 中水倒入3 直到3 中水到b3\n结束了，现在5 中水为标准的4 夸脱水。`","tags":["思维能力"],"categories":["学习笔记"]},{"title":"前端面试总结","url":"/2017/11/2017.11.9-前端面试.html","content":"**{{title}}**  <Excerpt in index | 首页摘要>\n# HTTP协议\n之前也看过一些有关tcp/ip协议的书，对HTTP协议也有一些了解，但是真要让我自己说出来的时候才发现对http协议了解的只是脑海中的印象而已，当时看书是理解了，但是回过头来想的时候又变得模糊了，总之，还是自己没有理解透彻的原因吧！\n今天就再来简单概括一下HTTP协议的主要内容吧~同学们，好好听课，重点来了~（敲黑板~认真脸~）\n1. 支持客户/服务器模式。\n2. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n3. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n4. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n5. 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n\n### http请求由三部分组成，分别是：请求行、消息报头、请求正文\n\n1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF  \n其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。\n\n请求方法（所有方法全为大写）有多种，各个方法的解释如下：\nGET     请求获取Request-URI所标识的资源\nPOST    在Request-URI所标识的资源后附加新的数据\nHEAD    请求获取由Request-URI所标识的资源的响应消息报头\nPUT     请求服务器存储一个资源，并用Request-URI作为其标识\nDELETE  请求服务器删除Request-URI所标识的资源\nTRACE   请求服务器回送收到的请求信息，主要用于测试或诊断\nCONNECT 保留将来使用\nOPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求\n应用举例：\nGET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)\n\nPOST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。\neg：POST /reg.jsp HTTP/ (CRLF)\nAccept:image/gif,image/x-xbit,... (CRLF)\n...\nHOST:www.guet.edu.cn (CRLF)\nContent-Length:22 (CRLF)\nConnection:Keep-Alive (CRLF)\nCache-Control:no-cache (CRLF)\n(CRLF)         //该CRLF表示消息报头已经结束，在此之前为消息报头\nuser=jeffrey&pwd=1234  //此行以下为提交的数据\n\nHEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。\n2、请求报头后述\n3、请求正文(略) \n\n### HTTP协议详解之响应篇\n\n在接收和解释请求消息后，服务器返回一个HTTP响应消息。\n\nHTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文\n1、状态行格式如下：\nHTTP-Version Status-Code Reason-Phrase CRLF\n其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。\n状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：\n1xx：指示信息--表示请求已接收，继续处理\n2xx：成功--表示请求已被成功接收、理解、接受\n3xx：重定向--要完成请求必须进行更进一步的操作\n4xx：客户端错误--请求有语法错误或请求无法实现\n5xx：服务器端错误--服务器未能实现合法的请求\n常见状态代码、状态描述、说明：\n200 OK      //客户端请求成功\n400 Bad Request  //客户端请求有语法错误，不能被服务器所理解\n401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 \n403 Forbidden  //服务器收到请求，但是拒绝提供服务\n404 Not Found  //请求资源不存在，eg：输入了错误的URL\n500 Internal Server Error //服务器发生不可预期的错误\n503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常\neg：HTTP/1.1 200 OK （CRLF）\n\n2、响应报头后述\n\n3、响应正文就是服务器返回的资源的内容\n\n# 进程和线程\n一个程序至少有一个进程,一个进程至少有一个线程. \n线程的划分尺度小于进程，使得多线程程序的并发性高。\n另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。\n线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。\n\n进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.\n线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.\n一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。\n\n__进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。__\n\n# 盒模型\n![W3C-Box](http://outwcl4zh.bkt.clouddn.com/W3C-Box.jpg)\n![IE-Box](http://outwcl4zh.bkt.clouddn.com/IE-Box.jpg)\n\n# js中异步加载和同步加载的优缺点\n### 同步模式\n又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。\n js 之所以要同步执行，是因为 js 中可能有输出 document 内容、修改dom、重定向等行为，所以默认同步执行才是安全的。\n以前的一般建议是把 __`<script>`放在页面末尾`</body>`之前，这样尽可能减少这种阻塞行为，而先让页面展示出来。__\n简单说：同步加载的网络 timeline 是瀑布模型，而异步加载的 timeline 是并发模型。\n\n### 异步加载\n又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理。\n这种方法是在页面中 __`<script>`标签内，用 js 创建一个 script 元素并插入到 document 中。这样就做到了非阻塞的下载 js 代码。__\nasync属性是HTML5中新增的异步支持，见后文解释，加上好（不加也不影响）。\n此方法被称为 Script DOM Element 法，不要求 js 同源。\n将js代码包裹在匿名函数中并立即执行的方式是为了保护变量名泄露到外部可见，这是很常见的方式，尤其是在 js 库中被普遍使用。\n代码如下：\n\n`(function() {\n     var s = document.createElement('script');\n     s.type = 'text/javascript';\n     s.async = true;\n     s.src = 'http://yourdomain.com/script.js';\n     var x = document.getElementsByTagName('script')[0];\n     x.parentNode.insertBefore(s, x);\n })();`\n\n **但是，这种加载方式在加载执行完之前会阻止 onload 事件的触发，而现在很多页面的代码都在 onload 时还要执行额外的渲染工作等，所以还是会阻塞部分页面的初始化处理。**\n\n`(function() {\n     function async_load(){\n         var s = document.createElement('script');\n         s.type = 'text/javascript';\n         s.async = true;\n         s.src = 'http://yourdomain.com/script.js';\n         var x = document.getElementsByTagName('script')[0];\n         x.parentNode.insertBefore(s, x);\n     }\n     if (window.attachEvent)\n         window.attachEvent('onload', async_load);\n     else\n         window.addEventListener('load', async_load, false);\n })();`\n\n 这和前面的方式差不多，但关键是它不是立即开始异步加载 js ，而是在 onload 时才开始异步加载。这样就解决了阻塞 onload 事件触发的问题。\n\n在异步加载的时候，无法使用 document.write 输出文档内容。\n在同步模式下，document.write 是在当前 script 所在的位置输 出文档的。而在异步模式下，浏览器继续处理后续页面内容，根本无法确定 document.write 应该输出到什么位置，所以异步模式下 document.write 不可行。而到了页面已经 onload 之后，再执行 document.write 将导致当前页面的内容被清空，因为它会自动触发 document.open 方法。\n实际上document.write的名声并不好，最好少用。\n替代方法：\n1. 虽然异步加载不能用 document.write，但还是可以onload之后执行操作dom（创建dom或修改dom）的，这样可以实现一些自己的动态输出。比如要在页面异步创建一个浮动元素，这和它在页面中的位置就没关系了，只要创建出该dom元素添加到 document 中即可。\n2. 如果需要在固定位置异步生成元素的内容，那么可以在该固定位置设置一个dom元素作为目标，这样就知道位置了，异步加载之后就可以对这个元素进行修改。\n\n# 如何在元素未添加到dom结构时在元素上绑定事件\n可以用事件冒泡的形式进行处理，如下代码：\n\n`$(document).on('click','selector',function(){  \n        ...  \n    }); `\n    \n此时事件冒泡到document对象上，当检测事件的target，如果与传入的选择符（这里是selector）匹配，就触发事件，否则不触发。","tags":["计算机基础"],"categories":["学习笔记"]},{"title":"诗与远方","url":"/2017/11/2017.11.09 诗与远方.html","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n## 个人随笔：\n总有一代人会实现我们的梦想；\n100多年前，在梁启超的海船上又曾复活了：“纵有千古，横有八荒，前途似海，来日方长。美哉我少年中国，与天不老！壮哉我中国少年，与国无疆！”\n\n\n一个人最重要的不是拥有多少财富，和拥有多大的房子，最重要的是拥有深厚的学识和崇高的思想道德。         -康震点评《陋室铭》\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["诗与远方"],"categories":["个人随笔"]},{"title":"前端练习题","url":"/2017/11/练习题.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n##  隐式类型转换\n\n1. var str = false + 1;\n   document.write(str);\n结果为：1        （false会发生隐式类型转换成数值类型的0）\n\n2. var demo = false == 1;\n   document.write(demo);\n结果为：false  （同第一题）\n\n3. if(typeof(a) && - true + (+ undefined) + \"\") {\n      document.write('基础扎实');\n   }\n结果为：基础扎实   （typeof()是唯一一个使用未经声明的变量，不报错的方法，并且它的六个返回结果都是字符串类型的；\"\"空字符串起连接作用）\n\n4. if(11 + \"11\" * 2 == 33) {\n\tdocument.write('基础扎实');\n   }\n结果为：基础扎实     （运算符的优先级比较，先算乘除再算加减。等号优先级最低。牢记字符串的连接作用。）\n\n5. !!\" \" + !!\"\" - !!false || document.write('你觉得能打印，你就是猪');\n结果为：1\n\n ## 预编译\n\n1. function bar() {\n\treturn foo;\n\tfoo = 10;\n\tfunction foo() {\n\t\t\n\t}\n\tvar foo = 11;\n  }\n  document.write(bar());\n结果为：function foo() {};     （牢记函数预编译的四部）\n\n2. function bar() {\n\tfoo = 10;\n\tfunction foo() {};\n\tvar foo = 11;\n\treturn foo;\n   }\n   console.log(bar());\n结果为：11                     （牢记函数预编译的四部）\n\n3. a = 100;\n    function demo(e) {\n\tfunction e() {}\n\targuments[0] = 2;\n\tdocument.write(e);\n\tif(a) {\n\t   var b = 123;\n\t   function c() { \n\t   }\t\n\t}\n\tvar c;\n\ta = 10;\n\tvar a;\n\tdocument.write(b);\n\tf = 123;\n\tdocument.write(c);\n\tdocument.write(a);\n    }\n    var a;\n    demo(1);\n    document.write(a);\n    document.write(f);\n结果为：2 undefined undefined 10 100 123     （全局变量有两种，第一种就是直接定义在全局中的变量，第二种就是没用var直接定义出来的变量。if里面不能定义函数，以前可以，现在不合法，但是也不会报错）\n\n \n  ## 立即执行函数\n1. function test(a, b) {\n\tconsole.log(a, b);\n   }(1, 2);\n结果：不报错，返回结果为：2。        （因为会把最后小括号当成随意写在文本中的，另外会返回括号里面最后的数）\n\n\n\n ## new问题\n1. 运行test()和new test()的结果分别是什么？\n   var a = 5;\n   function test() {\n\ta = 0;\n\talert(a);\n\talert(this.a);\n\tvar a;\n\talert(a);\n   }\n结果为：test执行结果为0、5、0   new test结果为0、undefined、0\n\n\n2. 分析下面的JavaScript代码段：\n\tfunction employee(name, code) {\n\t\tthis.name = \"wangli\";\n\t\tthis.code = \"A001\";\n\t}\n\tnewemp = new employee(\"zhangming\",'A002');\n\tdocument.write(\"雇员姓名:\" + newemp.name + \"<br>\");\n\tdocument.write(\"雇员代号:\" + newemp.code + \"<br>\");\n输出的结果是(  ).(选择一项)\n   A. 雇员姓名:wangli  雇员代码:A001\n   B. 雇员姓名:zhangming  雇员代码:A002\n   C. 雇员姓名:null, 雇员代码:null\n   D. 代码有错误，无输出结果\n答案是：A     （因为根本就没有进行赋值、没用到传进去的参数、写死了，定式的，生成多少个都是这样的。如果想进行赋值的话应该写成  this.name = name,this.code = code）\n\n3. var str = \"abc\";\n   str += 1;\n   var test = typeof(str);\n   if(test.length == 6) {\n\ttest.sign = \"typeof的返回值可能为String\";\n   }\n   document.write(test.sign);\n结果为：undefined  (str先+=1得字符串形式的abc1.然后typeof(str)返回值是字符串形式的string，test是原始值，所以访问他的.length会形成包装类，test的长度确实是6，所以能走进if循环里。包装类保存不出来。)\n\n\n4. function Person(name, age, sex) {\n\tvar a = 0;\n\tthis.name = name;\n\tthis.age = age;\n\tthis.sex = sex;\n\tfunction sss() {\n\t   a++;\n\t   document.write(a);\n\t}\n\tthis.say = sss;\n   }\n   var oPerson = new Person();\n   oPerson.say();\n   oPerson.say();\n   var oPerson1 = new Person();\n   oPerson1.say();\n结果为：1、2、1      (注意：题中的this.say = sss把sss保存出来了，与Person形成闭包 )\t\n\n\n5. var x = 1;\n   if(function f() {}) {\n\tx += typeof f;\n   }\n   console.log(x);\n结果为：1undefined    （boolean值为false的只有6个，上题中的不属于那六个，所以肯定能走进if语句中。typeof是唯一一个使用未经声明的变量不报错的方法）\n\n6. (function(x) {\n\tdelete x;\n\treturn;\n   })(1);\n\n结果为：undefined     （可配置性。delete只能删除对象上的属性，比如在全局上定义一个 var a = 123；虽然a就相当于是window上的一个属性，但是delete window.a是删不了的。但是你要是在全局上就定义window.a = 123;或者 a = 123； delete a;结果就为真，可以删除的。这也就是可配置性一说！）\n\n\n7. var h = function a() {\n\treturn 23;\n   }\n   typeof a();\n结果为：报错a is not defined\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n重点中的重点！\n  typeof (new Array).__proto__.constructor()\n结果为：\"object\"     解析：先算括号里面的，再算点。优先级顺序。形式上又有typeof的两种形式的用法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端"],"categories":["学习笔记"]},{"title":"说说滕王阁的修建者——“混蛋王爷”李元婴","url":"/2017/11/滕王阁的修建者--滕王李元婴.html","content":"\n# 说说滕王阁的修建者——“混蛋王爷”李元婴\n说到江西南昌的滕王阁，即使没去过的人，也一定听过它的大名，号称江南三大名楼之首，尤其是唐初诗人王勃的《滕王阁赋》，更让它名扬天下，其中的诗句“落霞与孤鹜齐飞，秋水共长天一色”流传至今。但历史上的滕王阁其实有三处，最早修建是山东滕州的滕王阁（已被毁，待复建），其次是江西南昌的滕王阁（知名度最高），最后修建是四川阆中的滕王阁。这三处滕王阁的修建者都是同一个人——即唐初的滕王李元婴。\n\n![滕王阁](http://outwcl4zh.bkt.clouddn.com/%E6%BB%95%E7%8E%8B%E9%98%81)\n现在位于江西南昌的滕王阁\n\n李元婴在历史上的知名度并不高，但要是说到他的父亲唐高祖李渊和他的哥哥唐太宗李世民，却是大家非常熟悉的历史人物。李渊共有二十二个儿子，除了隐太子李建成、唐太宗李世民等，还有这个最小的儿子李元婴。李元婴出生于公元630年，也就是贞观三年，这个时候的李渊早已禅让退位，年纪也64岁了，却也不耽误生孩子。贞观十三年，才十岁的李元婴被哥哥唐太宗封为滕王，封地在今天的山东滕州。\n成年后，李元婴按照唐朝的制度，前往封地就蕃。只是这位王爷没有造福地方，相反却是骄奢淫逸、横征暴敛、大兴土木，引起了当地极大的民愤。根据相关的史书记载，李元婴在地方并无政绩可言，而是终日飞鹰走狗、声色犬马。据说他经常带着大队的人马在自己的领地内骑马打猎，甚至把忙于劳作的农民当靶子，玩弹弓射击，以此取乐，唐高宗李治为此还专门写信劝诫这位比自己小很多的皇叔不要用弹弓射人。\n在生活作风方面，李元婴也是个十足的混蛋。他的王府里面不仅妻妾众多，而且特别青睐下属们的漂亮妻子。据说，在滕王李元婴待过的地方，下属官员们都明白这个“潜规则”，会自觉把自己的妻子送到王府，供这位王爷玩乐，若是不送的，则免不了被李元婴无故刁难和诬陷。\n这位弄得“民怨沸腾”又“官怨沸腾”的贪败王爷，自然是皇帝最头疼的对象。唐太宗在位时期，对这位幺弟的各种混蛋行为往往是睁一只眼闭一只眼。唐高宗即位后，对这位小皇叔，或是当面警告，或是写信劝诫，实在没办法了，就一贬再贬，进行惩罚。先是贬到苏州，再到洪州（今江西南昌），后来又到隆州（今四川阆中），只是李元婴恶习不改，依旧我行我素，无法无天。\n虽然品行恶劣，但李元婴却有很高的艺术造诣，这自然与他从小的宫廷艺术熏陶有关。据说他“善画”，而且“工于蛱蝶”，由此留下了著名的“滕派蝶画”。除此之外，他还非常钟情于建筑艺术，每到一处就广邀天下的能工巧匠，大肆修建行宫、楼阁。永徽四年（653年），他选址赣江之滨，修起了一座高插云天的楼阁，这就是王勃笔下的滕王阁了，为后人的宝贵的历史文化遗产。转载自 百家好 --我爱读历史","tags":["历史故事"],"categories":["历史故事"]},{"title":"正则表达式","url":"/2017/11/正则表达式.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n# 正则表达式   就是个规则  是个对象\n\n\n__RegExp正则表达式的作用：匹配特殊字符或有特殊搭配原则的字符的最佳选择。__\n\n两种创建方法：直接量`var reg = /pattern/;`或者`var reg = new RegExp('pattern');`但是也可以不加new，但是这就相当于直接把RegExp('pattern')拷贝过来了。而且也可以在()里面添加一个已经设置好的正则规则。如：`reg = /abc/;  var reg1 = new RegExp(reg); `这个reg1就跟reg一样了。 __推荐用直接量。__\n\n\n**\\n换行**\n**\\r行节束缚**    windows系统上是他们两个的一起作用的,一个回车就相当于\\r\\n  lunix上只有一个换行符,也就是只有\\n\n\\t一个制表符，一个缩进，可以设置一个缩进等于几个空格\n\n__\\\\__ 转义字符的作用还有，如果你想打印或者使用特殊字符的话就在前面加上转义字符，让特殊符号回归成本来的意义。\n\n如果想写特殊的格式，多行字符串，就在字符串每一行的结尾加上转义的字符就行了。可如果是字符串的话在每一行的结尾加上+号也是可以的。比如：\n\n```\n<div></div>\nvar div = document.getElementsByTagName('div')[0];\ndiv.innerHTML = \"\\\n\t<div>\\\n\t\t<span>邓宝宝很萌</span>\\\n\t</div>\\\n\"\n```\n另一种：\n\n```\n<div></div>\n\tvar div = document.getElementsByTagName('div')[0];\n\tdiv.innerHTML = \"<div>\" +\n\t\t\t   \"<span>邓宝宝很萌</span>\" +\n\t\t\t\"</div>\";\n\n\nvar reg = /abcde/;\nvar str = \"123abcdeabcdeabcde\";\n```\n\nreg.test(str);判断str里面是否有abcde的字符串；返回值为true\nstr.match(reg);跟上面的方法正好相反。这是字符串上的方法，找字符串上符合正则表达式reg的方法。\n\n\n# **在后面加上i g m**\ni  表示忽略大小写ignoreCase;\ng  表示全局找符合条件的，但是不会识别特殊符的Globle,不加g的话匹配一个就停了。全局匹配。 \nm  表示可识别多行匹配了,match;  \n例如：多行匹配\n  `var reg = /^a/g\n  var str = \"abc\\nabc\";\n  str.match(reg);`   \n结果为一个a；但是第二个a也是符合条件的，想要第二个也匹配出来就要在后面添加一个m就能多行匹配了。查找开头为a 的话识别不了两个a，但是加上m就能识别了。\n\n`reg = /^a/` 就相当于一个开头是a的字符串规则。\n\n# []\n`var reg = /[abcd][bcde]/`  第一个里面就是查找符合第一位的条件的，[a-z]代表从a到z的字母。[^a-z]代表查找任何不在条件的字符。还可以[a-z0-9]里面写好几个条件的。[]是第一位满足什么条件，ASCII码  A 65； a 97；因为中间有26个字母之外还有一些特殊符号呢。eg：\n `var reg = /[^a-g][1-9]/g;\n var str = \"ah2dfsa\";\n str.match(reg);`\n结果为：h2；\n在[]里的^号是非的意思，就是取反的意思。\n\n\n# ()\n()在正则表达式中的意义：reg = /(abc|bcd)d/g;|代表或者的意思；()代表连着后面的条件的，可以代表和的意思。必须是abc或者bcd连着之后的d的满足条件的字符。\neg：\n`reg = /(abc|bcd)d/g;\nvar str = \"abcdbcdddsahf\";\n str.match(reg);`\n结果为：\"abcd\"  \"bcdd\";\n\n# 元字符：一些表达式的缩写形式；\n.   所有的都包括；[^\\r\\n];\n\\d  查找数字;就相当于[0-9];\n\\D  查找非数字；就相当于[^0-9];\n\\w  查找单词字符；word；就相当于[A-z0-9_]\n\\W  查找非单词字符；就相当于[^w]\n\\s  查找空白字符；代表一切空白；[\\t\\n\\f\\r\\v ]\n\\S  查找非空白字符；[^s]\n\\b  匹配单词边界；单词边界的意思；空格之后就是单词边界了；\n\\B  匹配非单词边界；非单词边界；\n\\O  查找NUL字符；\n\\n  查找换行符；\n\\f  查找换页符；\n\\r  查找回车符；\n\\t  查找制表符；\n\\v  查找垂直制表符；\n\\xxx    查找以八进制数xxx规定的字符；\n\\xdd    查找以十六进制dd规定的字符；\n\\uxxxx  查找以十六进制数xxxx规定的Unicode字符；\neg：\n`var reg = /[\\u5000-\\u6000]/g;\nvar str = \"邓宝宝\"；  邓u90df  宝u5d00\nstr.match(reg);`\n结果为：\"宝\"  \"宝\" ；\n\n\n\n# 贪心匹配原则：正则表达式能匹配多个就不匹配少个。\n\n**量词：**\nn+    匹配人格包含至少一个n的字符串；\nn*    匹配任何包含零个或多个n的字符串；\nn?    匹配任何包含零个或一个n的字符串；\nn{X}   匹配包含X个n的序列的字符串；\nn{X,Y}  匹配包含X至Y个n的序列的字符串；\nn{X,}   匹配包含至少X个b的序列的字符串；\nn$      匹配任何结尾为n的字符串；\n^n      匹配任何开头为n的字符串；\n?=n     匹配任何其后紧接指定字符串n的字符串；\n?!n     匹配任何其后没有紧接指定字符串n的字符串；\n\n`var reg = /^abc$/g;\nvar str = \"abcabc\"\nstr.match(reg);`\n\n返回结果：null;\n\n\n\n# 写一个正则表达式，检验字符串首尾是否含有数字？\n```\nvar reg = /(^\\d)|(\\d$)/gi;\nvar str = '123abc321';\nstr.match(reg);  或  reg.test(str);\n```\n返回结果为：true；\n\n# 写一个正则表达式，检验字符串首和尾是否含有数字？\n```\nvar reg = /^\\d[\\s\\S]*\\d$/g;   表达全集的方法有很多哦~\nvar str = \"123abc           \\n def321\";\nstr.match(reg);   或   reg.test(str);\n```\n\n\n\n# RegExp 对象上的一些属性：（reg.属性）\nglobal：  RegExp对象是否具有标志g。 返回值为：true或者false\nignoreCase:  RegExp对象是否具有标志i。\nlastIndex： 一个整数，标示开始下一次匹配的字符位置。\nmultiline： RegExp对象是否具有标志m。\nsource: 正则表达式的源文本。  能把本源打出来。\n\n# RegExp 对象上的方法：（reg.方法）\ncompile: 编译正则表达式。（没用）\nexec： 检索字符串中指定的值。返回找到的值，并确定其位置。execute执行CEO中的E。和str上的match方法有点儿相似。不加全局匹配g的话就完全一样了。加上g才上这个方法的实际用处。这个方法使用时重复调用一次一次匹配才能体现出来哦~  内部能够识别游标的位置。reg.lastIndex 就是游标的位置，输出结果就是当前游标的位置。这个方法就是给exec这个方法用的。可以手动改游标的位置。必须有全局匹配g。没有g游标不会动的。\n\n`var reg = /a/g;\nvar str = \"ababab\";\nconsole.log(reg.exec(str));`\n结果为:[\"a\", index: 0, input: \"ababab\"]\n`console.log(reg.lastIndex); `输出当前游标位置；\n结果为：1\n`console.log(reg.exec(str));`\n结果为:[\"a\", index: 2, input: \"ababab\"]\nconsole.log(reg.lastIndex); 输出当前游标位置；\n结果为：3\n`console.log(reg.exec(str));`\n结果为:[\"a\", index: 4, input: \"ababab\"]\n`console.log(reg.lastIndex); `输出当前游标位置；\n结果为：5\n\n__test：__ 检索字符串中指定的值。返回true 或 false。\n\n\n\n\n# 支持正则表达式的String对象上的方法：（str.方法）\nsearch： 检索与正则表达式相匹配的值。查找位置的方法，返回的是调用该方法的位置，没有的话返回-1。\n`var reg = /abc/g;\nvar str = \"123abcd\";\nstr.search(reg);`\n\n# ()----->  子表达式\n`var reg = /abc(d)/g;`  能把子表达式中记录的内容通过match的方法返回出来；\n`var str = \"123abcd\";`\n`console.log(str.match(reg))`打印出来的结果比在控制台里调试str.match(reg)\n的结果要多一点儿(多了满足条件是光标的索引，也就是search方法，还有就是str全部的信息)。因为console会返回这个类数组的全部信息。`str.match(reg)`只是返回这个方法的实际结果。\n这个返回的结果中就包括有子表达式的内容。\n**match： 找到一个或多个正则表达式的匹配。**\n\n**replace： 替换与正则表达式匹配的子串。**\n\n`var str = \"xyyx\";\nstr.replace('x', 'a');`\n这个是把字符串中的第一个x替换成a；不过改变的不是原来的字符串哦~ 因为原来的字符串是原始值，任何原始值都是不可改变的，这里又用到了包装类的知识点哦~系统内部隐式创建一个字符串但是用完就删除了，没有了，找不到了。这里的话只能通过console.log(str.replace('x', 'a'))查看这个方法。结果为：ayyx。那这么说的话这个方法还有用处吗？有用啊，可以var一个变量保存啊。匹配的只有一个哦~这里没有全局匹配的功能，没有加g的功能。想要全变了，可以用正则表达式写console.log(str.replace(/x/g, 'a'));结果为：ayya。\n\n# 写一个正则表达式把原来的 xxyy 形式的 对调过来成为 yyxx的形式。\n`var reg = /(\\w)\\1(\\w)\\2/g;`\n`var str = \"123aabb321\";`\n`console.log(str.replace(reg, '$2$2$1$1'));`\n结果为: \"123bbaa321\"\n这里的$1代表的就是第一个子表达式引用到的内容，$2就是第二个子表达式引用到的内容。单独$什么也不是哦~   第二个参数还能填一个函数，例如：`console.log(str.replace(reg, function($, $1, $2){}))`，系统怕单纯的正则不够你用所以就给你用函数来调用满足一些复杂的要求，所以这个函数最后返回的一定还是一个字符串，系统内部给你写好了传的参数，你直接传进去就行。function中的参数第一个用$代替一下，是正则表达式匹配到的整体内容。第二个参数$1就是第一个子表达式的内容，$2就是第二个子表达式的内容。\n\n# 把命名的名称改成小驼峰式写法；\n`var str = \"the-first-name\";\nvar reg = /-(\\w)/g;\nconsole.log(str.replace(reg, function ($, $1) {\n  return $1.toUpperCase();\n}));`\n打印结果为：theFirstName;\n\n\n\n写出一个正则表达式满足xxyy形式的方法：这个时候必须用到子表达式了。(\\w)\\1 这个是第一个位置的子表达式，代表的意义就是对第一个字子表达式的重复引用。(\\w)\\2 这个是第二个位置的子表达式，代表的意义就是对第二个子表达式的重复引用。所以xxyy形式的正则表达式形式如下：\n`var reg = /(\\w)\\1(\\w)\\2/g;\nvar str = \"aabbccdddddddd\";\nstr.match(reg);`\n控制台打印结果：(3)[\"aabb\", \"ccdd\", \"dddd\"];从当前光标所在位置继续查找下一位的。\n\n写出一个正则表达式满足 xyyx 的形式。\n`var reg = /(\\w)(\\w)\\2\\1/g;\nvar str = \"abbabccd\";\nconsole.log(str.match(reg));`\n控制台打印结果为：(2)[\"abba\"];  看清楚了小伙子~\n\n`var reg = /(\\w)(\\w)\\2\\1\\2\\1/g;\nvar str = \"abbabadeeded\";\nconsole.log(str.match(reg));`\n控制台打印结果为：(2)[\"abbaba\", \"deeded\"];\n\n\n# 一对方法来回转换：\n 字符串上的方法：\nsplit('-'):  把字符串分割为字符串数组。默认是逗号。\n\n 数组上的方法：\njoin('-'): 把数组中的每一项的值按照所给定的符号分成字符串。默认是逗号。","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"框架","url":"/2017/11/框架.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n## React\nreact:是Facebook开发的一款JS框架。\n传统页面从服务器获取数据，显示到浏览器上，用户输入数据传入服务器的时候，随着数据量大增大，越来越难以维护。Facebook认为MVC无法满足他们的扩展需求，由于他们非常巨大的代码库和庞大的组织，使得MVC很快变得非常复杂，每当需要添加一项新的功能或特性时，系统的复杂度就成级数增长，只是代码变得催乳和不可预测，结果导致他们的MVC正在土崩瓦解。认为MVC不适合大规模应用，当系统中有很多的模型和相应的视图时，其复杂度就会迅速扩大，非常难以理解和调试。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["框架"],"categories":["个人随笔"]},{"title":"杂记","url":"/2017/11/杂.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n减肥就等于健康，健康不只是你一个人的事情，你的健康对你的家人的影响有时候要远远大于对你自身的影响。所以从现在做起就好好的对自己的健康负责吧！\n\n认识到人的身体更适应最原始的食物，比如说：水果、绿色蔬菜、豆类、种子、鸡蛋、海产品、纯奶制品等等；而不是随后产生的食物，比如说：谷物、过量喂食的动物产生的肉和化学加工食物等等。\n\n为什么要减肥：现代社会流行的肥胖、糖尿病和阳痿等问题说明了。今天人类已经违背了人类发展的自然规律。\n\n减肥必须要养成良好的作息规律：最最重要的是-->我们需要生活周期，这个包括行动和不行动，比如说：清醒和睡眠，警觉和放松，运动和休息，少量饮食和过量饮食，任何因为不断的压力和长期不断的进食（一天进食多次）产生的周期破坏，都会给人类身体的适应生存的能力和表现产生不利的影响。\n总之，如今人类健康每况愈下，主要是因为：\n1. 每天吃太多的顿数\n2. 不饿的时候也要吃\n3. 吃不应该吃的食物\n4. 在运动和休息之间无法平衡\n5. 对环境和食物供应变化的适应能力较差\n\n\n## 勇士减肥法：\n勇士减肥法：勇士减肥法是一个三周减肥方案，为了达成个人的减肥目标而特别设定的如下三个步骤：\n第一步：排毒期，改善身体的排毒的能力，从而帮助肝脏中和那些引起增肥的物质。\n第二步：适应脂肪燃料期，改进身体，利用脂肪作为能量来源的能力。\n第三步：适应碳水燃料期，改进身体，利用碳水作为能量的能力。\n这三步将帮助你，改进你的新陈代谢能力，让你的身体燃脂能力产生质的飞跃。\n这个方案通过每个阶段不同的饮食方案，指导减肥者启动身体的生存模式，迫使身体去适应和改进利用【碳水和脂肪】燃烧的能力，重建细胞组织，燃烧脂肪和抵抗压力，从而变得更加强壮，更精瘦，更坚韧，这只要通过几个【限制吃】和【放开吃】循环来控制。\n\n【限制吃】：基于轻断食原理，这个部分在白天（工作时间）执行，要求你进食最少的食物，集中精力避免每次摄入过多的食物，同时也要满足自己的饥饿感，这个部分，你应该吃新鲜的蔬菜和水果，沙拉和一些蛋白质（参考后面的周饮食计划明细）\n\n【放开吃】：基于“饮食规则”（见后面），这个部分给你足够的自由，让你想吃多少就吃多少，可以吃各种不同口味的食物，但是要知道自己主动停止进食，或者当你感觉到非常舒服的被满足之后，或者当你的饥渴大于饥饿的时候。\n\n这个方法的原则非常简单明了，这可以作为你一生的饮食方式，你可以根据自己的情况，在这三个步骤中不断的循环，这样你可以吃到你喜欢的食物，同时，你也可以平衡你的新陈代谢，轻松甩掉你的脂肪。\n\n达到的效果：\n你不断的燃脂，脂肪不会再生\n你活力四射\n你思维更加敏捷\n你能完成更多的工作\n自我感觉更加良好\n看起来更有自信，更加好\n生活对你就像一场让人兴奋的挑战\n\n\n## 勇士饮食法则：\n1. 一开始摄入精致美味的食物，比如沙拉、蔬菜、蛋白质，然后摄入高能食物，比如说碳水化合物。\n2. 在你的正餐中，你可以享用所有你喜欢的口味，风味，口感，颜色的食物。\n3. 如果你感觉你更渴了（相对于你的饥饿感），停止进食。\n\n注意点：\n.推荐你在吃完一部分正餐之后，休息二十分钟，给自己足够的时间来接受饱腹感的信号，如果20分钟后，你还感觉到饥饿，你可以继续吃。\n.尽量选择有机食品，特别是牛奶和肉类，避免毒素，化工品和杀虫剂，这些对于减肥和健康都不利。\n\n勇士减肥法，十条法令：\n1. 白天限制进食\n2. 晚上吃正餐\n3. 摄入必要的营养物质（维他命、矿物质、EFA、氨基酸、益生菌）\n4. 在你的正餐中，你可以享用所有你喜欢的口味，风味，口感，颜色的食物\n5. 前几天，限制动物类食物，排毒\n6. 高蛋白，高脂肪，高碳水，循环\n7. 尽量避免，激素类、杀虫剂、化学添加剂、糖精、代糖、加工葡萄糖等\n8. 不要单独吃碳水\n9. 避免下列错误的食物组合：（1）谷物和糖（2）淀粉、脂肪和糖（3）坚果和谷物（4）碳水和酒精\n10. 给你的身体氨基酸，比如说肉毒碱，半胱氨酸，牛磺酸等\n\n# 具体的饮食计划部分：\n第一步：排毒\n第一步的主要目的是身体排毒，为了以后的消脂最大化。\n第一周，你将减少动物类食物，除了一些奶制品和鸡蛋外。\n白天：限制吃\n从你起床后就开始到最后晚餐结束，可以根据你自己的作息时间调整，比如说，你5:00点起床，你会睡得很早，你可以根据自己的时间设计自己的一天饮食。\n\n一天综述：\n白天【限制吃】期间，不要吃动物蛋白（肉类，鱼类），可以适当吃一些水果，蔬菜，一点点奶制品，也可以吃水煮的熟鸡蛋。\n\n注意：【限制吃】不代表要进入饥饿状态，你可以每一个小时都吃一些可以吃的食物，不要让你的身体觉得你在剥夺他进食的权利。\n\n早上：1-2杯室温的水，1个水果（后面有水果清单）咖啡/茶（无糖、可以加点奶）\n上午：1个水果，或者鲜榨果蔬汁（胡萝卜汁，胡萝卜甜菜，欧芹，芹菜混合汁，原味酸奶，水煮鸡蛋，牛奶，意大利乳清干奶酪或干酪）\n中午：清汤一碗，沙拉（绿叶蔬菜，西红柿，辣椒，洋葱，黄瓜，蘑菇，豆芽等）、煮熟的鸡蛋（可选）、沙拉调味品：橄榄油，醋（一丢丢，不要白醋）\n下午茶：酸奶或牛奶或胡萝卜汁或水果\n\n提示：任何时候你都可以用水果代替沙拉，清汤和鸡蛋。\n\n晚上【放开吃】\n晚餐（正餐）：沙拉（必须先吃），沙拉调味品：橄榄油，醋（一丢丢）\n蒸熟的蔬菜（很多的西兰花，菜花，小洋白菜，西葫芦，胡萝卜，秋葵，蘑菇，菠菜，洋葱）\n\n豆类（主要蛋白质来源） 推荐小扁豆，绿豆，黑豆，四季豆，鹰嘴豆，毛豆\n谷物（主要碳水来源） 推荐菰米，黑米，大麦，藜麦，此阶段不要吃小麦。\n你也可以用一种鹰嘴豆泥和芝麻酱的混合物。\n\n注意：全麦和豆类的比例是1:1；\n你也可以加各种芝士，酸奶或者鸡蛋。\n喝点咖啡和茶没有关系，可以适当加点奶\n推荐你在吃完一部分正餐之后，休息二十分钟，给自己足够的时间来接受饱腹感的信号，如果而是分钟后，你还感觉到饥饿，你可以继续吃。\n\n\n第一周禁止进食所有的糖类食物，可以用日常补剂（后面有补剂清单）\n运动员最好在锻炼后，是加上恢复餐，比如说酸奶和香蕉，勇士能量棒，或者牛奶。","tags":["杂"],"categories":["个人随笔"]},{"title":"有感而记","url":"/2017/11/有感而记.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n## 个人随笔：\n突然想到当下的中国，我们这一代人真的是太幸福了，刚才看了《美国最可恨的女人》这部电影，看到了真实的一个美国女人，作为一个五六十年代的无神论者，就那么单枪匹马的与全世界为敌，而且那么的不幸运，一辈子也没有遇见的自己的另一半，在自己毕业之后先后遇见了两次渣男，并且都怀了一次孕，虽然父母也不支持自己生下来这两个孩子，但是她还是毅然决然的生下来了两个儿子，完全没有顾忌自己的糟糕的状况。当时的美国的默认国教就是基督教。因为美国是政教分离的政策，大多数人都是信仰基督教，还有剩下的少部分人是信仰的伊斯兰教，但归根结底的这些教徒都是信仰上帝的存在的。就连历任的美国总统都是说的是愿上帝保护美国！所以美国的民众怎么可以忍受的了别人所说的没有上帝的存在呢？她还是一个有着高学历的法律专业毕业的高材生，她明明可以不管不顾的做一个睁一只眼闭一只眼生活的普通女性，但是她没有，她说既然没有人发声，为什么不能是我呢？她没有作为一个碌碌无为的旁观者，而是站起来并且站在了最显眼的地方，发出了自己的声音，她知道她这样做会带来什么样的后果，但是她还是做了！我为这样一个敢于追求自己心中所发出的声音而奋斗的女性致敬。虽然她在发声之后就成立一个无神论协会，并且在成立协会之后就开始了自己的一点儿小私心，以帮助弱者的名义把募集到的资金占为己有。但是这样更加的体现了作为一个女性作为一个普通人，人性中的弱点，更加的真实了。总之，我很羡慕这样一个坚强的女性，不畏强权，敢于发出自己的声音的这种精神，并且用自己的血肉之躯面对整个国家的力量也丝毫不退缩的勇气。\n\n\n优秀的人真是太多太多了，最可恨的是他们还非常的努力！你还能继续忍下去吗？你再不努力奔跑，那你以后怎么孝敬父母，怎么给你爱的人幸福呢？没有伞的孩子必须努力奔跑！加油吧！你不聪明，你也没有后台，你只有靠着你自己的努力一点一点的积累吧！没有什么事情是可以一步就完成的，不积跬步无以至千里，不积小流无以成江河！从现在就开始认真的做每一件事情吧！好吗？\n树欲静而风不止，子欲养而亲不待！在这个最应该奋斗的年纪，如果堕落了，在本该奋斗的时间你用来休养生息了，那么就算父母有时间等你来孝敬，你有什么本事、你有什么能力、你拿什么东西来孝敬生你养你为你付出一切的父母呢？你啊，老大不小了，这些事情不需要别人非要来说给你听你才知道吧？你从高中第一次毕业没考上一所满意的高等学校的时候就应该很清楚的吧！现在你都大三、马上就要大四了，中间四年多过去了，你自己想想你在这些年里干了些什么有意义的事情呢？舒舒坦坦的过了这么些年也该为自己之后的人生规划一下了吧。记住不要成为别人眼中的失败者，不要成为别人口中的无用之人，更不要成为自己看不起的那类人，不要成为连自己都讨厌的人。努力吧！少年！\n父母望子成龙，爷爷奶奶希望自己的孩子们幸福快乐，但是谁也帮不了你，只有你自己能救你自己啊，为了家人的寄望、为了亲人的盼望，千万不要成为一个无知、傲慢、懒惰、虚荣、嫉妒、懦弱的失败者！\n既然目标是那遥远的地平线，就只顾风雨兼程！奔跑吧!摔倒了也要咬紧牙继续前行，记住你的前行路上没有人能扶你一把，没有人能拉你一下，没有人会给你帮助，就算你的腿瘸了，你也只能靠自己踉跄前行！","tags":["影视人生"],"categories":["个人随笔"]},{"title":"从星巴克的商业模式中看出几个问题","url":"/2017/11/星巴克.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n# 天下熙熙，皆为利来；天下攘攘，皆为利往。\n最近这几天看到好几条关于星巴克的新闻。讲的是星巴克一年买出40亿+的咖啡，最后的咖啡纸杯的去向，你知道吗？出于好奇，我点开看了看这条向我的手机推送的新闻，点开之后本来想着匆匆浏览一遍就好，但是看了开头就把我的兴趣给提了起来，越看越有趣。给大家一个链接，想看的可以去看看哈~但是我觉得有趣并不能保证你看后也觉得有趣啊~[星巴克40亿纸杯背后](http://36kr.com/p/5097923.html)\n这篇新闻中让我动容的不是星巴克的不作为和为了利益不择手段的做法。而是一些人们为了保护环境而自发的组织在一起，并且为了让星巴克减少污染环境而做出的种种努力！他们其中有的人专门为星巴克做了详细的纸杯新材料的设计和开发并且考虑到了与星巴克原先纸杯的经济对比问题，怕的就是星巴克不采取他们的这种最环保的纸杯材料的建议。还有一些人是星巴克的管理层，他们为了地球的环保事业而加入星巴克的环保部门，他们在星巴克的发展历程中发挥了及其重要的作用，但是当他们知道了他们并不能促使星巴克最高领导层接受他们使用最新环保材料纸杯时，毅然决然的选择辞去星巴克中高层管理者的职位。我看到的是这些人发光的目标或者说是崇高的信仰，他们追求的或许在有些人看来是不可思议的，但是我觉得这才是真正的为了自己的追求而不惜付出巨大代价的牺牲精神。\n也许再过十几年或者用不了这么长的时间，我们自己的国家也会有一群这样的人，他们不会为了自己的利益而做出什么苟且之事，他们胸中含着崇高的社会使命感，高度的社会责任意识，到那个时候，我相信我们的社会一定会变得更加美好。\n# 公司的管理层\n我想到了吴晓波收集资料总结出来的《大败局》中说到的，中国式企业家，当然了，大败局中总结的是中国改革开放早期到21世纪初的优秀企业家们，他总结到，这些企业家们在处理个人事情和与人交往上，表现出的高情商和高素质让人印象深刻，一点儿都没有那种盛气凌人的气势和让人感到不自如的时候，他们是让人在他们面前很轻松。但是他们在企业活动中所表现出来的雷厉风行和铁血无情也是让别的企业胆寒心颤啊！这种在不同的情景下的两种状态让人感到陌生的同时也让人反思，难道企业家都是这样的吗？不是的，那时的中国的企业发展环境造就了他们这种企业家；那个时候是中国企业发展的黄金期，一个企业家的领头人有多大的胆子有多大，那这个企业的发展规模就能到哪一步！在企业经营中的铁血无情体现的让人心惊胆颤。\n回过头再来看看国外的企业家是什么样子的，他们或许也是为了利益会动用铁血手段，但是他们有商业的底线。污染地球的环境对他们来说就是不可接受的底线之一了。从这儿看来我们中国的企业家还有很多的路要走啊。\n# 公司发展\n大公司都是由小公司发展起来的，在小公司发展之初，人们都不会怎么关注的。而一旦小公司过了一个发展高峰并且成长为一个业界的领导者的时候，进入公众的目光之中，那么这个公司高层所做的一切决定都会暴露在大庭广众之下，必须要能受得住人们的指指点点，决不能有特别大的背离道德方面的商业活动，一个公司的企业形象可能就会因为一个小小的道德问题而崩塌，到时候那这个公司不论体量如何，都会成为人们所唾骂的对象，不得不说的是，人们是非常喜欢传一些风言风语的，绯闻，小道消息等等都是人们所感兴趣的内容，一旦你公司的一个决定成为了带有负面信息的内容，那么你就要接受群众们对你的唾骂挑战。而这个时候及时迅速的管理公关活动可能就相当的重要了，必须及时控制住时态的发展，采用有利的公关活动挽留公司形象的崩塌。\n# 一个商人必须要有坚持的东西--即商业底线\n一个唯利是图的商人是走不远的，看如今的大公司的领头人，无一不是在乎当下的蝇头小利之人，他们都有长远的规划，立足高远才能预测更长远的路径。追求高远才能长存的道理，人们都懂。但是实施起来的难度并没有几个人知道，而且在看得见的利益面前，能忍受的了的人更是所剩无几，一般人们都会被当下的蝇头小利所迷惑，走不了太长远；当得到了当下的小利润时，都会自满而忘记了前进的步伐，被竞争者迎头追上并且打压的好恶还手之力。所以一个优秀的企业家必须要懂得克制，不能只顾眼前的利润，而要从长远来看，追求要高远，这样企业才能长存。底线对一个企业家来说更是如此，不能为了当下的目标而不择手段的截取用户的价值，毫无底线的企业总是失败的最彻底的企业。就算侥幸存活下来，也是让同行的小企业看不起的，自然也是逃脱不掉被淘汰的结局。\n","tags":["商业问题"],"categories":["个人感悟"]},{"title":"后端网络笔记","url":"/2017/11/后端网络笔记.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n## Ajax\n\n浏览器也就是客户端，在浏览器中输入网址（URL）。浏览器会从输入的网址找相应的地址，而网站中所有存在的数据都在服务器中存着的。所以上网其实也就是从服务器中请求资源的过程，当然了具体的肯定不会这么简单的。\n在网上搜索 萨德 。就会在网址的URL上出现wd=萨德的字样。\n注册一个账号，账号就保存在每个对应公司的数据库。百度的就是百度的数据库。你用手机号注册新账号的时候，就会去公司的数据库里面查找看一下数据库里面有没有这个手机号，这就是数据交互的过程。\n\n浏览器-->服务器-->数据库       三位一体才形成了一体的系统。\n\nAjax的发展史：是因为谷歌地图的横空出世造就了Ajax，不用刷新页面，这是因为异步，请求资源和数据交互同时进行，所以交互体验更加的好了。\n\n\n客户端向服务器发送一个请求，服务器端回应的叫响应。传统的是服务器直接返回整个页面；在Ajax模型中，数据在客户端与服务器之间独立传输，服务器不在返回整个页面。\n```      \n<form action='地址' method='方法'>\n  <input type='test' name='usrename'>\n  <input type='password' name='password'>\n  <input type='submit' value='提交'>\n\n通过get方法点击提交按钮 浏览器就会在URL上返回这个数据，也就是地址栏，所以这个传递数据的大小也就有限制了，但是post方法返回的数据不会再地址栏上所以传递数据的大小就比get方法大好多了，大约为4k左右。传递文件类型的需要设input的type='file';还有form表单的值enctype='multipart/form-data\n\n</form>\n```\n用JavaScript以异步的形式操作xml（现在操作的是json格式的，名值对的形式） 所以以前就叫Ajax（Asynchronous javascript and xml）\n\nAjax不阻塞页面，体验好。\n\nAjax对象上的方法：\nabort()  停止当前请求\nopen(\"method\",\"url\",true)  建立对服务器的调用\nsend(content)  向服务器发送请求\ngetAllResponseHeaders()  把http请求的所有响应首部作为健/值对返回\ngetResponseHeaders(\"headerLabel\")  返回值指定首部的串值\nsetRequestHeader(\"label\",\"value\")  把指定首部设置为所提供的值。在设置任何首部之前必须先调用open();\n\nAjax对象上的属性：\nonreadystatechange 状态改变的事件触发器,事件监听\nreadyState   对象状态（integer）值是数字类型的 0=未初始化 1=读取中 2=已读取 3=交互中 4=完成\nstatus   服务器返回的状态码，如：404=“文件未找到”、200=“成功” 500=“服务器内部错误” 304=“资源未被修改”\nresponseText  服务器进程返回数据的文本版本\nresponseXML  服务器进程返回数据的兼容DOM的XML文档对象\nstatusText  服务器返回的状态文本信息\n      \n封装一个属于我们的Ajax： \n`var ajax = null;\nif(window.XMLHttpRequest) {\n  ajax = new XMLHttpRequest;\n}else {\n  ajax = new ActiveXObject('Microsoft.XMLHttp');\n}\najax.open('method','getNews.php','true');\n\najax.send();\najax.onreadystatechange = function() {\n  if(ajax.readyState == 4) {\n  if(ajax.status == 200) {\n    ajax.responseText \n  }\n  }\n}`\n      \n      \n封装Ajax：\n```\nfunction Ajax(method, url, flag, data, callBack) {\n  var app = null;\n  if(window.XMLHttpRequest) {\n    app = new XMLHttpRequest;\n  }else {\n    app = new ActiveXObject('Microsoft.XMLHttp');\n  }\n  var method = method.toUpperCase();\n  if(method == 'GET') {\n    app.open('method', url + '?' + data, flag);\n    app.send();\n  }else if(method == 'POST') {\n    app.open(method, url, flag);\n    app.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n    app.send(data);\n  }\n  app.onreadystatechange = function() {\n    if(app.readyState == 4) {\n  if(app.status == 200) {\n    callBack(app.responseText);\n  }\n    }\n  }\n}\n```","tags":["后端"],"categories":["学习笔记"]},{"title":"前端基础题总结","url":"/2017/11/前端基础题总结.html","content":"**{{title}}** <Excerpt in index | 首页摘要>\n\n### 1. 行内元素和快级元素\ninline： `<span></span>,<strong></strong>,<em></em>,<a></a>,<del></del>`;\nblock:  `<p></p>,<ol></ol>,<li></li>,<ul></ul>,<div></div>,<form></form>,<adress></adress><table></table><h1-6>`;\n行内元素转化为块级元素：display : block;\n\n### 2. css代码三中引入方式：\n\t行间样式\n\t页面级css\n\t引入css文件 link\n\tstyle标签下写 @import url();\n\n### 3. web标准：行为、样式、结构相分离\n\n### 4. 简化代码：\n\n```<style type=\"text/css\">\n\t*{\n\t\tmargin: 0 10px;\n\t\tpadding: 0;\n\t}\n\t#content{\n\t\tbackground:#ffffff;\n\t}\n\t#content div{\n\t\tfont-size: 14px;\n\t\ttext-align: center;\n\t\tcolor: #e9e9e9;\n\t}\n\t#nav{\n\t\tbackground-color: #e0e0e0;\n\t}\n</style>```\n\n### 5. 浏览器中margin默认值为8px；\n\n### 6. 盒模型的计算：\n\n```<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>liangxi</title>\n\t\t<style>\n\t\tbody{\n\t\t\tpadding: 0;\n\t\t\tmargin: 0;\n\t\t}\n\t\t#my-defined{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tpadding: 0 100px;\n\t\t\tmargin: 10px 20px 30px 40px;\n\t\t\tborder: 1px solid orange;\n\t\t\tbackground: orange;\n\t\t}\n\t</style>\n\t</head>\n\t<body>\n\t\t<div id=\"my-defined\"></div>\n\t</body>\n</html>```\nhtml中orange颜色的区域宽度是302px\norange区域距离页面左边40px，上10px\n\n### 7. 用css、html编写一个两列布局的页面，要求右侧宽度为200px；左侧自动扩展。\n\n```<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>liangxi</title>\n\t<style>\n\t.right{\n\t\tfloat: right;\n\t\twidth: 200px;\n\t\theight: 100px;\n\t\tbackground:red; \n\t}\n\t.left{\n\t\theight: 100px;\n\t\tmargin-right: 200px;\n\t\tbackground: black;\n\t}\n\t</style>\n</head>\n<body>\n\t<div class=\"right\"></div>\n\t<div class=\"left\"></div>\n</body>\n</html>```\n\n### 8. 居中一个浮动元素：\n\n<div class='wrap'>\n\t<div id='my-defined'></div>\n</div>\n\n```<style type=\"text/css\">\n\t<!-- 第一种方法： -->\n\t.wrap {\n\t\tposition: relative;\n\t\theight: 1000px;\n\t\twidth: 100%;\n\t}\n\t.wrap #my-defined{\n\t\tposition: absolute;\n\t\twidth: 300px;\n\t\theight: 500px;\n\t\tleft: 50%;\n\t\tright: 50%;\n\t\tmargin-left: -150px;\n\t\tmargin-top: -250px;\n\t\tbackground-color: #ccc;\n\t}\n\t<!-- 第二种方法： -->\n\t.wrap{\n\t\tposition: relative;\n\t\theight: 1000px;\n\t\twidth: 100%;\n\t}\n\t.wrap #my-defined{\n\t\tposition: absolute;\n\t\twidth: 300px;\n\t\theight: 500px;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground-color: #ccc;\n\t}\n\t<!-- 第三种方法： -->\n\t.wrap{\n\t\tdisplay: flex;\n\t\twidth: 100%;\n\t\theight: 1000px;\n\t\tjustify-content: center;\n\t\talign-items: center;\n\t}\n\t.wrap #my-defined{\n\t\theight: 500px;\n\t\twidth: 300px;\n\t\tbackground-color: #ccc;\t\t\n\t}\n\t<!-- 第四种方法： -->\n\t.wrap{\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 1000px;\n\t}\n\t.wrap #my-defined{\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\tbottom: 0;\n\t\tright: 0;\n\t\tmargin: auto;\n\t\tbackground-color: #ccc;\n\t}\n</style>```\n\n### 9. 画出下图示意图：\n\n```\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>liangxi</title>\n\t\t<style>\n\t\t\t#page{\n\t\t\t\twidth: 520px;\n\t\t\t}\n\t\t\t.nav{\n\t\t\t\twidth:200px;\n\t\t\t\tfloat: right;\n\t\t\t\tbackground: orange;\n\t\t\t}\n\t\t\t.main{\n\t\t\t\twidth: 200px;\n\t\t\t\tfloat: left;\n\t\t\t\tpadding-left: 110px;\n\t\t\t\tbackground: black;\n\t\t\t}\n\t\t\t.sub{\n\t\t\t\twidth: 100px;\n\t\t\t\tfloat: left;\n\t\t\t\tmargin:10px 0 10px -100px;\n\t\t\t}\n\t\t\t.nav,.sub{\n\t\t\t\tborder: 10px deshed #000;\n\t\t\t\theight: 300px;\n\t\t\t\tbackground: orange;\n\n\t\t\t}\n\t\t\t.sub{\n\t\t\t\theight: 280px;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div id=\"page\">\n\t\t\t<div class=\"main\"><div class=\"sub\"></div></div>\n\t\t\t<div class=\"nav\"></div>\n\t\t</div>\n\t</body>\n</html>\n```\n\n### 10. form表单中method属性值及其区别：\n\tGET 使用URL 或Cookie 传参，而POST将数据，放在BODY中。\n\tGET 的URL会有长度上的限制， POST可以传输很多数据。\n\tPOST比GET安全。\n但其实HTTP协议里没有规定POST数据就要放在BODY里， 也没有要求GET数据就一定要放在URL中而不能放在BODY中。\nHTTP协议对GET和POST 都没有对数据的长度进行限制，两方面原因造成数据限制的原因\n\t早起浏览器会对URL长度进行限制（浏览器URL输入框）\n\t浏览器会对Content-length进行限制，这是为了服务器安全和稳定。\n\n### 11. 去掉ul>li结构中前面的圆点，并且解决li前面的空余\n\n```\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>liangxi</title>\n\t<style>\n\t\t\tul {\n\t\t\theight: 100px;\n\t\t\tpadding: 0;\n\t\t\tlist-style: none;\n\t\t\tborder: 1px solid black;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<ul><li></li></ul>\n</body>\n</html>\n```\n\n### 12. JavaScript中typeof可能返回的结果：number,string,boolean,object,undefined,function,symbol;\n\n### 13. 已知数组var arr = [\"goole\",\"microsoft\",\"oracle\",\"阿里\"，\"freewheel\",\"IBM\",\"爱立信\"，\"百度\"，\"企鹅\"，\"美团\"，\"去哪儿\"，\"58同城\"，\"新浪\"，\"搜狐\"，\"大众点评\"，\"360\",\"汽车之家\"，\"巨人网络\"，\"携程\"，\"4399\",\"凤凰网\"，\"人民网\"]，亲们，如果你想进前十的公司，请用效率最高的方法将此数组按照顺序链接成字符。\n\n`<script type=\"text/javascript\">\n\tvar arr = [\"goole\",\"microsoft\",\"oracle\",\"阿里\",\"freewheel\",\"IBM\",\"爱立信\",\"百度\",\"企鹅\",\"美团\",\"去哪儿\",\"58同城\",\"新浪\",\"搜狐\",\"大众点评\",\"360\",\"汽车之家\",\"巨人网络\",\"携程\",\"4399\",\"凤凰网\",\"人民网\"];\n\tconsole.log(arr.join(','));\n</script>`\n\n### 14. 写出html、css、JavaScript注释代码形式：\n\thtml：<!--   -->\n\tcss:/*   */\n\tjs://\n\n### 15. 编写一段JavaScript脚生成下面这段DOM结构。\n\n`<div class=\"exmple\">\n\t<p class=\"slogan\">成哥，你最帅!</p>\n</div>`\n\nJS代码如下：\n\n`<script type=\"text/javascript\">\n\tvar $Div = document.createElement('div');\n\tvar $P = document.createElement('p');\n\t$Div.className = \"exmple\";\n\t$P.className = \"slogan\";\n\t$Div.appendChild($P);\n\tdocument.body.appendChild($div);\n\t$P.innerHTML = \"成哥，你最帅！\";\n</script>`\n\n### 16. 为html元素绑定一个事件，如点击事件。写出兼容各个浏览器的事件绑定方法。\n\n`<script type=\"text/javascript\">\n\t<!-- 兼容各个浏览器的绑定事件： -->\n\tfunction addEvent(elem, type, handle){\n\t\tif(elem.addEventListener){\n\t\t\telem.addEventListener(type, handle, false);\n\t\t}else if (elem.attachEvent) {\n\t\t\telem['temp' + type + handle] = handle;\n\t\t\telem[type + handle]= function (){\n\t\t\t\telem['temp' + type + handle].call(elem);\n\t\t\t};\n\t\t\telem.attachEvent('on' + type, elem[type + handle])\n\t\t}else{\n\t\t\telem['on'+type]=handle;\n\t\t}\n\t}\n\t<!-- 兼容各个浏览器的一处绑定事件： -->\n\tfunction removeEvent(elem, type, handle){\n\t\tif(elem.removeEventListener) {\n\t\t\telem.removeEventListener(type, handle, false);\n\t\t}else if(elem.detachEvent) {\n\t\t\telem.datachEvent(‘on’ + type, elem[type + handle]);\n\t\t}else {\n\t\t\telem[‘on’ + type] = null; //  elem[‘on’ + type] = false;\n\t\t}\n\t}\n</script>`\n\n第二种方法：\n\n`<script type=\"text/javascript\">\n\tfunction addEvent(elem, type, handle){\n\t\tif(elem.addEventListener){\n\t\t\telem.addEventListener(type, handle, false);\n\t\t}else if (elem.attachEvent) {\n\t\t\telem[handle.name] = function () {\n\t\t\t\thandle.call(elem);\n\t\t\t};\n\t\t\telem.attachEvent('on' + type, elem[handle.name]);\n\t\t}else{\n\t\t\telem['on'+type]=handle;\n\t\t}\n\t}\n\t<!-- 兼容各个浏览器的移除绑定事件： -->\n\tfunction removeEvent(elem, type, handle){\n\t\tif(elem.removeEventListener) {\n\t\t\telem.removeEventListener(type, handle, false);\n\t\t}else if(elem.detachEvent) {\n\t\t\telem.datachEvent(‘on’ + type, elem[handle.name]);\n\t\t}else {\n\t\t\telem[‘on’ + type] = null; //  elem[‘on’ + type] = false;\n\t\t}\n\t}\n</script>`\n\n### 17. Call,apply:作用都是改变this指向；\n区别：传参的方式不同，call直接传，apply利用数组的形式传参；\n\n### 18. 封装ajax,向服务器异步发送数据；\n\n`<script type=\"text/javascript\">\n\tfunction ajax(method, url, flag, callback, data){\n\t\tvar xhr = null;\n\t\tif(window.XMLHttpRequest){\n\t\t\txhr = new window.XMLHttpRequest();\n\t\t}else{\n\t\t\txhr = new ActiveXObject('Mirosoft.XMLHTTP');\n\t\t}\n\t\tvar method = method.toUpperCase();  //对应的是toLowerCase()方法;\n\t\tif(method === 'GET'){\n\t\t\txhr.open('GET', url + '?' + data, flag);\n\t\t\txhr.send();\n\t\t}else if(method === 'POST'){\n\t\t\txhr.open('POST', url, flag);\n\t\t\txhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');\n\t\t\txhr.send(data);\n\t\t}\n\t\txhr.onreadystatechange = function (){\n\t\t\tif(xhr.readyState === 4){\n\t\t\t\tif(xhr.status === 200){\n\t\t\t\t\tcallback(xhr.responseText); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n</script>`\n\n### 19. 数组去重 eg：var arr = ['a','b',234,23,'a','b',3,1,234];\n第一种方法：\n\n`<script type=\"text/javascript\">\n\tArray.prototype.unique = function () {\n\t var arr = [],\n\t    obj = {},\n\t    len = this.length;\n\t    for(var i = 0;i < len;i++){\n\t    \tif(!obj[this[i]]){\n\t    \t\tobj[this[i]] = \"11\";\n\t    \t\tarr.push(this[i]);\n\t    \t}\n\t    }\n\t    return arr;\n}\n\tvar arr = [1,1,2,2,2,3,3,33,4,4,5,45,45,];\n\t[].unique(arr);    --> 结果为：[1，2，3，33，4，5，45]\n</script>`\n第二种方法：\n`<script type=\"text/javascript\">\n\tArray.prototype.unique = function (arr) {\n\t\treturn new Set(arr);\n\t}\n\tvar arr = [1,1,2,2,2,3,3,33,4,4,5,45,45,];\n\t[].unique(arr);    --> 结果为：[1，2，3，33，4，5，45]\n</script>`\n第三种方法：\n`<script type=\"text/javascript\">\n\tArray.prototype.unique = function (arr) {\n\t\tvar temp = [], len = arr.length;\n\t\tfor(let i = 0; i < len; i++) {\n\t\t\tif(temp.indexOf(arr[i]) === -1) {\n\t\t\t\ttemp.push(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n\tvar arr = [1,1,2,2,2,3,3,33,4,4,5,45,45,];\n\t[].unique(arr);    --> 结果为：[1，2，3，33，3，4，45]\n</script>`\n第四种方法：\n`<script type=\"text/javascript\">\n\tArray.prototype.unique = function (arr) {\n\t\tvar temp = [], len = arr.length;\n\t\tfor(let i = 0; i < len; i++) {\n\t\t\tif(arr.indexOf(arr[i]) === i) {\n\t\t\t\ttemp.push(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n\tvar arr = [1,1,2,2,2,3,3,33,4,4,5,45,45,];\n\t[].unique(arr);    --> 结果为：[1，2，3，33，4，5，45]\n</script>`\n第五种方法：\n`<script type=\"text/javascript\">\n\tArray.prototype.unique = function (arr) {\n\t\tvar temp = [],index = [], len = arr.length;\n\t\tfor(let i = 0; i < len; i++) {\n\t\t\tfor(let j = i + 1; j < len; j++) {\n\t\t\t\tif(arr[i] === arr[j]) {\n\t\t\t\t\ti ++ ;\n\t\t\t\t\tj = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp.push(arr[i]);\n\t\t\tindex.push(i);\n\t\t}\n\t\tconsole.log(index);\n\t\treturn temp;\n\t}\n\tvar arr = [1,1,2,2,2,3,3,33,4,4,5,45,45,];\n\t[].unique(arr);    --> 结果为：[1，2，3，33，4，5，45]\n</script>`\n### 20. 如今有个ul，如果有十亿个li；要求点击li触发事件，弹出对应li的内容\n\n`<ul>\n\t<li></li>\n</ul>`\n`<script type=\"text/javascript\">\n\tvar oUl = document.getElementsByTagName('ul')[0];\n\toUl.onclick = function  (e) {\n\t\tvar event = e || window.event;\n\t\tvar target = event.target || event.srcElement;\n\t\tconsole.log(target.innerHTML);\n\t}\n</script>`\n\n### 21. 阻止事件冒泡和事件默认时间\n\n`<script type=\"text/javascript\">\n\t<!-- //取消冒泡 -->\n\tfunction stopBubble(e) {\n\t\tif(e.stopPropagation){\n\t\t\te.stopPropagation();\n\t\t}else{\n\t\t\te.cancelBubble = true;\n\t\t}\n\t}     \n\t<!-- //阻止默认事件 -->\n\tfunction  cancelHandler(e){\n\t\tif(e.preventDefault){\n\t\t\te.preventDefault();\n\t\t}else{\n\t\t\te.returnValue = false;\n\t\t}\n\t}\n</script>`\n\n### 22. 什么是DOM：\nDOM是操作css，html的一套编程接口；\nDOM对象即为宿主对象，浏览器厂商定义的；\nDOM定义了表示和修改文档所需的方法。\n对html和xml编程接口不是css\n\n### 23. 利用JavaScript取非行间样式，要求兼容性各个浏览器\n\n`<script type=\"text/javascript\">\n\tfunction getComputedStyle(obj,styleProp){\n\t\tif (window.getComputedStyle) {\n\t\t\treturn window.getComputedStyle(obj,false)[styleProp];\n\t\t}else{\n\t\t\treturn obj.currentStyle[styleProp];\n\t\t}\n\t}\n</script>`\n\n### 24. 运行test()和new test()的结果是什么：\n\n`<script type=\"text/javascript\">\n\tvar a = 5;\n\tfunction test(){\n\t\ta=0;\n\t\talert(a);\n\t\talert(this.a);\n\t\tvar a;\n\t\talert(a);\n\t}\n</script>`\n结果是：0 5 0    ,    0 undefined 0\n\n### 25. 有字符串\"aaaaabbbccccddddeeefgaa\",转换为连续不重复的字符串\n\n`<script type=\"text/javascript\">\n\tvar str = \"aaaaabbbccccddddeeefgaa\";\n\tvar reg = /(.)\\1*/g;\n\tconsole.log(str.replace(reg,\"$1\"));\n</script>`\n\n### 26. 一串连续数字实现打点功能：100000000转换成：1.000.000.000\n\n`<script type=\"text/javascript\">\n\tvar str = \"1000000000\";\n\tvar reg = /(?=(\\B)(\\d{3})+$)/g;\n\tconsole.log(str.replace(reg,\".\"));\n</script>`\n\n### 27. 写出运算结果：\n\n```<script type=\"text/javascript\">\n\talert(typeof(a))--undefined\n\talert(typeof(undefined))--undefined\n\talert(typeof(NaN))--number\n\talert(typeof(null))--object\n\n\tvar a = \"123abc\";\n\talert(typeof(+a));--number\n\talert(typeof(!!a));--boolean\n\talert(typeof(a + \"\"));--string\n\n\talert(1 == \"1\"); --true\n\talert(NaN == NaN); --flase\n\talert(NaN == undefined);--flase\n\talert(\"11\" + 11);--1111\n\talert(1===\"1\")--flase\n\talert(parseInt(\"123abc\"))--123\n\n\tvar num = 1232123.3456789;\n\talert(num.toFixed(3));--1232123.346\n\t//toFixed只在number类型上可以用，保留几位有效数字，四舍五入\n\n\t// typeof(typeof(a))--string\n</script>```\n\n### 28. 打印当前年月时分秒\n\n`<script type=\"text/javascript\">\n\tvar date = new Date();\n  console.log(date.getFullYear + \"年\" + (date.getMonth() + 1) + \"月\" + date.getDate() + \"日\"+ date.getHours() + \"时\" + date.getMinutes() + \"分\" + date.getSeconds() + \"秒\");\n</script>`\n\n### 29. css中，font-size设置的是字体的高；单位是px，em是相对值。\n\n### 30. 有html结构：\n\t\n    `<div style=\"background-color:red;margin:0 0 100px 0;\">123</div>\n\t<div style=\"background-color:red;margin:200px 0 0 0;\">234</div>`\n\n\t他们之间的间距是：200px\n\n### 31. 简单说说自定义构造函数创建对象的原理：\n\t在函数的最前面隐式的加上 this = {}；最后隐式的返回 return this；\n\n### 32. 写出一种原型链实现继承的方式：圣杯模式\n\n```<script type=\"text/javascript\">\n\n\tvar inherit =(function(){\n\n\tvar F = function(){};\n\t\treturn function(P,C){\n\t\t\tF.prototype = P.prototype;\n\t\t\tC.prototype = new F();\n\t\t\tC.prototype.constructor = C;\n\t\t\tC.prototype.uber = P.prototype;\n\t\t}\n\t}());\n</script>```\n\n### 33. 深度克隆：\n\n`<script type=\"text/javascript\">\n\tArray.prototype.deepClone = function (parent, child) {\n      \t var child = {} || child;\n      \t var toStr = Object.prototype.toString,\n      \t     arrStr = '[object Array]';\n      \t for(var prop in parent){\n      \t \tif(parent.hasOwnProperty(prop)){\n      \t \t\tif(typeof(parent[prop]) === \"object\"){\n                    child[prop] = (toStr.call(parent[prop]) === arrStr) ? []:\n                    {};\n                    deepClone(parent[prop], child[prop]);\n      \t \t\t}else{\n      \t \t\t\tchild[prop] = parent[prop];\n      \t \t\t}\n      \t \t}\n      \t }\n      }\n</script>`\n\n### 34. 描述预编译过程：\n\t（1）创建AO对象；\n\t（2）找形参和变量声明，将变量和形参作为AO对象的属性名，值为undefined；\n\t（3）将实参和形参相统一；\n\t（4）在函数体里找函数声明，将函数声明作为AO对象的属性名，将函数体作为赋值对象赋予函数名。\n\n### 35. 介绍js语言特点：\n\t单线程；脚本语言；解释性语言，解释一行执行一行；ECMA标注；弱数据类型语言；可以跨平台；\n\n### 36. 介绍主流浏览器以及他们相应的内核，介绍浏览器分为哪几部分，内核呢？\n\t浏览器分为：shell与内核（js引擎，渲染引擎，其他）\n  主流浏览器：IE（trident）；chrome（webkit/blink）；safari（webkit）；Firefox（Gecko）；Opera（presto）；\n\n### 37. 简述js时间线的顺序：\n\t1、创建Document对象，开始解析web页面。document.readyState = 'loading'。\n\t2、遇到link外部css，创建线程加载，并继续解析文档。\n\t3、遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。\n\t4、遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()）\n\t5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。\n\t6、当文档解析完成，document.readyState = 'interactive'。\n\t7、文档解析完成后（就是所有dom节点都解析完），所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）;\n\t8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。\n\t9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = 'complete'，window对象触发load事件。\n\t10、从此，以异步响应方式处理用户输入、网络事件等。\n\n### 38. 异步加载js的几种方案：\n\tdefer async\n异步加载兼容性写法：\n\n```<script type=\"text/javascript\">\n  function asyncLoaded (url,callback) {\n      var script = document.createElement('script');\n      script.type = \"text/javascript\";\n      if (script.readySate) {\n          script.onreadystatechange = function (){\n              if (script.readySate == \"complete\" || script.readySate == \"loaded\") {\n                  obj[callback]();\n                  script.onreadystatechange = null ;\n              }\n          }\n      }else{\n          script.onload = function(){\n              obj[callback]();\n          }\n      }\n      script.src = url ;\n      document.head.appendChild(script);\n  }\n\n</script>```\n\n### 39. 打印结果：\n\n`<script type=\"text/javascript\">\n\tvar a = (10*3-4/2 + 1)%2,\n\t\tb = 3;\n\tb %= a + 3;\n\tconsole.log(a++);\n\tconsole.log(--b);\n</script>`\n\n\t结果：1   2\n\n### 40. 使用原生js，addEventListener,给每个li元素绑定一个click事件，输出他们的顺序。\n\n`<ul>\n    <li>a</li>\n    <li>a</li>\n    <li>a</li>\n    <li>a</li>\n</ul>`\n\n`<script type=\"text/javascript\">\n\tvar liCollection = document.getElementsByTagName('li'),\n\tlen = liCollection.length;\n\tfor (var i = 0; i < len; i++) {\n\t\t(function(j){\n\t\t\tliCollection[j].addEventListener('click',function(){\n\t\t\t\tconsole.log(j);\n\t\t\t}false);\n\t\t}(i))\n\t}\n</script>`\n### 41. 一个字符串由[a-z]组成，找出第一个只出现一次的字母\n\n`<script type=\"text/javascript\">\n\tArray.prototype.unique = function() {\n\t var len = this.length,\n\t     obj = {},\n\t     arr = [];\n\t for(var i = 0; i < len; i++){\n\t   if(!obj[this[i]]) {\n\t     obj[this[i]] = \"1\";\n\t     arr.push(this[i]);\n\t   }\n\t }\n\t return arr;\n\t}\n\tvar str = \"abaadf\";\n\tvar arr = str.split(\"\");\n\tvar arr1 = arr.unique();\n\tconsole.log(arr1[0]);\n</script>`\n### 42. 打印结果：\n\n`<script type=\"text/javascript\">\n\tvar name = \"222\";\n\tvar a = {\n\t\tname:\"111\",\n\t\tsay:function(){\n\t\t\tconsole.log(this.name);\n\t\t}\n\t}\n\tvar fun = a.say;\n\tfun();\n\ta.say();\n\tvar b = {\n\t\tname:\"333\",\n\t\tsay:function(fun){\n\t\t\tfun();\n\t\t}\n\t}\n\tb.say(a.say);\n\tb.say=a.say;\n\tb.say();\n</script>`\n\n结果： 222  111  222  333\n\n### 43. 原始值\n\n`<script type=\"text/javascript\">\n\tvar str = \"你成哥很帅\";\n\tstr.length = 3;\n\tconsole.log(str);\t\n</script>`\n\n执行结果为：你成哥很帅\n原因：原始值不可改变\n\n### 44. 请用多种方法创造对象：\n\t字面量 var obj = {}；\n\t构造函数 var obj = new Object{};\n\tvar obj = Object.create(原型)\n\n### 45. 解决污染全局变量\n\t命名空间，闭包\n\n### 46. 枚举一个对象中所有自有属性：\n\n```<script type=\"text/javascript\">\n\n  Person.prototype.lastName = \"ji\";\n\n  function Person(name,age){\n    this.name  = name;\n    this.age = age ;\n  }\n\n  var oPerson = new Person ('cheng',123);\n  for(var prop in oPerson){\n    if(oPerson.hasOwnProperty(prop)){\n    console.log(oPerson[prop]);\n    }\n}\n</script>```\n### 47. 让数组里的数据从大到小排列：\n\n`<script type=\"text/javascript\">\n\tarr.sort(function(a,b){\n\t\treturn a - b;\n\t}());\n</script>`\n\n### 48. es5严格模式如何使用，应该注意些什么：\n\n`<script type=\"text/javascript\">\n全局严格模式:直接加 字符串：\"use strict\";\n局部函数内严格模式（推荐）\nfunction test(){\n    \"use strict\";\n}\n注意：不支持with,arguments.callee,func.caller,变量赋值前必须声明，局部this必须被赋值(Person.call(null/undefined) 赋值什么就是什么),拒绝重复属性和参数\n</script>`\n\n### 49. 选择html元素节点几种方法，以及他们各自的兼容性问题及特点：\n\n`<script type=\"text/javascript\">\n\t\tgetElementsByTagName()[0];\n\t\tgetElementById();\n\t\tgetElementsByName();\n\t\tgetElementByClassName(); interactive8及以下不兼容\n\t\tquerySelectorAll();非实时ie7及以下不兼容\n\t\tquerySelector();非实时ie7及以下不兼容\n\t1.getElementById方法定义在Document.prototype上，即Element节点上不能使用。\n\t2.getElementsByName方法定义在HTMLDocument.prototype上，即非html中的document以外不能使用(xml document,Element)\n\t3.getElementsByTagName方法定义在Document.prototype 和 Element.prototype上\n\t4.HTMLDocument.prototype定义了一些常用的属性，body,head,分别指代HTML文档中的<body><head>标签。\n\t5.Document.prototype上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代<html>元素\n\t6.getElementsByClassName、querySelectorAll、querySelector在Document,Element类中均有定义\n</script>`\n\n### 50. 说出节点类型的值为1,2,3,8,9的值对应的节点是什么：\n元素节点   —— 1 \n属性节点   —— 2\n文本节点   —— 3 \n注释节点   —— 8\ndocument  —— 9 单独成一类 文档节点\n<!-- DocumentFragment  ——  11 文档碎片 --> \n<!-- 获取节点类型   nodeType  -->\n\n### 51. 鼠标事件的触发顺序：\n\tmousedown; focus; mouseup; click;\n\t右键事件：\n\t\n    `<script type=\"text/javascript\">\t\n\telem.onmousedown = function (e) {\n\t\tif(e.button == 2){\n\t\t\talert(\"右键点击\")\n\t\t}\n\t}\n\t</script>`\n\n### 52. 数据格式JSON转换为字符串，以及把字符串转换为JSON的方法\n\n`<script type=\"text/javascript\">\n\tJSON.parse();  string — > json字符串\nJSON.stringify();   json — > string\n</script>`\n\n### 53. BOM对象及其功能：\n    Window     JavaScript 层级中的顶层对象，表示浏览器窗口。\n    \t属性：\n\t    \tclosed\t返回窗口是否已被关闭。\n\t    \tdocument\t对 Document 对象的只读引用。\n\t\t\thistory\t对 History 对象的只读引用。\n\t\t\tinnerheight\t返回窗口的文档显示区的高度。\n\t\t\tinnerwidth\t返回窗口的文档显示区的宽度。\n\t\t方法：\n\t\t\talert()\t显示带有一段消息和一个确认按钮的警告框。\n\t\t\tblur()\t把键盘焦点从顶层窗口移开。\n\t\t\tclearInterval()\t取消由 setInterval() 设置的 timeout。 \n\t\n\tNavigator  包含客户端浏览器的信息。\n\t\t属性：\n\t\t\tappCodeName\t返回浏览器的代码名。 \n\t\t方法：\n\t\t\tjavaEnabled()\t规定浏览器是否启用 Java。\n\t\n\tScreen     包含客户端显示屏的信息。 \n\t\t属性：\n\t\t\tavailHeight\t返回显示屏幕的高度 (除 Windows 任务栏之外)。\n\t\t\tavailWidth\t返回显示屏幕的宽度 (除 Windows 任务栏之外)。\n\t\t\twidth\t返回显示器屏幕的宽度。\n\t\t\n\tHistory    包含了浏览器窗口访问过的 URL。 \n\t\t属性：\n\t\t\tlength\t返回浏览器历史列表中的 URL 数量。\n\t\t方法：\n\t\t\tback()\t加载 history 列表中的前一个 URL。\n\t\t\tforward()\t加载 history 列表中的下一个 URL。\n\t\t\tgo()\t加载 history 列表中的某个具体页面。\n\n\tLocation   包含了当前 URL 的信息。\n\t\t属性：\n\t\t\thref\t设置或返回完整的 URL。\n\t\t方法：\n\t\t\tassign()\t加载新的文档。\n\t\t\treload()\t重新加载当前文档。\n\t\t\treplace()\t用新的文档替换当前文档。\n\n### 54. 说明position定位的值有什么区别，如果有不能兼容的问题，如何解决\n\tabsolute 绝对定位\n\trelative 相对定位\n\tfixed\t 相对可视区定位，而且脱离原来位置 ie6不能用\n    sticky回去查一查\n\n### 55. 添加css代码使得ul外观可以包住li：\n\n```<style type=\"text/css\">\n\tul{\n\t\tlist-style: none;\n\t\tpadding: 0;\n\t}\n\tul>li{\n\t\tfloat: left;\n\t}\n\n\n\tul:after{\n\tcontent:\"\";\n\tdisplay:inline-block;\n\tclear:both;\n}\n</style>```\n\n`<ul>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n</ul>`\n\n### 56. 熟知的选择优先级关系（权重）\n\t！important\t\t\t无穷大\n\tstyle（行间样式）\t1000\n\tid\t\t\t\t\t100\n\tclass/属性/伪类\t\t10\n\t标签/伪元素\t\t\t1\n\t通配符*\t\t\t\t0\n\n### 57. display值及含义\ndisplay值： inline---行级元素，不沾满整行，不可以改变宽高\n\t\t\tblock----块级元素 沾满整行 可以改变宽高\n\t\t\tinline-block----行级块元素 不占满整行 可以改变宽高 \n\n### 58. 写一个输入框，带有js功能，鼠标聚焦提示消息信息，失去焦点显示提示信息\n\n```<style type=\"text/css\">\n\tinput{\n\t\tborder: 1px solid black;\n\t\tcolor: #999;\n\t}\n\n\t.fontGrey{\n\tcolor: #999;\n\t}\n\t.fontNormal{\n\tcolor: #424242;\n\t}\n\n</style>```\n```</head>\n<body>\n\tusername:<input tyoe=\"text\" value=\"请输入用户名\"onfocus=\"if(this value='请输入用户名'){this.value='';this.className='fontNormal'}\"onblur=\"if(this.value==''){this.value='请输入用户名';this.className='fontGrey'}\" onchange=\"console.log(this.value)\">\n</body>```\n\n### 59. 写出打印结果并说明原因：\n\n`<script type=\"text/javascript\">\n\tfunction fn(a,b){\n\t\targuments[0] = 1;\n\t\tconsole.log(a);\n\t\tfn(2,1);\n\t}\n\t打印：1;\n\t原因：实参，形参相统一;\n</script>`\n\n### 60. 将下列变量转化为小驼峰形式：my-first-name->myFirstName\n\n`<script type=\"text/javascript\">\n\tvar str = \"my-first-name\";\n\tvar reg =/-(\\w)/g;\n\tvar test = str.replace(reg,function($,$1){\n\t\treturn $1.toUpperCase();\n\t});\n\tconsole.log(test);\n</script>`\n\n### 61. 将aaaaabbbb字符串调换成bbbbaaaa形式\n\n`<script type=\"text/javascript\">\n\tvar str = \"aaaabbbb\";\n\t var reg = /(\\w{4})(\\w{4})/g;\n\t console.log(str.replace(reg,\"$2$1\"));\n</script>`\n\n说一下你对前端的理解.","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"人生启迪","url":"/2017/11/人生启迪发人深省.html","content":"## 影视人生-人生启迪\n** {{ title }}：** <Excerpt in index | 首页摘要>\n动情美剧：This Is Us\n\n启迪电影：Cloud Atlas （演员：汤姆汉克斯、哈利贝瑞、雨果维文、周迅  导演：汤姆提克威、拉娜沃卓斯基）\n","tags":["影视人生"],"categories":["个人随笔"]},{"title":"绑定事件","url":"/2017/11/事件.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n## 事件\n### 如何绑定事件：\n1. ele.onxxx = function (event) {}\n兼容性很好，但是一个元素只能绑定一个处理程序\n基本等同于写在HTML行间上\n2. obj.addEventListener(type, fn, false);\nIE9以下不兼容，可以为一个事件绑定多个处理程序\n3. obj.attachEvent(‘on’ + type, fn);\nIE独有，一个事件同样可以绑定多个处理程序\n\n### 事件处理程序的运行环境：\n1. ele.onxxx = function (event){}\n  程序this指向是dom元素本身\n2. obj.addEventListener(type, fn, false);\n  程序this指向是dom元素本身\n3. obj.attachEvent('on' + type, fn);\n  程序this指向window\n\n2有需要注意的地方：虽然这个方法可以绑定多个处理程序，但是也得看是怎么绑定的：\n `var oDiv = document.getElementsByTagName(div)[0];\n oDiv.addEventListener('click', function() {\n   alert(0);\n }, false);\n oDiv.addEventListener('click', function() {\n   alert(1);\n }, false);`\n这样的结果就是：先弹窗为0，在弹窗为1；  因为绑定的事件处理函数不是同一个事件处理函数，绑定的事件处理函数是多个事件处理函数时，绑定多少个事件处理函数就会执行多少次这个所绑定的事件处理函数，并且无论这个是否是同一事件类型。 \n\n `var oDiv = document.getElementsByTagName(div)[0],\n     test = function(){\n\talert(0);\n     };`\n oDiv.addEventListener('click', test, false);\n这样的结果就是： 只弹窗一次0；  因为绑定的事件处理函数是同一个就是test处理函数。总结：同一dom元素绑定同一事件类型而且是同一个处理函数的时候，只执行所绑定的test处理函数一次！！！\n\n事件处理模型：事件冒泡和事件捕获（这两个方法的切换也就是addEventListener这个方法的第三个参数的false和true的切换）\n事件冒泡：结构上的由于最内部的dom结构触发事件处理函数，但是这个处理函数会往上冒泡，直到冒泡到最祖先层次才会结束。但是必须要绑定这个事件的处理函数。往上冒泡就是必须是同一个事件处理函数才能自动往上触发父级或者更高级的同样绑定的同一事件类型的处理函数。\n这俩个方法的区别就是触发事件的先后顺序发生了改变，事件冒泡是才从里往外，顾名思义也就像鱼儿从水底吐泡向水上冒泡一样，从dom结构上来说就是从子级往父级和更高级的父级关系上发生的事件处理模型。而捕获从事件发生的顺序上跟冒泡正好相反，这两个方法也就是事件发生顺序上的这点区别而已。如果这两个方法都有的话，是先捕获在冒泡的。与写代码的顺序无关，IE并没有捕获，只有冒泡。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"计算机发展+Git简单使用+markdown简单语法","url":"/2017/11/专业必备技能.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n# 计算机的发展历程：\n电子数字计算机是一种能够自行按照已设定的程序进行数据处理的电子设备；是软件与硬件相结合、面向系统、侧重应用的自动化求解工具。\n世界上第一台电子数字计算机ENIAC在1946年诞生于美国；短短70年计算机技术迅猛发展，从科学计算、数据处理等应用领域，迅速扩展到实时控制、辅助设计、智能模拟等诸多领域。今天计算机无所不在~~\n\n1946年，我们使用电子真空管制造计算机，机器语言编程主要应用于科学计算。\n1956年，出现了晶体管，制造出了第二代计算机，批处理控制成为一种操作计算机的主要方式，进而也出现了高级计算机语言Fortan语言用于科学计算/COBOL语言应用于数据处理；应用领域也扩展到数据处理领域。\n1959年，集成电路的出现，多道程序的概念得以实施；进而操作系统/数据库管理系统/高级语言程序等一系列的系统软件成组产生；应用领域得到了进一步的扩展。\n1976年，大规模集成电路/超大规模集成电路相继面世；计算机向快速化、小型化、系统化、网络化、智能化等方面快速发展。\n1980年，微型计算机概念出现了；计算机的廉价化进一步促进了应用领域的快速膨胀。\n1990年，图形化人机交互技术面世；计算机使用的友善化推动了应用人群的快速扩展。\n2003年，移动计算机的出现，是的计算机进一步发展，使得现在计算机无处不在。\n\n## 计算机系统的组成：\n计算机系统：包括硬件子系统和软件子系统\n硬件：借助光、电、磁、机械等原理构成的各种物理部件的有机组合，是系统工作的实体。 ---CPU，主存储器，I/O控制系统，外围设备\n\n软件：各种程序和文件，用于指挥计算机系统按指定的要求进行协同工作。 包括系统软件、支撑软件和应用软件。  关键系统软件是：操作系统与语言处理程序。\n\n\n## 计算机硬件系统：\n中央处理器--运算单元、控制单元；\n主存储器；\n外围设备--输出设备、输入设备、存储设备、网络通信设备；\n这些硬件是靠系统总线连接着相互作用的。\n\n今天的计算机绝大部分是由 冯诺依曼模型设计的存储程序计算机。\n1. 以运算单元为中心，控制流由指令流产生\n2. 采用存储程序原理，面向主存组织数据流\n3. 主存是按地址访问、线性编址的空间\n4. 指令由操作码和地址码组成\n5. 数据以二进制编码\n\n## 存储计算机的结构：\n\n                <-----控制器\n               |>\n数据程序-->输入设备-->存储器-->输出设备-->计算结果\n                       |\n                     运算器\n\n\n\n## 总线及其组成：\n总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是CPU、内存、输入输出设备传递信息的公用通道；\n计算机的各个部件通过总线相连接，外围设备通过相应的接口电路在于总线相连接，从而形成了计算机硬件系统；\n按照所传输的信息种类，总线包括一组控制线、一组数据线和一组地址线。\n\n内部总线：用于CPU芯片内部连接各元件；\n系统总线：用于连接CPU、存储器和各种I/O模块等主要部件；\n通信总线：用于计算机系统之间通信。\n\n## 中央处理器（CPU）\n中央处理器是计算机的运算核心（Core）和控制单元（Control Unit），主要包括：\n运算逻辑部件：一个或多个运算器；\n寄存器部件：包括通用寄存器、控制与状态寄存器，以及高速缓冲存储器（Cache）；\n控制部件：实现各部件间联系的数据、控制及状态的内部总线；负责对指令译码、发出为完成每条指令所要执行操作的控制信号、实现数据输出等功能的部件；\n\n## 处理器与寄存器：\n运算单元、控制单元、内部总线、PC/IR/Flag、MAR/MDR;\n寄存器、Cache、IOAR/IODR\n\n## CPU：\n标志寄存器Flag、程序计数器PC、\n控制单元：指令暂存器IR、指令译码器ID\n内存地址寄存器MAR、内存数据寄存器MDR\n     |\n   主存储器\n\n存储器的组织层次：层级越小，容量更小，速度更快，价格更高；层级越高，容量更大，速度更慢，价格更低。\nL0：寄存器\nL1：L1 Cache（SRAM）\nL2：L2 Cache（SRAM）\nL3：L3 Cache（SRAM）\nL4：主存（DRAM）\nL5：SSD（本地固态硬盘）\nL6：本地外存储器（本地硬盘）\nL7：远程外存储器（分布式文件系统，Web服务器）\n\n\n## 外围设备：输入设备、输出设备、存储设备、网络设备（机机通信设备）\n外围设备控制方式：轮询方式--CPU忙式控制，CPU执行内存数据交换；中断方式--CPU启动外设，外设中断CPU，CPU执行内存数据交换；DMA方式--CPU启动DMA，DMA执行输入输出与内存数据交换，DMA中断CPU。\n\n\n## 计算机软件系统的组成：系统软件、支撑软件、应用软件；\n\n## 系统软件：操作系统、实用程序、语言处理程序、数据库管理系统；\n操作系统实施对各种软硬件资源的管理控制\n实用程序为方便用户所设，如文本编辑等\n语言处理程序把用汇编语言/该机语言编写的程序，翻译成可执行的及其语言程序；\n支撑软件：有接口软件、工具软件、环境数据库，支持用户使用计算机的环境，提供开发工具；\n应用软件：是用户按器需要自行编写的专用程序；\n\n## 程序员的计算机系统视图：\n最开始的计算机是\n程序员---> 机器指令----> 计算机硬件系统\n当操作系统与实用软件的出现扩展机器指令，可以着重于CPU的计算，增加了系统调用，注重再来计算上面；\n增加了数据库管理系统之后，程序设计；\n高级语言的形成，使得我们面向目标机器变成了面向目标解决；\n\n## 软件开发的不同层次：\n计算机硬件系统：及其语言\n操作系统质资源管理：机器语言+广义指令（扩充了硬件资源管理）\n操作系统之文件系统：机器语言+系统调用（扩充了信息资源管理）\n数据库管理系统：++数据库语言（扩充了功能更强的信息资源管理）\n语言处理程序：面向问题的语言\n\n\n## 计算机程序的执行过程：\n一些高级语言一般会经过转换程序转换成另一种高级语言执行比如我们的第四代语言需要转换成C语言这样的第三代语言高级语言源程序，之后通过编译程序转换成目标代码程序或者通过解释程序编程目标代码程序；我们也可以通过汇编语言源程序通过汇编程序转换成目标代码程序；最后目标代码程序则需经过库函数通过连接程序变为可执行程序；可执行程序是在操作系统中可执行的程序；可执行程序最后装入程序装入内存，在操作系统下进行执行。\n\n\n## 操作平台与操作系统\n任何一台及其都有其操作平台与操作系统；\n计算机的操作系统：\n开关标示，按钮控制，亮灯显示；\n\n\n\n\n# Git有很多命令：\ngit init （交给git来管理）\ngit add . （工作区上传到缓存区）\ngit commit -m '本次提交的注释信息'  （缓存区上传到仓库）\ngit reset --hard HEAD^  (回滚到上一个版本，一个尖角号就是后退一个版本)\ngit log  (获取当前的版本号和之前的版本)\ngit refolg (看我们真实的一些操作并且返回所有的id号)\ngit reset --hard ID号  (回滚到本ID号所在的版本)\ngit diff  (比较工作区与缓存区的区别)\ngit diff HEAD  (比较工作区与仓库的区别)\ngit diff --cached  (比较缓存区与仓库的区别)\ngit checkout HEAD <file>   (把仓库的代码覆盖到工作区和缓存区，如果写代码写错了，就可以这样啊)\ngit reset HEAD  (把仓库区覆盖缓存区)\ngit checkout -- <file>   (缓存区覆盖工作区)\n\n## 多人开发：\ngit branch dev  (新建一个dev分支)\ngit branch    （查看现在分支）\ngit branch -va  (查看远程和本地的所有分支)\ngit checkout dev  (从当前分支改到dev分支上，多人开发一般都会把master分支保护起来，一个人一个分支)\ngit merge dev  (把在dev上开发的代码合并到master分支上，此功能应该先回到master分支上，这样就是合并dev到master分支上)\n要是dev分支上与我们master分支上互相都有不同，也就是master是别人在你上传到master上之前提交修改了，所以合并你的dev的时候就会出现冲突，冲突合并会出现HEAD上与你不同的内容，和你dev与master不同的内容之间会有分割线，所以你就要手动的进行合并。\ngit checkout remotes/origin/dev  (下载远程dev分支上的内容到本地)\n多人开发首先应该拉取代码：\ngit pull origin master  (拉取远程代码到本地)\ngit push origin master:master  (把本地上的代码处理完冲突在推送到远程上)\n一般公司里你自己并不能提交到master分支上，所以你应该提交一个提交请求并且@一下这个项目的主管（前端主管和后端主管），主管审核无误后，主管才会推送到master分支上。\n\n\n\n## github简单使用：\n1）git  init\n初始化一个git\n2) vim .gitignore 新增以及编写这个文件\nnode_modules/\n意思就是上传的时候忽略这个文件夹以及里面的内容，因为我上传的是nodejs项目文件，所以不用把node_modules上传上去\n3）git add .    添加代码到git\n4)  git commit -m '第一个版本'\n版本的备注信息\n5) git remote add origin https://github.com/jasonzhangdong/auth2.0test.git\n将代码关联到github上面，后面的url就是第二部拷贝下来的那个路径\n6）git push -u origin master\n     将代码推送上去\n\n## git一些问题：\n问题描述：\n在使用gulp当中，自动生成的node_modules文件夹，因为文件目录层级太深，无法系统删除，用360粉碎工具也报错\n解决方法：\n使用npm中的插件rimraf，专门用于删除的模块插件\n　　1、安装：npm install -g rimraf（全局安装）\n　　2、使用：先定位目标文件夹的父级目录，然后命令行输入rimraf ***（***为需要删除的文件夹名称）  eg：rimraf node_modules\n\n\n\n# MarkDown的简要规则：\n标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。\n```\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。\n\n## 引用\n如果你需要引用一小段别处的句子，那么就要用引用的格式。只需要在文本前加入 > 这种尖括号（大于号）即可，要注意符号和文本之间的空格。\n\n## 图片与链接:\n插入链接与插入图片的语法很像，区别在一个 !号\n图片为：![](){ImgCap}{/ImgCap}\n链接为：[]()\n插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。\n例子：\n插入链接：\n```\n[Baidu](http://baidu.com)\n插入图片：\n![Mou icon](http://mouapp.com/Mou_128.png)\n```\n展示效果如下：\n[Baidu](http://baidu.com)\n插入图片：\n![Mou icon](http://mouapp.com/Mou_128.png)\n## 粗体与斜体:\nMarkdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。\n\n## 表格\n\n表格是我觉得 Markdown 比较累人的地方，例子如下：\n```\n\n| Tables        | Are           | Cool  |\n\n| ------------- |:-------------:| -----:|\n\n| col 3 is      | right-aligned | $1600 |\n\n| col 2 is      | centered      |   $12 |\n\n| zebra stripes | are neat      |    $1 |\n\n```\n\n## 代码框:\n如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。使用 tab 键即可缩进。\n\n\n分割线\n分割线的语法只需要三个 * 号.\n```\n***\n***\n***\n***\n```\n效果展示如下：\n***\n***\n***\n***\n这是四条分割线吗？\n","tags":["认知提升"],"categories":["资源分享"]},{"title":"那年那器那些事","url":"/2017/11/What is the server.html","content":"\n## 服务器的自白\n\n>hello，大家好，我叫服务器，承载了全世界互联网行业的光荣与梦想。最近，听说居然有人敢质疑我的权威，说我会不会宕机？明确告诉你，你可以骂我卡，但就是不让你看见我宕机！\n\n## 不是不想休息，而是不能宕机\n\n我们服务器是每一家互联网企业的支撑，如果支柱倒塌那会是怎样的灾难？所以我们不是不想休息，而是绝对不能宕机！服务器存在的目的是与家用电脑是完全不同的两种，家用电脑存在着不需要使用的时间点，而且这个时间点往往很长，因此家用电脑可以有很长的休眠时间。而服务器则不然，不同公司的服务器对使用时间段不同，这也就使得部分服务器根本不允许有休眠的时间。\n\n## 夜深人静，依然奋斗的服务器\n\n  根据数据显示，金融企业每次宕机的平均损失约为1000万美金，这还不让无法统计的无形资产损失。一些大型的网站通常会有登录的高峰阶段，例如12306的春运、电商平台的购物街、新型电子产品的发布等都会给服务器带来巨大的压力，宕机对企业就是灾难性的打击。\n\n![f1](http://outwcl4zh.bkt.clouddn.com/1.jpg)\n               烧香拜佛难免服务器崩溃\n  我们不是不想宕机，而是使命的存在让我们不能宕机。此外，又制定外部环境，过硬的自身素质和纯净的软件环境是保障我们稳定运行绝不宕机的条件。\n\n## 只有住的好，才能不显老\n  我们的服务器的触觉比你们人类更加挑剔，工作时间比人类更长，因为良好的工作环境是必要条件。\n\n### 谷歌的数据中心\n  在恒湿恒温准无尘的环境，没错，那就是我们最习惯的地方。我们这样挑剔的电子设备，工作环境必须常年保持在18℃到30℃之间，温度过高或者过低都将对我们的使用有所影响，加速我们的老化。空气的流通也是非常重要的，在我们所居住的地方，24小时空调是不能停。但是空调不能保障我们的体温的。每当我们服务器工作时间长了，浑身上下都会发热。因此大量的冷却水给我们进行贴身服务降温，保障服务器散热和机身温度的稳定。\n\n## 谷歌数据中心，不同颜色的冷却水\n  我们的工作运行环境，要求至少达到准无尘标准。一般来讲，经过长期正常维护的服务器运行十年以上，主板上的积尘比用几个月的家用电脑服务器少。只有这样才能最大限度避免静电灰对服务器工作可靠性的影响。\n\n## 整洁、干净、无尘\n  更重要的是，我们的运维人员都非常专业，经常加班加点的对服务器的运行状况进行监测。以便于一旦发现任何问题，及时处理。否则，宕机也是在所难免。\n  只为不宕机，硬件更专业，我们服务器的设计就是为了不宕机而出现的，这一点和家用电脑有着千差万别。\n  没有完全不会坏的服务器，我们也会有故障。一次服务器在设计的时候做了大量的备份冗余，维护不会影响到正常工作。以谷歌的数据中心为例，大量的数据服务器都采取了即插即用模块化的方式设计。每个模块服务器有着自己的电源。如果某一模块发生故障，直接换上新的模块就可以，而不会影响到其他模块。\n\n## 模块化设计都有独立的电源\n  而且，服务器大多数设计为集群架构，即以双机或者多机热备。同时运行一个业务时，一台或者多台服务器的离线并不会对整体业务造成严重的影响。而这也是平时一些人在玩网游是会感觉卡的原因之一，很可能就是某台服务器偷懒启用了备用服务器的原因。\n\n## 模块维修，没想象的那么难\n  家用电脑可能会有生产商偷工减料节约成本，降低整体价格的现象存在。但是我们服务器领域却不会这样。CPU内置多种容错纠错机制；内存带有ECC校验芯片，数据干扰出错风险比非ECC内存低很多，采用优质方案是不宕机的关键所在。\n  比家用服务器的商业级别的配件好太多，我们所有的零件都是工业级配件。而且从电子元件到电路板都经历了包括老化测试（高温高电压）、振动测试、高温高湿测试等几十项可靠性测试。经历了暴风雨的洗礼的我们却在温室中被供养，这就是常年不宕机的秘诀。\n\n### 服务器出厂要经过各种测试\n\n## 一生只做一件事，软件更纯粹\n  我们所运行的系统和普通的家用系统有着本质的区别。无论是windows server、Linux或者更强大的Unix，这些系统本身具有高精确度、简单化、稳定可靠等特点。\n\n\n  而这些服务器系统的精简程度简直令人发指。由于服务器不需要外接显示器，所以一些图形化的界面服务程序通通被砍掉，甚至连声卡都不要开启。\n\n  相比普通的家用操作系统，这些图形化的程序往往占用了大量的空间，计算量和复杂程度较高，导致电脑服务器运行缓慢。而大量多余运行项目排除，使得服务器级别操作系统的目的性更明确，甚至有的服务器穷其一生都是在运行一款Apache，压力比家用电脑小太多。\n\n### Unix系统没有图形化界面，这是搭配的CDE桌面\n  而对于高端的服务器来讲，操作系统的容错性也是完爆家用级别服务器。在家用服务器运行时，一个error弹框就能让整台电脑重启。而服务器如果出现错误，后台自动生成详细的错误分析日志，寻求最佳解决方案保障程序继续运行下去。\n\n![f2](http://outwcl4zh.bkt.clouddn.com/2.jpg)\n   让人目眩的大规模集群架构\n\n   做单一的工作虽然简单，但是服务器的处理量是巨大的，这时，大型集群架构就可以发挥他的作用了。一旦服务器负载量增大，大规模集群会让负载均衡化，保障单个服务器不会过载崩溃，整个系统稳定运行。\n\n## 其实我也宕机，只是不让你看见\n  当然，我们服务器家族个头有高有矮，情况不一。一些比较低端的服务器只是针对小范围的受众，一旦超出了承载范畴，系统崩溃宕机的事情时有发生。而高端产品也不能完全例外，但是宕机几率和风险要小太多。\n\n![f3](http://outwcl4zh.bkt.clouddn.com/3.jpg)\n    不同类型的服务器\n\n  让服务器宕机的原因大致可以分为三种。一，天灾。服务器所处环境不良，维护不够及时，甚至供电不良等；二，人祸。各种应用的设置不当，人为操作失误和破坏以及最常见的大量访问超出了服务上限，导致服务器崩溃。 三，服务器本身原因。服务器质量的差距归根结底是投入的差距。也就是说，服务器的质量越好，成本越高，相应的价格也就越贵。比如，普通的商业级别服务器价格在3000到10万间，而Unix服务器的价格则在30万到3000万。\n\n![f4](http://outwcl4zh.bkt.clouddn.com/4.jpg)\n        戴尔Unix服务器\n\n  价格的提升带来的是服务器稳定性的提升。高端的Unix服务器已经达到了可用性99.99%的指标。即具备故障自动恢复能力，年停机时间不超过53分钟。但其超高成本和维护费用也使得很多企业望而却步。目前，也仅有银行、证券保险和电信等行业才会采用。\n\n  那么如此高端的服务器就可以永不宕机了么？事实恐怕并非如此，此类服务器中比较著名的当属IBM的Z系列服务器。这一款号称“永不宕机”的服务器在2013年也走下了神坛。中国银行所使用IBM的Z系列服务器出现了长达4小时的宕机，造成了巨大的损失。\n\n![f5](http://outwcl4zh.bkt.clouddn.com/5.jpg)\n    银行所用的IBM Z系列服务器\n\n  那么大型机也宕机，云服务器宕机么？也会有的。不久前谷歌云刚刚全面中断18分钟，而亚马逊云也曾在2013年出现了40分钟的宕机。而且相比普通的服务器宕机问题，云服务器会显得更为严重。由于公有云用户并不具有控制权，所以能做到就只剩下等待和祈祷了。\n\n  世界上真的完全没有不宕机的服务器吗？也是有的，美国2004年发射的机遇号火星探测器，从登陆火星到现在已经十余年，从未发生任何故障。该探测器便是采用双机冗余接口的方式搭载了两台IBM P series服务器。\n\n![f6](http://outwcl4zh.bkt.clouddn.com/6.jpg)\n   机遇号火星探测器\n\n  如果说宕机是偶尔的风雨，那么不宕机才是服务器支撑起整个互联网行业的脊梁。文章最后，用一张表来为大家总结一下为什么服务器能够不宕机。\n\n![f7](http://outwcl4zh.bkt.clouddn.com/7.jpg)\n\n  永不宕机在生活中或许只是一个神话，并非每台服务器都能陪你到老。在经历了太多的风霜后，宕机在所难免。我们不是不会宕机，只是在努力不想让你们看见，谁让我们的名字叫做“服务”呢。\n\n文章转载自[大篆科技](http://blog.sina.com.cn/s/blog_162fcae490102wf94.html)","tags":["认知提升"],"categories":["资源分享"]},{"title":"Webpack学习笔记","url":"/2017/11/Webpack.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n# 什么是Webpack？\nWebpack的中文叫法--我更愿意叫它“前端自动化构建工具”，是用来进行模块化加载并且打包的，它能把各种资源，例如图片、js文件、css预处理语言等等，统统进行处理，打包成符合生产环境部署的前端资源。\n\n模块化的问题解决之后，webpack 就能把各种资源模块打包合并成一个文件输出给浏览器。在打包的过程中还能对这些资源进行处理，比如压缩减少体积，把 sass 编译成 css, coffee 编译成 js。所以它在某些程度上，跟 grunt/gulp 的功能有些相同。\n![Webpack工作模式](http://outwcl4zh.bkt.clouddn.com/webpack.jpg)\n# 与grunt/gulp的区别\ngrunt/gulp 强调的是前端开发的工作流程，我们可以通过配置一系列的 task，定义 task 处理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等），然后定义执行顺序，来让 grunt/gulp 执行这些 task，从而构建项目的整个前端开发流程。\n![grunt/gulp](http://outwcl4zh.bkt.clouddn.com/gulp+grunt.png)\n\n\n\n\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"编程相关-杂（Relative）","url":"/2017/11/relative.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n```\n<li> vscode</li>\n<li> atom</li>\n<li> webstrom</li>\n<li>sublime的插件问题</li>\n<li>emmet</li>\nemmet插件的简单使用规则：div.demo#only*3>p[style=\"background-color:orange;width:100px;height:100px;\"]\ndiv>(p^span.demo#only{内容})\nul>li{a$}*10\n```\n# Sublime Text 3 快捷键精华版:\nCtrl+Shift+P：打开命令面板\nCtrl+P：搜索项目中的文件\nCtrl+G：跳转到第几行\nCtrl+W：关闭当前打开文件\nCtrl+Shift+W：关闭所有打开文件\nCtrl+Shift+V：粘贴并格式化\nCtrl+D：选择单词，重复可增加选择下一个相同的单词\nCtrl+L：选择行，重复可依次增加选择下一行\nCtrl+Shift+L：选择多行\nCtrl+Shift+Enter：在当前行前插入新行\nCtrl+X：删除当前行\nCtrl+M：跳转到对应括号\nCtrl+U：软撤销，撤销光标位置\nCtrl+J：选择标签内容\nCtrl+F：查找内容\nCtrl+Shift+F：查找并替换\nCtrl+H：替换\nCtrl+R：前往 method\nCtrl+N：新建窗口\nCtrl+K+B：开关侧栏\nCtrl+Shift+M：选中当前括号内容，重复可选着括号本身\nCtrl+F2：设置/删除标记\nCtrl+/：注释当前行\nCtrl+Shift+/：当前位置插入注释\nCtrl+Alt+/：块注释，并Focus到首行，写注释说明用的\nCtrl+Shift+A：选择当前标签前后，修改标签用的\nF11：全屏\nShift+F11：全屏免打扰模式，只编辑当前文件\nAlt+F3：选择所有相同的词\nAlt+.：闭合标签\nAlt+Shift+数字：分屏显示\nAlt+数字：切换打开第N个文件\nShift+右键拖动：光标多不，用来更改或插入列内容\n鼠标的前进后退键可切换Tab文件\n按Ctrl，依次点击或选取，可需要编辑的多个位置\n按Ctrl+Shift+上下键，可替换行\n选择类\nCtrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。\nAlt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。\nCtrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。\nCtrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。\nCtrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。\nCtrl+M 光标移动至括号内结束或开始的位置。\nCtrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。\nCtrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。\nCtrl+Shift+[ 选中代码，按下快捷键，折叠代码。\nCtrl+Shift+] 选中代码，按下快捷键，展开代码。\nCtrl+K+0 展开所有折叠代码。\nCtrl+← 向左单位性地移动光标，快速移动光标。\nCtrl+→ 向右单位性地移动光标，快速移动光标。\nshift+↑ 向上选中多行。\nshift+↓ 向下选中多行。\nShift+← 向左选中文本。\nShift+→ 向右选中文本。\nCtrl+Shift+← 向左单位性地选中文本。\nCtrl+Shift+→ 向右单位性地选中文本。\nCtrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。\nCtrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。\nCtrl+Alt+↑ 向上添加多行光标，可同时编辑多行。\nCtrl+Alt+↓ 向下添加多行光标，可同时编辑多行。\n编辑类\nCtrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。\nCtrl+Shift+D 复制光标所在整行，插入到下一行。\nTab 向右缩进。\nShift+Tab 向左缩进。\nCtrl+K+K 从光标处开始删除代码至行尾。\nCtrl+Shift+K 删除整行。\nCtrl+/ 注释单行。\nCtrl+Shift+/ 注释多行。\nCtrl+K+U 转换大写。\nCtrl+K+L 转换小写。\nCtrl+Z 撤销。\nCtrl+Y 恢复撤销。\nCtrl+U 软撤销，感觉和 Gtrl+Z 一样。\nCtrl+F2 设置书签\nCtrl+T 左右字母互换。\nF6 单词检测拼写\n搜索类\nCtrl+F 打开底部搜索框，查找关键字。\nCtrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。\nCtrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。\nCtrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。\nCtrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。\nCtrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。\nCtrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。\nEsc 退出光标多行选择，退出搜索框，命令框等。\n显示类\nCtrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。\nCtrl+PageDown 向左切换当前窗口的标签页。\nCtrl+PageUp 向右切换当前窗口的标签页。\nAlt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）\nAlt+Shift+2 左右分屏-2列\nAlt+Shift+3 左右分屏-3列\nAlt+Shift+4 左右分屏-4列\nAlt+Shift+5 等分4屏\nAlt+Shift+8 垂直分屏-2屏\nAlt+Shift+9 垂直分屏-3屏\nCtrl+K+B 开启/关闭侧边栏。\nF11 全屏模式\nShift+F11 免打扰模式\n\n# 微信小程序的一些简单简介：\n微信小程序中没有关联或者引入标签，只能靠相同的命名来产生关联，比如：index.wxml--index.wxss--index.js--index.json;只能命名相同的名字，然后微信页面就会自动找相同名字来进行关联了。自动进行绑定关联，根据命名把一些东西捆绑在一起。\nrpx：就是最开始是为了不让在苹果手机上失真而人为设置的一种与真实的px（像素）所在不同手机上的换算关系。所以rpx也就具有了根据不同屏幕进行自适应的功能了。\nwxml上并没有通配符选择器，但是有json配置文件。没有body标签，但是有pages标签就相当于html中的body标签了。\nwxml中有很多强大的内置标签，也就是人为封装的组件，恩，很强大的。例如：轮播图组件<swiper>标签，下面有<swiper-item>，<swiper>上有autoplay属性，并伴随着interval=\"时间\"，是否采用衔接滑动circular=\"true\";\n图标<icon>组件：上面有不同的类型：type='success/info/..' color=\"color\";\n地图<map>组件：map组件上还有很多其他的标签和属性方法。总之很强大了！\n\nwxml没有dom节点，不能像JavaScript一样操作dom元素。但是wxml给了我们一个数据绑定的.js文件。里面有page({});函数调用的形式。通过调用page()这个函数，来注册了一个页面，通过改变page()这个函数来影响UI层面的东西。page()函数里面有一些函数来监听页面的渲染。\n生命周期函数：`onLoad:function(options){}`--监听页面加载。\n生命周期函数：`onReady:function(){}`--监听页面初次渲染完成。\n生命周期函数：`onShow:function(){}`--监听页面显示\n生命周期函数：`onHide:function(){}`--监听页面隐藏\n生命周期函数：`onUnload:function(){}`--监听页面卸载\n生命周期函数执行的顺序为：页面先加载触发`onLoad`函数；再调用`onShow`函数；之后再调用onReady函数。\n\n两个层---一个给用户看的视图层，另一个应用层js操作视图层。\n首先是视图层的初始化init..和应用层的创建creat..一个实例\n视图层向应用层要一些初始化是数据。切换页面，那么这个页面生命周期就结束了，调用`onUnload`函数。this就代表这个页面实例。\n\n## 编写微信小程序的简单步骤：\n首先会在app.json文件下查找我们所配置的东西，创建的页面，页面之间的关联还有页面的导航栏（最顶上的一栏）的设置和底边的tabpar分页的切换设置等等都是在这儿实现的。在app.json中配置好了主页面和分页面之后就可以开始编写代码了。\n如何在微信地图上添加功能按钮：因为在地图上添加`<button>`按钮是显示不出来的，因为map组件的层级永远在最上面，只能用map组价提供好的controls属性，配合监听对control的点击的回调函数。然后在.js文件中有wx.getSystemInfo这个方法监听设备信息来获取需要设置的相应数据。\nbindcontroltap，在onShow函数内定义一个app-map执行器上下文（类似canvas的执行期上下文），这个执行器上下文中有一个方法是moveToLocaltion方法，定义一个movetoCenter方法就是执行moveToLocation方法的，然后在switch case中，case到指定的controlId就调用定义好的movetoCenter方法。\n\n模拟假数据的一个很好用的网站，easy-mock网站，恩，很有年头了。简单的使用：直接进去没有用户名他直接会让你登录，没有的话就会直接帮你注册成功了。注册成功直接创建项目就行了。非常简单就能使用的。假数据写成JSON形式的，然后窗口打开，复制窗口URL地址，然后就能使用这个假数据了。\n\nhttp://easy-mock.com/mock/5983e3d1a1d30433d852e683/ofo/getbike\n\n## a++ 和 ++a 的区别：\n    他们都是已经执行了代码，也就是都已经加一了。但是++a是显示的加上去了，也就是说显示出来了，但是a++是到下一次执行才显示出来，但是上一次的代码已经执行了。ok？\n\n## 命名上的一些英文单词：\nwrapper：包装；\nnavigation：航行（学），航海（术），海上交通；\ncontain：内容；\nfooter: 页脚；\nheader： 页头；\n未完待续...","tags":["others"],"categories":["开发工具"]},{"title":"Npm相关问题","url":"/2017/11/npm.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n简单的来说npm就是nodejs的包管理工具。\n\n所以说到它就不得不提一下nodejs这个前端发展中出现的里程碑式的后端JavaScript语言。让我们摆脱了浏览器这一个单一的环境限制，开始向后端迈进。\n\n正是由于nodejs的火爆发展，也带动着前端JavaScript模块化的步伐。由于后端开发是非常复杂的，所以必须使用模块化的开发模式，而随着前端也越来越复杂的应用开发，所以类似后端开发中的模块化开发不得不应用到前端中来了。\n\n# 前端模块化开发带来的好处\n\n## 命名冲突\n随着前端开发应用的复杂度越来越高，应用开发的团队成员也越来越多，不可避免的就有了命名上的一些冲突，为了解决命名冲突所带来的问题，我们可以用模块化的思想，把各个功能封装在一个模块中。\n\n## 文件依赖\n在JavaScript中，由于语言的单线程性质，如果要加载一个js文件，而这个文件依赖于很多个其他的js文件，那么就要很小心的处理加载的先后顺序问题，先把依赖加载进来，在加载依赖这些js的js文件。说起来很拗口哦~（没办法，就这个表达能力啊~）比如：\n`<script src=\"util.js\"></script>\n<script src=\"dialog.js\"></script>\n<script>\n  org.CoolSite.Dialog.init({ /* 传入配置 */ });\n</script>`\ndialog.js依赖util.js文件中的一些方法，所以必须先要加载完成util.js文件才能正常使用dialog.js中的方法。\n上面讲的是最简单的文件依赖问题的一些使用方法。但是像上面那样使用很麻烦，所以借鉴后端node的模块化方法，前端引入了类似YUI3库的加载方法，简单实用还美观，如下：\n`YUI.add('my-module', function (Y) {\n  // ...\n}, '0.0.1', {\n    requires: ['node', 'event']\n});`\n\n上面的代码，通过 requires 等方式来指定当前模块的依赖。这很大程度上可以解决依赖问题，但不够优雅。当模块很多，依赖很复杂时，烦琐的配置会带来不少隐患。\n\n命名冲突和文件依赖，是前端开发过程中的两个经典问题。下来我们看如何通过模块化开发来解决。为了方便描述，我们使用 Sea.js 来作为模块化开发框架。\n\n# 使用Sea.js来解决\n先说一下这些模块的发展吧。前面说了前端模块化是借鉴的node后端模块化的思想。而node又是遵循的服务器端模块的规范-->CommonJs。\n\n## CommonJS （服务器端的模块化规范）\n根据CommonJs规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。如下：\n\n```\n1> math.js\nexports.add = function() {\n    var sum = 0, i = 0, args = arguments, l = args.length;\n    while (i < l) {\n        sum += args[i++];\n    }\n    return sum;\n};\n2> increment.js\nvar add = require('math').add;\nexports.increment = function(val) {\n    return add(val, 1);\n};\n3> main.js，该文件为入口文件\nvar inc = require('increment').increment;\nvar a = 1;\ninc(a); // 2\n```\nCommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，网络请求资源的方式，速度相对较慢，就必须采用异步加载的模式。所以就有了 AMD  CMD 的解决方案。\n模块的要求如下：\n> 标示符require，为一个函数，它仅有一个参数为字符串，该字符串须遵守Module Identifiers的6点规定\n> require方法返回指定的模块API\n> 如果存在依赖的其它模块，那么依次加载\n> require不能返回，则抛异常\n> 仅能使用标示符exports导出API\n\n## AMD（Asynchromous Module Definition）异步模块定义\nAMD 是 RequireJS 在推广过程中对模块定义的规范化产出。\nAMD异步加载模块。它的模块支持 对象、 函数、 构造器、 字符串、 JSON 等各种类型的模块。 \n\n使用AMD规范适用define方法定义模块。如下：\n\n```\n//通过数组引入依赖 ，回调函数通过形参传入依赖 \ndefine(['someModule1', ‘someModule2’], function (someModule1, someModule2) { \n\n    function foo () { \n        /// something \n        someModule1.test(); \n    } \n\n    return {foo: foo} \n}); \nAMD规范允许输出模块兼容CommonJS规范，这时define方法如下： \n\ndefine(function (require, exports, module) { \n     \n    var reqModule = require(\"./someModule\"); \n    requModule.test(); \n     \n    exports.asplode = function () { \n        //something \n    } \n}); \n```\n> 定义模块用module变量，它有一个方法declare\n> declare接受一个函数类型的参数，如称为factory\n> factory有三个参数分别为require、exports、module\n> factory使用返回值和exports导出API\n> factory如果是对象类型，则将该对象作为模块输出\n\n目前，实现AMD的库有 RequireJS  、 curl  、 Dojo  、 bdLoad 、 JSLocalnet  、 Nodules  等。\n\n## CMD\nCMD是SeaJS 在推广过程中对模块定义的规范化产出。\nSea.js 是国内前端大神玉伯写出来的一个成熟的开源项目，核心目标是给前端开发提供简单、极致的模块化开发体验。这里不多做介绍，有兴趣的可以访问 seajs.org 查看官方文档。\n\n使用 Sea.js，在书写文件时，需要遵守 CMD （Common Module Definition）模块定义规范。一个文件就是一个模块。如下：\n```\ndefine(function(require, exports) {\n  exports.each = function (arr) {\n    // 实现代码\n  };\n\n  exports.log = function (str) {\n    // 实现代码\n  };\n});\n通过 exports 就可以向外提供接口。这样，dialog.js 的代码变成\n\ndefine(function(require, exports) {\n  var util = require('./util.js');\n\n  exports.init = function() {\n    // 实现代码\n  };\n});\n```\n关键部分到了！我们通过 require('./util.js') 就可以拿到 util.js 中通过 exports 暴露的接口。这里的 require 可以认为是 Sea.js 给 JavaScript 语言增加的一个语法关键字，通过 require 可以获取其他模块提供的接口。\n\n这其实一点也不神奇。作为前端工程师，对 CSS 代码一定也不陌生。\n\n`@import url(\"base.css\");`\n\n`#id { ... }\n.class { ... }`\nSea.js 增加的 require 语法关键字，就如 CSS 文件中的 @import 一样，给我们的源码赋予了依赖引入功能。\n\n# CMD和AMD的区别有以下几点： \n\n1. 对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式也不同）。 \n\n2. AMD推崇依赖前置，CMD推崇依赖就近。\n```\n//AMD \ndefine(['./a','./b'], function (a, b) { \n    //依赖一开始就写好 \n    a.test(); \n    b.test(); \n}); \n\n//CMD \ndefine(function (require, exports, module) { \n    //依赖可以就近书写 \n    var a = require('./a'); \n    a.test(); \n    ... \n    //软依赖 \n    if (status) { \n        var b = require('./b'); \n        b.test(); \n    } \n}); \n```\n虽然 AMD也支持CMD写法，但依赖前置是官方文档的默认模块定义写法。 \n\n3. AMD的API默认是一个当多个用，CMD严格的区分推崇职责单一。例如：AMD里require分全局的和局部的。CMD里面没有全局的 require ,提供 seajs.use()来实现模块系统的加载启动。CMD里每个API都简单纯粹。 \n\n***\n***\n好了，说完了上面的介绍，该正式讲一下正文了~\n\n# npm 三个版本的区别简介\n如今npm包管理已经有3个版本了，那就来讲一下他们之间的区别吧~\n\n## npm v2解析包的依赖关系\n想像一下现在有三个模块module A、module B、module C。A依赖B的V1版本，C依赖于B的V2版本。 npm采取的方式是把依赖的模块包嵌入子目录。\n\n## npm V3 解析包的依赖关系\nnpm3和npm2的不同之处在于：\n> npm2使用嵌套的方式来管理依赖包，npm3尝试缓和过长的包依赖路径问题。 把二级依赖的包安装在同一级目录下。\n\n假设我们有一个模块A依赖模块B。我们在安装模块A的时候，在项目的node_modules文件夹下： 可以看到 npm v2与npm v3的差异是npm v3中A和B是再同一层文件夹中的，而npm v2中B是再A文件夹下嵌套的。\n\n现在我们需要安装一个模块C，模块C依赖模块B但是版本与模块A依赖的不同。\n\n由于B v1.0已经安装在node_modules目录的根目录下了，不能把B v2.0也安装在根目录下。这个时候npm v3的处理方式和npm v2类似。\n\n通过 npm ls 查看当前项目所有包的依赖关系。如果只是想看顶级包的依赖关系可以执行npm ls --depth=0。\n\n## npm v3去重\n也正因为npm v3版本中的新特性，所以就会出现一些重复的包下载，我们可以用提供给我们的API来进行删除重复的包。\n__npm dedupe__\n\n该命令会删除node_modules顶级目录下没有被使用的模块，并且把被重复依赖的模块移动到顶级目录下。\n\n接下来看一下最新版的npm的一些命令用法吧~\n# npm 最新用法\n## npm install\n用过npm的对这个命令一定熟悉的不能再熟悉了吧~\n`$ npm install <packageName>`\n安装之前，npm install会先检查，node_modules目录之中是否已经存在制定模块。如果存在，就不再重新安装，既是运程仓库已经有了一个新版本，也是如此。\n\n如果你希望，一个模块不管是狗安装过，npm都要强制重新安装，可以使用-f或者--force命令参数。\n`$ npm install <packageName> --force`\n\n## npm update\n如果想更新已安装模块，就要用到npm update命令了。\n`$ npm update <packageName>`\n它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本有更新，就会安装最新版本。\n\n## registry\nnpm update命令怎么知道每个模块的最新版本呢？\n答案是npm模块仓库提供了一个查询服务，叫做registry。以npmjs.org为例，它的查询网址是https://registry.npmjs.org/。\n\n这个网址后面跟上模块名，就会得到一个 JSON 对象，里面是该模块所有版本的信息。比如，访问 https://registry.npmjs.org/react，就会看到 react 模块所有版本的信息。\n\n它跟下面命令的效果是一样的。\n\n`$ npm view react\n# npm view 的别名\n$ npm info react\n$ npm show react\n$ npm v react`\n\nregistry 网址的模块名后面，还可以跟上版本号或者标签，用来查询某个具体版本的信息。比如， 访问 https://registry.npmjs.org/react/v0.14.6 ，就可以看到 React 的 0.14.6 版。\n\n\n# npm 的常用命令行代码：\n1. npm install moduleNames：安装Node包（moduleNames包名称）\n（1）npm install moduleNames -g 为全局安装 \n（2）npm install moduleNames@5.1.1  安装特定版本插件\n（3）npm install moduleNames --save 会在package.json的dependencies属性下添加moduleNames  即发布依赖时候任依赖的插件\n（4）npm install moduleNames --save-dev  会在package.json的devDependencies属性下添加moduleNames依赖 即开发依赖插件\n总结：npm install 在安装 npm 包时，有两种命令参数可以把它们的信息写入 package.json 文件，一个是npm install --save另一个是 npm install --save-dev，他们表面上的区别是--save 会把依赖包名称添加到 package.json 文件 dependencies 键下，--save-dev 则添加到 package.json 文件 devDependencies 键下。\n真正跑在用户浏览器中的代码，比如jquery,react这些，是需要安装到dependencies中的。\n--save是对生产环境所需依赖的声明(开发应用中使用的框架，库),--save-dev是对开发环境所需依赖的声明(构建工具，测试工具).正常使用npm install时，会下载dependencies和devDependencies中的模块，当使用npm install --production或者注明NODE_ENV变量值为production时，只会下载dependencies中的模块。\n2. npm config set registry https://registry.npm.taobao.org  修改包下载源，此例修改为了淘宝镜像\n3. npm config get prefix  查看全局安装路径\n4. npm config set prefix G:/node_modules_global  修改全局安装路径\n5. npm init  初始化目录\n6. npm install -g gulp  全局安装（如gulp）\n7. npm uninstall -g gulp    全局包卸载（如gulp）\n8. npm uninstall gulp --save-dev  项目本地卸载（如gulp）\n9. npm ls --global    会查看到安装包所包含的所有依赖文件   npm ls --global -depth 0  只查看顶级安装包\n10. npm ls  查看本地安装包\n11. npm cache clean  删除安装包缓存\n12. npm  update xxx  更新安装包\n13. npm search xxx  查找验证某个包是否已经存在\n14. npm root 查看当前包安装路径  npm root -g  查看全局包安装路径\n15. npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新\n16. npm view xxx engines：查看包所依赖的Node的版本\n17. npm view xxx repository.url：查看包的源文件地址\n18. npm view xxxpendencies：查看包的依赖关系","tags":["node"],"categories":["开发工具"]},{"title":"Math.floor()等方法的用法","url":"/2017/11/Math.floor()方法.html","content":"\n## Math.floor()方法的深层解析\n  大家都知道这是一个JavaScript的基础的方法---向下取整，但是你们有没有遇到过这个方法不听话呢？哈哈，接下来就让我们来领教一下这个方法什么时候才会出现不听话吧！\n  `!function test(){\n\t\t\tvar is = 100;\n\t\t\twindow.setInterval(function(){\n\t\t\t\tis = is/7;\n\t\t\t\tMath.floor(is);\n\t\t\t\tconsole.log(is)\n\t\t\t},10)\n\t\t}()`\n        这个方法之后的结果为14.124235...\n这段代码中就用到了Math.floor()这个方法，但是这个方法就在这个时候不听话了，is这个变量居然一直取到了小数点后好多好多位。这是为什么呢？其实并不是这个方法不好用了，只是我们把这个方法用错了而已，因为is这个变量是一个Number类型的数字，是一个原始值（栈类型）不可改变。所以上面的代码我们访问的其实还是原来的is的值，并没有访问Math.floor()之后的is值。\n我们可以这样访问到Math.floor()之后的is值。代码如下：\n`!function test(){\n\t\t\tvar is = 100;\n\t\t\twindow.setInterval(function(){\n\t\t\t\tis = is/7;\n\t\t\t\tconsole.log(Math.floor(is);)\n\t\t\t},10)\n\t\t}()`\n这样之后的结果就是14了。\n通过这篇文章，只是想告诉你，JavaScript语言的一些值的类型，有引用值和原始值，引用值也就是堆数据类型的值，原始值在JavaScript语言中有undefined、Number、Boolean、String等，并且不同的值类型之间的不同的区别是什么，尤其重要的是千万不要试图去改变原始值，因为你真的拗不过他们的！哈哈，好了，就这样了。","tags":["JavaScript"],"categories":["基础方法分享"]},{"title":"Js笔记","url":"/2017/11/js笔记.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n## js笔记\ntypeof 识别不了Object与Array与null（历史遗留性问题）\n返回六种数据类型number、string、booblean、undefined、object、function。\n\n隐示类型转化：Number()类型的数据转化，typeof之后会把true返回数值1，false返回值为0。“123”转化成123。undefined转化成数值NaN。null转化成数值0。“”空字符串转化成0。\n\nparseInt(\"123abc\")会把字符串类型的转换成整数类型Number类型的123，并且在非数字位置截断。但是只会把其它的undefined和null和true、false等转化NaN。    parseInt（“123”，radix）radix是基底，取值范围是2--36（0也行，有的浏览器中会把0当做10进制的数）。填上第二位的话会把前面的123按照所填的基底转化成10进制的数。\n\n只有六个值转化成booblean值为false，分别是undefined、null、0、\"\"、false、NaN。其它所有转化成boollean值都为true。\n\n&& 与运算符，找到一个false就返回。如0 && 1；直接返回值0。1 && 2 && 3；返回值为3。全真才为真，有一个假就是假；\n\n|| 或运算符， 找到一个真就返回。如0 || 1 || 2，返回值为1。1 || 0，返回值为1。全假才为假，有一个真就是真。\n\nparseFloat(\"10.234\")可以把字符串类型的转化成小数类型的数值类型，即浮点型。\n\nString（undefined）--> \"undefined\"  会把一切东西转化成字符串类型的。\n\n对象.toString方法，与String相似，只不过他是一种方法。只有undefined和null没有这个方法，不能调用这个方法。toString(radix),这个radix跟parseInt中的radix正好相反。按照10进制转换成所填基底的数。\n\n数学符号有隐式类型转换，只有+号特别，会与字符形式的连接起来。\n\nnull == undefined返回结果为true。 0 == \"\"返回结果为true。\n\n对象.toFixed(3)方法表示的是保留小数点后3位有效数字，科学计数法。\n\n作用域：当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，   ！！它所产生的！！！  执行期上下文被销毁。\n   查找变量：从作用域的顶端依次向下查找。\n\n ` function a() {\n\tfunction b() {\n\t\tconsole.log(b);\t\n\t}\n  \tvar a = 123;\n\tb();\n  }\n  var glob = 100;\n  a();`\n函数a的执行也就是函数b定义的开始，函数b在刚定义的时候就保存了函数a的劳动成果。变量只有在执行的时候才会被赋值。\n\n   闭包\n`   function a() {\n\tvar arr = [];\n\tfor(var i = 0; i < 10; i++) {\n\t\tarr[i] = function () {\n\t\t\tconsole.log(i + \",\");\n\t\t}\n\t}\n\treturn arr;\n   }\n   var demo = a();\n   for(var j = 0; j < 10; j++) {\n\tdemo[j]();\n   }`\n上题中的i与函数形成闭包，所以结果会打印出10个10。题中的i在函数还没执行时不会被赋值，要等到函数最后执行的时候才会进行赋值，函数执行时for循环就已经转了10圈了，所以i直接进行赋值就成了10个10。运用立即执行函数可以每一圈都让i赋值。\n我们想要依次打印出i从0到9，但是这样的话就打印不出来我们想要的结果。所以只能靠闭包才能实现我们想要的结果。如下：\n\n\n` function a() {\n  var arr = [];\n  for(var i = 0; i < 10; i++) {\n    (function (j) {\n      arr[j] = function () {\n        console.log(j);\n      }\n    }(i))\n  }\n  return arr;\n   }\n   var demo = a();\n   for(var j = 0; j < 10; j++) {\n  demo[j]();\n   }`\n值得注意的是这个函数中的demo是一个数组，执行时不能像demo()这样，需要如上题那样进行。\n\n\t闭包会导致原有作用域链不释放，造成内存泄露。闭包会导致多个执行函数共用一个公有变量，如果不是特殊需要，应尽量防止这种情况放生。\n一个函数连续执行的话会在他之前形成的作用域链上再作用。\n\n闭包的作用：1、公有变量   累加器（多次调用的是一个变量）\n\t   2、可以做缓存，存储变量   （操作的是同一个变量，把变量放在那儿，多个函数都使用它）   3、模块化开发，防止污染全局变量   4、私有化变量\n` function Deng () {\n  var prepareWife = \"xiaozhang\";\n  var obj = {\n    name : \"dengxuming\",\n    age : 40,\n    sex : \"male\",\n    wife : \"xiaoliu\",\n    divorce : function () {\n      delete this.wife;\n    },\n     getMarried : function () {\n      this.wife = prepareWife;  \n    },\n    changePrepare : function (someone) {\n      prepareWife = someone;\n    },\n    sayMyWife : function () {\n      return this.wife;    }\n    }\n    return obj;\n    }\n    var deng = Deng();`\n\n\n  立即执行函数：此类函数没有声明，在一次执行过后即释放。适合做初始化工作。\n（function () {}）()  就是长这个样子。执行完就被销毁，所以一般不写名。    只有表达式才能被执行。123就是一个表达式。函数声明不能被执行。成等式就是表达式。表达式被执行完了它就会被销毁，就找不到了。例如下面这个例子：\n`  var a = function () {\n                              console.log('a');\n                            }()  \n                          \n                          \n                            + function () {\n                              console.log('a');\n                            }()  `                          (在函数声明之前加上+ - ！之后也能执行)\n这个函数执行完之后就不能找到a函数了。\n\n  认识对象\n`  var mrYao = {\n  firstName : \"xiaoyao\",\n  lastName : \"yao\",\n  age : 99,\n  handsome : false, \n  son : {\n    name : wang,\n    age : 180\n  }\n  wife : {\n    name : zhou,\n    age : 90    \n  }\n  smoke : function () {\n    console.log('I am smoking, cool');  \n  }\n  drink: function () {\n    console.log('I am drinking');\n  }\n  }`\n  对象可以增删改查！\n  delete后面加空格，就是使用这个方法，可以把对象的属性和方法删除。\n\n对象的创建方法有  1、字面量   2、构造函数  （系统自带 new Object（）；Array（）；Boolean（）；String（）；自定义）  3、\n\n系统的构造方法 var obj = new Object();就相当于var obj = {};叫：对象字面量/对象直接量\n\n系统的构造方法不够好，可以自定义构造函数。\n\n`function Person() {\n\n}\nvar person = new Person;`\n自定义构造函数大头风原则。\n\n\n\n构造函数内部原理。使用new操作符会在内部隐式的进行三部曲。\n1、在函数最前面隐式的加上this = {}  2、执行 this.xxx = xxx;\n  3、隐式的(return)返回this\n通过new出来的对象，如果你手动的加上return返回一个引用值的时候，那么系统的new隐式进行的三部曲中的第三步就不能返回this了，而会返回手动加上的return的东西。但是只要你手动加上的return返回的结果不是引用值，而是原始值的话不影响构造函数的内部原理的。\n\n包装类。给原始值加属性、方法，访问原始值的属性、方法等等，都是包装类干的。系统内部自动给你加的。例如：\n`  var num = 123;\n  num.abc = 'a';\n  console.log(num.abc);`结果为：undefined\n因为num是一个原始值，数字类型的，系统会在内部隐式的给你转换成系统内部的Number对象，给你new出来。不过系统隐式的给你new出来之后没有保存他，只是没有让他报错，也并没有保存起来，所以访问不到他。再例如：\n`  var str = 'abcd';\n  str.lenth = 2;\n  console.log(str.length);`结果为：4\n因为str是一个字符串类型的原始值，他上面并没有.length方法，但是系统会把它隐式的new出来，new String（str）.length也就是4了。\n\n\n原型  ：原型是对象function的一种属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。\n利用原型特点和概念，可以提取共有属性。\n对象如何查看对象的构造函数，constructor。\n`Person.prototype.name = \"abc\";\nfunction Person() {\n}\nvar person = new Person();\nPerson.prototype.name = \"bcd\";\nconsole.log(person.name);`\n结果为：bcd   (因为这是直接赋值的。注意跟下一题的区别。这个是原始值也就是在栈里面存着)\n\n`Person.prototype = {\n name : \"abc\"\n}\nfunction Person() {\n}\nvar person = new Person();\nPerson.prototype = {\n   name : \"bcd\"\n}\nconsole.log(person.name);`\n结果为：abc     (因为这个是引用值也就是在堆内存里面存着。而且这个person是Person  new出来的，所以有隐式的三步，在this里面会有__proto__=Person.prototype。而new又在第二次引用赋值之前，所以并不会改变name的值，因为__proto__已经提取到第一个name的值了)\n\n\n `  Son.prototype = {\n      eat : function () {\n        this.height ++;\n        card : [100, 200]\n      }\n    \n       };\n       function Son() {\n      this.height = 100;\n       }\n       var son = new Son;\n       son.eat();   101\n       son.eat();   102\n       son.card.pop();`   200   拿出来200，原型里面就没有200了\n\n  son 可以调用父亲Son的值，但是并不能改变父亲Son中的值。也就是说son.__proto__.height的值永远都是100。\n\n\n绝大数对象的最终都会继承自Object.prototype\n`var demo = {\n  name : 'abc',\n  age :234\n  }\nvar obj = Object.create(demo); `\n创建一个obj对象是以demo为原型的对象。括号里必须填东西，想要创建一个没有原型的对象里面要填null。\n\n\n一个对象上的__proto__是追到他的父级的原型链上的，所有的对象的__proto__都会追到系统的Object上的，所以Object上就没有__proto__了。如果改变了一个对象上的__proto__就相当于改变了他的原型链，也就是改了他的父级的.prototype原型链了。原型链是一个对象，对象是引用值，修改的话就是换地址的，原先的空间并不会换的。比如：\n`var obj = {name:\"a\"}; var obj1 = obj; obj = {name:\"b\"};console.log(obj1.name)`;结果为：a    ()\n\n\n`var obj = {};\n document.write(obj); ` 打印结果为：[object Object]   因为打印一个文档流的话会隐式的把obj上的toString方法的结果给你打印出来。例如：`var obj = Object.create(null);obj.toString = function () {return '邓哥身体好'；}  document.write(obj);`  结果为：邓哥身体好\n但是数字类型的，布尔类型的，数组类型的他们toString出来的就不是[object Object]形式的，因为他们的原型上就有重写的toString方法。    \n\ntoString方法是在原型链上的，所以一般都有，可以完全的分别出来对象，数组等等。但是undefined和null没有toString，因为他俩没有原型链。数字有toString，但是不能直接123.toString，因为数字后面跟着小数点会把这个小数点当做是浮点类型的小数点的。\n\n浏览器有一个存在的bug。就比如0.14*100结果就为140.0000000002；精度不准的问题。\nMath.radom().这是生成0-1之间的随机数，比如：for(var i = 0; i < 10; i ++) {var num = Math.random().toFixed(2) * 100;\nconsole.log(num);} 这个就会出现精度不准的问题，就说因为计算机的精度不准，在处理小数不准是因为计算机是基于二进制编码的原因，无法修改的bug。toFixed()就有这个问题。上一题解决的办法就是不用toFixed()在最后取整用floor。比如：for(var i = 0; i < 10; i ++) {var num = Math.floor(Math.random() * 100);  console.log(num);}这次取整就不会出现不精准的问题了。\n\n函数.call方法的使用。test()其实就是test.call();这个方法可以改变this的指向。括号里面的第一位参数就是this指向的对象，第二位开始可以放正常的参数了。缺点就是还调用了另一个函数，如下：\n`function Wheel(wheelSize, style) {\n  this.style = style;\n  this.wheelSize = wheelSize;\n}\nfunction Sit(c, sitColor) {\n  this.c = c;\n  this.sitColor = sitColor;\n}\nfunction Model(height, width, leng) {\n  this.height = height;\n  this.width = width;\n  this.leng = leng;\n}\nfunction Car(wheelSize, style, c, sitColor, height, width, leng) {\n  Wheel.call(this, wheelSite, style);\n  Sit.call(this, c, sitColor);\n  Model.call(this, height, width, len);\n}\nvar car = new Car(100, '花里胡哨的', '真皮座椅舒适'， 'red', 1800, 1900, 4900);`\n企业开发的模块化，最后完工的成品是多个拼接起来的。\n\ncall 和apply的区别：call需要把实参按照形参的个数传进去；   apply需要传一个arguments数组。\ncall和apply都是改变this指向，区别就是传参列表不同。\n\n\ntypeof (new Array).__proto__.constructor()\n结果为：\"object\"     解析：先算括号里面的，再算点。优先级顺序。形式上又有typeof的两种形式的用法。\n\n计算输入变量的字节长度，汉字的Unicode长度大于255，英文字母的Unicode长度小于等于255；\n`var str = \"kjfhasdkjf生命在于学习\"\nfunction bytestLength(str) {\n   var count = str.length;\n   for(var i = 0; i < str.length; i++) {\n  if(str.charCodeAt(i) > 255) {\n     count ++;\n  }\n  }\n  return count;\n}\n或者\nvar str = \"aldshfuioasdhf\";\nfunction bytestLength(str) {\n   var count = 0;\n   for(var i = 0, len = str.length; i < len; i ++) {\n  if(str.charCodeAt(i) > 255) {\n     count += 2;\n  }else {\n     count ++;\n  }\n   }\n   return count;\n}`\n\n\n继承发展史：\n1、传统形式---->原型链    缺点：过多的继承了没用的属性\n2、借用构造函数   也就是用call或者apply的方法，其实是调用跟自己完全囊括的属性才能使用的，多调用了一次构造函数浪费效率了。    缺点：不能继承借用构造函数的原型； 每次构造函数都要多走一个函数\n3、共享原则，共有原型。     缺点：不能随便改动自己的原型\n\n圣杯模式：(构造函数想完全继承自父亲的原型，并且还可以添加自己特有的原型)\n`Father.prototype.lastName = \"Deng\";\nFather.prototype.sex = \"male\";\nfunction Father() {\n\n}\nfunction Son() {\n\n}\nfunction inherit(Target, Origin) {\n   function F() {};\n   F.prototype = Origin.prototype;\n   Target.prototype = new F();\n   Target.prototype.constuctor = Target;\n   Target.prototype.uber = Origin.prototype;\n}\ninherit(Son, Father)\nvar son = new Son();\nvar father = new Father();`\n\n\n\nyahoo的YUI3库现在不用这个了。现在都用jQuery库了。YUI3库是这样写的  \n`var inherit = (function () {\n      var F = function () {};\n      return function (Target, Origin) {\n      F.prototype = Origin.prototype;\n      Target.prototype = new F();\n      Target.prototype.constuctor = Target;\n      Target.prototype.uber = Origin.prototype;\n      }\n    }()); `    运用闭包的私有化变量属性。必须熟练掌握闭包的属性特点。\n\n\n命名空间的问题。防止污染全局变量。一般解决办法就是使用立即执行函数，在立即执行函数里命名变量，变量会成为私有化变量，也就是利用闭包的特点。init初始化、入口。\n\n\n对象还有一种访问属性的方法，除了obj.name访问对象obj的name属性，还可以obj['name'];浏览器在执行obj.name的时候回隐形的转换成name转换成字符串类型的形式执行，所以用字符串的形式更加快，有效率。而且使用字符串的形式这种方法更加的方便，在以后的使用中，字符串的使用频率更加高的。\n\n\n\n\n对象、数组的遍历、枚举；`var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; for(var i = 0; i < arr.length; i++) {console.log(arr[i]);}`\n\n遍历对象的话就要用到for-in 循环了；\n  `var obj = {\n       name : 'abc',\n       age : 123,\n       sex : 'male',\n       height : 180,\n       weight : 75\n     }\n     for(var prop in obj) {\n     console.log(obj.prop);` 这里有一个错误哦~！应该写成obj[prop]的形式。\n  }\n obj.prop---->就相当于obj[\"prop\"]，因为系统会隐式的把前面的改成后面的这种形式。\n  这里有一个问题，用对象.prop的话，会访问这个对象上的属性。不过这个对象上并没有prop的属性，所以最后会打印出5个undefined。所以应该写成对象[name]属性的形式。记住哦~！！！\n\n  这样遍历对象的话会把原型上的属性也会给遍历出来，但是不包括系统自己原型上本来就有的，只是自己手动设的才会连着打印出来的。所以要是只想遍历这个对象本身的属性的话，应该先判断一下是否属于自身的属性，用到的方法就是对象.hasOwnProperty\n\n还有一个跟hasOwnProperty差不多的方法就是in，他的作用就是看一下对象上有没有这个这个属性，比如看一下对象是否有name的属性，就是：'name' in obj;属性值必须是字符串形式的。返回值是布尔类型的值。但是有一个缺点就是不管这个属性是不是你本身的，你父亲的他返回值也是true。\n\n\ninstanceof\n\neg:\n`function Person() {};\n  var person = new Person();\n  person instanceof Person; `  返回结果为：true  看person是不是Person构造出来的；但是   person instanceof Object;  返回结果也为：true；   结论：看A的原型链上有没有B的原型，在原型链上的也认为是，所以这是往原型链上找的。\n\ninstanceof 方法检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true，如果不在怎返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错（类似空指针异常）。\n还有一个方法很像in的方法，他就是instanceof。官方给出的解释是 A对象是不是B构造函数构造出来的。 比如：A insftanceof B。\n但是官方的解释是远远不够的，只要是在原来对象原型链之上的他的返回结果都是true。所以其实他的意思应该是：看一下A对象的原型链上有没有B的原型，也就是找祖先的，往原型链之上找到。所以instanceof解决了一个问题，就是typeof方法不能精确判断出来的问题。\neg：var arr = [] || {};\n传进去一个变量，这个变量有可能是数组也有可能是对象，如何判断出来；有三种区分方法：\n1. 用constructor可以区分出来\n  [].constructor   返回结果为：function Array() {  {native code}  }\n var obj = {};\n  obj.constructor   返回结果为：function Object() {  {native code}  }  \n2. 用instanceof可以区分出来\n  [] instanceof Array\n  返回结果为：true\n  var obj = {};\n  obj instanceof Array\n  返回结果为：false\n3. 用toString方法可以区分出来（一般也都是用这种方法区分的）\n  数组、对象等等都有自己的toString方法\n  Object.prototype.toString.call([]);调用数组的toString方法  返回结果为：\"[object Array]\"\n  Object.prototype.toString.call({});调用对象的toString方法  返回结果为：\"[object Object]\"\n  Object.prototype.toString.call(123);调用数字的toString方法  返回结果为：\"[object Number]\"\n  toString方法可以准确区别出来数组和对象。并且在有父子页面的情况下也能准确识别出来，其他的两种方法就不能在子页面中识别出来父页面下类型了。所以一般我们都是用toString方法来区分的。\n\n\n\n深度克隆：遍历对象  for(var prop in obj)\n\t1. 判断是不是原始值   typeof()  object\n\t2. 判断是数组还是对象，有三种方法：instanceof   toString  constructor  一般用toString方法，因为如果在原先的页面上再引入一个页面的话，引入进来的页面中的数组和对象就不符合原先的原则了，而toString方法则不会发生这种引用错误。\n\t3. 建立相应的数组或对象\n\t递归的方法。(必须找出口)\n\n`var obj = {\n  name : 'abc',\n  age : 123,\n  card : ['vasa', 'master'],\n  wife : {\n  name : 'bcd',\n  son : {\n    name : 'aaa'\n  }\n  }\n}\n\nfunction deepClone(origin, target) {\n  var target = target || {},\n      toStr = Object.prototype.toString,\n      arrStr = \"[object Array]\";\n  for(var prop in origin) {\n      if(origin.hasOwnProperty(prop)) {\n  if(origin[prop] !== 'null' && typeof(origin[prop]) == 'object') {\n    if(toStr.call(origin[prop]) == 'arrStr'){\n       target[prop] = [];\n    }else{\n       target[prop] = {};\n    }\n    deepClone(origin[prop], target[prop]);\n    }else{\n    target[prop] = origin[prop];\n    }\n  }\n  }\n  return target;\n}\nvar target = deepClone(obj);`\n\n\n三步运算符：?:\n  条件判断  ？  是  ： 否  表达式运算之后会返回值\n条件判断？前面的，条件成立的话执行：前面的运算表达式，条件不成立的话执行：后面的运算表达式。\nvar num = 1 > 0 ? (\"10\" > \"9\" ? 1 : 0) : 2;\n结果为：0   （字符串形式的数字比较是逐位比较ASCII（阿斯克码）表）\n\n\n\n数组\n字面量 var arr = [];\nvar arr = [,,];  arr的结果为2个undefined。\nvar arr = [1,2,3,,,,7,8]\n\n系统的构造方法：var arr = new Array(10.2);这样会报错的。只填一位的话会形成稀松数组，也就是var arr = new Array(10);会形成10位值为undefined的数组。还可以溢出读和写。\n\n数组常用的方法：\n改变原数组：push,pop,shift,unshift,sort,reverse\n\t   splic\n\npush方法是在数组的最后添加参数，可以添加多位；\npop方法是在数组的最后剪切一位出来，并且（）里面不支持添加参数，添加也没啥用，所以每次只能剪切一位出来；\nshift方法是在数组的最前面剪切一位出来；\nunshift方法是在数组的最前面添加参数，并且可以添加多位；\nreverse方法会把原数组逆转顺序。\nsplice()括号里填参数：第一位参数是从第几位开始，第二位参数是截取多少的长度，再往后面填的参数就是在切口处添加的参数，可以无穷多个了。切的刀口就在光标处，一般splice方法用的是添加数组的比较多。而且还可以在负数位开始截取。\n\nsort方法是给数组按照升序排序的方法，而且是按照字符串阿斯克码进行排序的。所以一般是我们自己给sort()方法设置他的排序方法。\n1、必须写两个形参   2、看返回值（1）当返回值为负数是，那么前面的数放在前面（2）为正数，那么后面的数在前 （3）为0，则不动\n   冒泡排序的规则；\narr.sort(function(a, b) {\nif(a > b) {\n  return 1;\n}else {\n  return -1;\n}\n});\n\n简写这个代码的话就是;\n`arr.sort(function(a, b) {\n  return a - b;   升序\n  return b - a;   降序\n})\n`\n\n给一个有序的数组，乱序\n`var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\narr.sort(function() {\n  return Math.random() - 0.5;\n});\n`\n按照对象的年龄升序排列；\n`var cheng = {\n  name : \"cheng\",\n  age : 18,\n  sex : 'male',\n  face : \"handsome\"\n}\nvar deng = {\n  name : \"deng\",\n  age : 40,\n  sex : undefined,\n  face : 'amazing'\n}\nvar zhang = {\n  name : \"zhang\",\n  age : 20,\n  sex : \"female\"\n}\nvar arr = [cheng, deng, zhang];\narr.sort(function(a, b) {\n  return a.age - b.age;\n})`\n\n\n不可改变原数组\nconcat,join--->split,toString,slice  \n\nconcat连接  arr.concat(arr1)  把数组arr1加到数组arr后面。\n数组的toString是把数组变成字符串。\nslice(从该位开始截取，截取到该位)\njoin(\"-\")方法可以再数组的每一位之间加上-连接成一个字符串。\nsplit(\"-\")方法可以根据\"-\"把数组的字符串拆成单个的。可以根据任意的字符串拆分。\n\n例题：\n`var str = \"alibaba\";\nvar str1 = \"baidu\";\nvar str2 = \"tencent\";\nvar str3 = \"toutiao\";\nvar str4 = \"wangyi\";\nvar str5 = \"xiaowang\";\nvar str6 = \"nvsheng\";\nvar strFinal = \"\";\nvar arr = [str, str1, str2, str3, str4, str5, str6];`\n字符串放在栈内存里存储，first in, last out;所以字符串的连接是调用每一个字符串进行连接，效率低下，一般我们把字符串先保存到数组中进行调用的，这样效率更高，因为数组的散列结构。\n\n\n类数组 arguments \n例：\n`var obj = {\n  \"0\" : 'a',\n  \"1\" : 'b',\n  \"2\" : 'c',\n  \"length\" : 3,\n  \"push\" : Array.prototype.push,\n  \"splice\" : Array.prototype.splice\n}`\n属性要为索引(数字)属性，必须有length属性，最好加上push方法。\n\n例题：\n`var obj = {\n  \"2\" : 'a',\n  \"3\" : 'b',\n  \"length\" : 2,\n  \"push\" : Array.prototype.push\n}\nobj.push('c');\nobj.push('d');\nconsole.log(obj);`\n结果为：obj{\n  \"2\" : \"c\",\n  \"3\" : \"d\",\n  \"length\" : 4,\n  \"push\" : Array.prototype.push\n}\n\n\n完美区别各种类型的函数对象\n\n`function type(target) {\n  var ret = typeof(target),\n  template = {\n    \"[object Array]\" : \"array - object\",\n    \"[object String]\" : \"string - object\",\n    \"[object Number]\" : \"number - object\",\n    \"[object Boolean]\" : \"boolean - object\",\n    \"[object Object]\" : \"object - object\"\n  }\n  if(target === null) {\n  return \"null\";\n  }else if(ret == \"object\") {\n  var str = Object.prototype.toString.call(target);\n  return template[str];\n  }else{\n  return ret;\n  }\n}`\n\n数组去重的方法：hash哈希的方法：基于的就是对象的命名规则就是相同的命名会覆盖，所以达到了数组去重的作用。与当年阿里巴巴考的类数组的例题有点儿相似。\n`var arr = [1, 2, 3, 4, 1, 3, 4, 2, 4, 5, 6, 4, 0, 0, 0];\nArray.prototype.unique = function () {\n  var temp = {},\n      arr = [],\n      len = this.length;\n  for(var i = 0; i < len; i ++){\n  if(!temp[this[i]]) {\n    temp[this[i]] = \"abc\";\n    arr.push(this[i]);\n  }\n  }\n  return arr;\n}`\nthis[i]代表数组的第i位。随意取名的话“abc”不能换成this[i],因为要是数组里面有undefined或者0等其他为false的值的话，这个去重就失败了。\n\n\nthis问题的例题：谁调用的this方法this就指向谁。\n`var name = \"window\";\nvar obj = {\n  name : 'obj',\n  say : function (){\n  console.log(this.name);\n  }\n}\nvar fun = obj.say();`\nconsole.log(obj.say);    结果为：obj\nconsole.log(obj.say.call(window));    结果为：window\nconsole.log(fun());      结果为：window\nconsole.log(fun.call(obj));    结果为：obj\n\n\n\n闭包形成的原因：一个函数套着另一个函数，并且必须要把里面的函数保存到最外面函数的外面才能形成闭包的。把里面的函数保存出来不一定非要用return。也可以在外部调用也可以的。例如：\n`var obj = {};\n    function a() {\n      var aa = 123;\n      function b() {\n      console.log(aa);\n      }\n      obj.fun = b;\n    }\n    a();\n    obj.fun(); `    结果就为：123    因为把里面的函数保存到了外部，会形成闭包，所以就能访问到a函数已经销毁的变量。\n\n\n\n1、一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母\n2、字符串去重；\n\n`var str =  \"adshqwertyuioonpqwertmyuiopasdfghjklasdfghjklzxcvb\";\nfunction sayFirst(target) {\n  var len = target.length,\n      count = 0;\n  for(var i = 0; i > len; i ++) {\n  if(target) {\n    \n  }\n  }\n}`\n\n企业开发中为了防止出错的，出错的话之后的代码就不会执行了；如果网速不好话，代码里有的数据没有下载完就会报错的；\ntry{}里面的代码有错误的话，如下：不会执行错误代码，而且错误代码下面的正确代码也不会执行了，但是不会报错的。\n而try里面有错误的话会直接跳到catch里面执行catch里面的代码，catch就是为了容错，而且是返回错误信息的。e可以随便写。\n`try{\n  console.log(\"a\");\n  console.log(b);\n  console.log(\"c\");\n}catch(e) {\n  alert(e.name + \" : \" + e.message);\n}`\n\nError.name的六种值对应的信息：\n1. EvalErron:eval()的使用与定义不一致\n2. RangeErron:数值越界\n3. ReferenceError:非法或不能识别的引用数值（没定义就使用的原因）\n4. SyntaxError:发生语法解析错误（代码中有中文的标点符号，在解析是就会报错）\n5. TypeError:操作书类型错误\n6. URLError:URL处理函数使用不当\n\n\nes5.0严格模式   es3.0 和 es5.0产生冲突的部分，就用es5.0，否则使用es3.0的；严格模式优点是减少了编程错误的发生。\n\nes5.0的启用：\"use strict\"可以写在一个函数里，那么就在这个函数里只能使用严格模式了。在严格模式中不能使用with（改变函数作用域）,arguments.callee(代替匿名函数的作用),func.caller（函数执行时才能调用，也是代替匿名函数的作用）等等方法；而且还有变量赋值前必须声明。this必须被赋值，预编译之前局部为undefined，不再是指向window了。拒绝重复属性和参数。\n\nwith()可以改变作用域链，先找括号里面填写的对象的作用域链，没有的话才会找自己的作用域链上的。命名空间的应用，代码简化的作用。但是更改作用域链的话，会使效率降低。\n\neval()括号里能把字符串当代码使用。是魔鬼！还可以改变作用域，他还有自己独立的作用域。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"Js模式读书笔记","url":"/2017/11/js模式-读书笔记.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n  \n## js模式笔记\n  模式：广义上是重现事件或用来生产者对象是主题···它是一个可以用来生产其他事物的模板或者模型。在软件开发过程中，模式是指一个通用问题的解决方案。一个模式不仅仅是一个可以用来复制粘贴的代码解决方案，更多的是提供了一个更好的实践经验、有用的抽象化表示和解决一类问题的模板。\n在JS中，一旦定义好了变量，同时也就已经正在处理对象向了。该变量会成为内置对象的一个属性，成为激活对象。第二，该变量实际上也是伪类，因为他拥有其自身的属性（attributes），该属性决定了该变量是否可以被修改、被删除和在一个for-in循环中进行枚举。\n一个对象仅仅是一个容器，该容器包含了命名的属性、健-值对（大多数）的列表。这里面的属性可以是函数（函数对象），这种情形下我们称其为方法。对象有两种类型：原生的（Native）：内置对象（例数组、日期对象等）和用户自定义对象（例var a={}）   主机的（Host）：Windows对象和所有的DOM对象。\n\n尽量少用全局变量！尽量使用var声明变量。\n使用var创建的全局变量不能删除。不适用var创建的隐含全局变量可以删除。这表明隐含全局变量严格来讲不是真正的变量，而是全局的属性。属性可以通过delete操作符删除，但变量不可以。\n尽量使用一个var声明全部变量，这样可以减少逻辑错误和提高代码的可读性。\n凌散变量的提升。不管在函数的任何地方声明变量，效果都等同于在函数顶部进行声明。\n\nfor-in循环应该用来遍历非数组对象。一般用for循环遍历数组。使用for-in遍历非数组对象时都要结合.hasOwnProperty（）。\n\n不要增加内置的原型。容易引发混乱，引起错误等。\n\n\n\n`  var inspect_me = 0,\n      result = '';\n  switch（inspect_me）{\n  case 0：\n     result = “zero”；\n     break；\n  case 1：\n     result = “one”；\n     break；\n  default：\n     result = “unknown”；\n  }`\n\n\n避免使用隐式类型转换。false==0或\"\" == 0这类比较语句后会返回true。\n\n避免使用eval（），他可以将任意字符串当做一个JavaScripe代码来执行。\n\nparseInt()的数值约定。传的第二个参数是一个进制参数，尽量不要省略该参数。还有截断字符只返回数字类型的功能。\n\n关于分号的使用，尽管解析器会在代码的每行的结尾隐式的加上分号，但是一般情况下我们还是不应该省略，这不仅是严格记录和代码编写方式，也会有助于避免之前范例中含糊不清的情况。\n\n使用空格，例如：`for (var i = 0; i < 10; i += 1){...}   var a = [1, 2, 3];   var o = {a: 1, b: 2};\n`\n命名约定：构造函数的首字母大写。其他命名模式，有时候开发者采用将变量名全部大写的约定来表明该变量在程序生命周期中不可改变，例如：var PI = 3.14,表示是精确的常量，请不要修改。\n还有的程序员使用一种约定来模仿功能性的做法是私有成员函数约定。使用一个下划线前缀来标识私有方法或者私有属性是更为简单的一种方法。例如：var person = {\n   _getFirst: function () { }表示私有函数，使用下划线前缀的表示方法可以提醒使用person对象的用户，告诉他们这些方法在其他地方不能确定一定能够正常工作，不能直接调用。\n}\n\n下面是一些使用下划线约定的变量：\n使用下划线结尾来表明是私有变量，例如name_和getElements_()。\n使用一个下划线前缀来标识受保护属性，使用两个下划线前缀来标识私有属性。\n在Firefox中有一些属性，这些属性技术上不是JavaScript语言的一部分，它们采用两个下划线前缀和两个下划线后缀来命名。例如__proto__and__parent__。\n\n编写注释。因为人的记忆力不是永久的，过了一段时间你自己写的代码可能你都不能认识了。最重要的习惯，也是最难遵循的习惯就是不断更新注释，因为过期的注释可能会误导阅读者，这比没有注释还可怕。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["book"],"categories":["学习笔记"]},{"title":"JQuery","url":"/2017/11/jQuery.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n## jQuery笔记\njQuery是一个非常优秀的js库。现在有一万行以上的代码了，重在他的封装思想，使用方法会用就可以先查先用。移动端有一个zepto的库就是从jQuery中精简来的。因为移动端的网速没有PC端的快、还有就是不稳定。\n像百度等等的一些比较大的互联网公司一般都会有在网上的jQuery库的，我们可以在网上直接应用他们的jQuery库，可以用src的方法直接引用过来，当然我们也可以下载下来直接在我们的服务器上直接调用。\n\n\n### 简单模仿jQuery的功能：\n```\n(function() {\n  function jQuery (selector, content) {\n\treturn new jQuery.prototype.init(selector, context)\n  }\n  jQuery.prototype.init = function (selector, context) {\n    var DomArray = document.getElementByTagName(selector, context);\n    for(var i = 0; i < DomArray.length; i ++) {\n      this[i] = DomArray[i];\t\t\n    }\n    this.length = DomArray.length;\n  }\n  jQuery.prototype.css = function (parm) {\n    for (var i = 0; i < this.length; i ++) {\n      for () {\n        this[i].style[attr] = parm[attr];\n      }\n    }\n  }\n  jQuery.prototype.init.prototype = jQuery.prototype;\n  window.$ = window.jQuery = jQuery;\n})();\n$('div').css({width: '100px', height: '100px', background: 'red'});\n```\n这样就能使用我们所写的jQuery实现一般的功能。\n\n\n> init()方法一般在公司里是用来初始化的作用，整个功能的开始或者是主入口。\n\n## jQuery的选择元素：\n1. $();括号里面和CSS选择一样，注意对选择出的一组元素，一起处理，省略循环，这里在js里是不允许的。\n2. 括号里面可以写elements, selector.等  eg：$('.demo').css('background-color':'red');单个是这样写的，多个的话就写在花括号里面eg：({backgroundColor:'red',width:100,height:100px,})\n3. 括号里面可以是 null false undefined\n4. 括号里面可以是 function() {}\n当$()括号里填的是函数function时；\n`$(function () {\n  alert('jQuery load');\n});\nwindow.onload = function () {\n  alert('window load');\n};`\n结果顺序为：先弹出 window  后弹出 jQuery\n因为jQuery里面是这样写的：\n`function $(selector) {\n  if(typeof selector === 'function') {\n\tfunction temp () {\n\t  window.setTimeout(selector, 0);\n\t}\n\tdocument.addEventListener('DOMContentLoaded', temp)\n  }\n}`\n虽然DOMContentLoaded是较window.onload先执行触发的，也就是先执行temp，但是setTimeout加入任务队列中虽然写的是0毫秒立即执行的，但是最快也要4毫秒之后才能执行，也就是说虽然你应该最先执行，但是因为js是单线程，4毫秒之后也就在windo.onload之后才能执行了。但是要是页面上有很多资源需要加载的话，图片或者文件等等那么window.onload就需要加载一些时间了，也就是在4毫秒之后那么setTimeout就会在window.onload之前了。\n\n5. 括号里面可以是 上下文context\n$(selector, context)\neg: $('div', 'span').css(background: 'red')\n这样就表示是在div里面的span标签执行css操作。\n6. 特有的操作；\n```\n$('ul li:first').css('background', 'red')；\n$('ul li:last').css('background', 'red')；\n\n$('ul li:eq(0)').css('background', 'red')；\n$('ul li').eq(0).css('background', 'red')；\n\n$('ul li:odd').css('background', 'red')；\n$('ul li:even').css('background', 'red')；\n```\n```\nvar arr[];\narr.filter(function (ele, index) {\n  如果第一个元素和索引满足条件，就把这个元素留下来，放到一个新数组中。起到了一个过滤的作用。\n})\njQuery里面也有这个方法。也能起到过滤的作用。\n$().filter(selectoe\\function\\element\\jQuery Object)\n$('ul li').filter(':even').css('background', 'orange')\n```\n> 过滤一下是偶数的li执行它。\n\n`$('ul li').filter(function (index) {\n  index % 4 === 0;\n}).css('background', 'orange');`\n\n# 下面介绍一些再jQuery中常用的方法：\n## not()方法\nnot()方法功能正好跟上面的filter()相反。\n## has()方法\nhas()方法功能\n`$('ul li').has('span').css('background', 'orange')`  表示的是li标签中有span标签的操作它\n## is()方法\nis()方法。他之后就不能再进行链式调用了。因为他返回的结果为boolean类型的。\n`$('ul .demo').is($('ul li').eq(2))` 返回的结果为 true，表示的是看前面所选的跟后面的是否相同。\n## find()方法\n`$('ul').find('.demo').css('background', 'orange')` 表示的是在ul里面找满足条件的li并进行操作li。跟之前的是不同的。因为他操作的不是最前面的ul了，而是操作的是find找到的满足条件的li。而且通过find()返回的结果里面还有一个prevObject对象，这个是找到这个之前的标签，与end()方法是一样的，可以往上回退到之前的标签。\n`$('ul').find('.demo').prevObject === $('ul')` 结果为：false  （因为之前是new出来的对象，后面是另一个new出来的另一个对象）\n## html()方法\nhtml()方法,是基于innerHTML的方法的，是获取集合中第一个匹配元素的HTML内容 或 设置每一个匹配元素的html内容。\n`$('ul li').html();`表示的是取出来一个li。   取值取一个，赋值赋一组。\n`$('ul li').html('<span style=\"color: orange;\">haha</span>');`表示的是在每一个li标签中都添加了一个span标签\n## text()方法\ntext()方法，是基于innerTEXT的方法，是得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。hahahahahaahahahhhahhahaha十个li中的文本内容全部返回。`$('ul li').text('123')`会把ul下的所有东西都替换了。\n## .css()方法\n`$('ul li').css()`当赋值为颜色的时候会把颜色内部转换成RGB形式的。取值取一个，赋值赋一组。\n## .setAttribute()方法\n`.setAttribute`**是设置DOM元素上的属性的。DOM上的标签上的特性像id、class等等会与DOM设置的形成一一映射的关系，而属性是你自己设置的所以则没有这种映射关系。**\n## .attr()方法\n`attr()`方法,是基于setAttribute()方法的\n`$('ul li').attr('data', 'duyi');`  表示的是在每一个li上面都加上了一个属性名称data=\"duyi\";\n`$('ul li').attr('data');`  结果为一个duyi,这就是取值，取值取一个，赋值赋一组。\n## .prop()方法\nprop()方法，是标签上的特性，才能添加上去的。\n`$('ul li').prop('id', 'demo')`,表示在每一个li标签上添加了一个id特性值为demo。\n再比如表单`<input type=\"radio\" checked=\"checked\">`\n`$('input').attr('checked');`当被选中的时候就是checked没有选中的时候就是undefined。但是你不了解的话就不会知道的。但是用prop()方法就不会不了解了，这个点返回值是true或者false。一般表单这个我们都用prop方法。\n## next()、prev()方法\nnext()的下一个标签   prev()的前一个标签   index()返回这个标签的索引是第几位。\n`$('li').click(function () {\n  console.log(this);\n  console.log($(this).index());\n})`\n\n\n因为jQuery是链式操作，所以下面的这些方法是有相反的。\n```\n$('.box3').inserBefore( $('.box1') );在box1之前加入box3\n$('.box1').before( $('.box3') );同上\n\n$('.box3').appendTo( $('.wrapper') );往.wrapper里加入box3\n$('.wrapper').append( $('.box3') );\n\n$('.box3').prependTo( $('.wrapper') );往.wrapper之前加入box3\n$('.wrapper').prepend( $('.box3') );\n```\n## remove()方法\nremove()方法：是把标签移除。\n\n# jQuery中的注册事件方法\n## bind()方法\n注册事件bind() （老版本）绑定事件的，可以改变this指向\n## on()方法\non() （新版本）  括号里面传参数是第一个是绑定的事件类型，第二个是绑定事件的方法 on('click', function() {})   第三个参数可以是数组对象，那么传的参数就会在这个绑定on方法的对象上了。第四个参数最重要是可以实现事件委托。`$('.wrapper').on('click', 'div', [{name: 'cst'}, '18'], function() {});`就相当于给.wrapper下的div加上了绑定事件，事件委托了，就是说不管是不是原来就在.wrapper下的div，因为这是给.wrapper上绑定了事件，会把这个事件直接加到他下面的div中。功能很强大啊！\n## off()方法\nalert()会阻塞页面。   off(this) 解除绑定事件，会把调用off事件的所有绑定的事件全部清除。\n\n`$('.wrapper').on('click', function () {alert(0)}).on('click', function () {alert(1)});`\n`$('.wrapper').off('click')`\n**怎么绑定的就怎么来解绑。**\n\n\n## 点赞有次数限制\n```\nfunction good() {\n  console.log('赞')；\n  if (++times === 10) {\n\t$(this).off('click', good);\n  }\n}\n$('.wrapper').on('click', good);\n$('.wrapper').one('click', function () {\n\tconsole.log('ok');\n})\n```\n**on()方法不仅可以绑定系统固有的事件，还可以绑定自定义事件。自定义事件可以通过trigger来触发。**\n## offsetWidth()方法\n```\nvar oDiv = document.getElementById('wp');\ndocument.write(oDiv.offsetWidth);    oDiv.offsetWidth()这个方法显示的就是“content + padding + border”\noDiv.innerWidth   这个显示的是“content + padding” \noDiv.outerWidth()\n```\n传参数，参数是true的时候会加上margin，没有参数就没有margin的值   这个显示的是“content + padding + border + margin”\n`$('.content').offset()`这个方法会返回一个对象，这个对象里面有top:  和  left:   并且值是与浏览器边框的距离值。\n`$('.content').position()`这个方法也会返回一个对象，这个对象里面的top:   和   left:   的值是与最近的父级元素的距离，父级元素要有相对定位或者绝对定位等等的可以让子级找到的属性。   \n## 创建dom方法\n$('<div> div </div>')可以这样创建一个div\n$('</div>')这样也可以，只不过这样就不能填写里面的内容了。","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"编程方法小汇总","url":"/2017/11/important Ideas.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n## 深度克隆：遍历对象  for(var prop in obj)\n\t1、判断是不是原始值   typeof()  object\n\t2、判断是数组还是对象，有三种方法：instanceof   toString  constructor  一般用toString方法，因为如果在原先的页面上再引入一个页面的话，引入进来的页面中的数组和对象就不符合原先的原则了，而toString方法则不会发生这种引用错误。\n\t3、建立相应的数组或对象\n\t递归的方法。(必须找出口)\n```\nvar obj = {\n  name : 'abc',\n  age : 123,\n  card : ['vasa', 'master'],\n  wife : {\n\tname : 'bcd',\n\tson : {\n\t  name : 'aaa'\n\t}\n  }\n}\nfunction deepClone(origin, target) {\n    var target = target || {},\n\ttoStr = Object.prototype.toString,\n\tarrStr = \"[object Array]\";\n  for(var prop in origin) {\n\tif(orgin.hasOwnProperty(prop)) {\n\t  if(origin[prop] !== 'null' && typeof(origin[prop]) == 'object') {\n\t\tif(toStr.call(origin[prop]) == 'arrStr'){\n\t\t   target[prop] = [];\n\t\t}else{\n\t\t   target[prop] = {};\n\t\t}\n\t\tdeepClone(origin[prop], target[prop]);\n\t  }else{\n\t\ttarget[prop] = origin[prop];\n\t  }\n\t}\n  }\n  return target;\n}\ndeepClone(obj);\n\n```\n## 封装Ajax方法：\n```\nfunction Ajax(method, url, flag, data, callBack) {\n  var app = null;\n  if(window.XMLHttpRequest) {\n    app = new window.XMLHttpRequest();\n  }else{\n    app = new window.ActiveXObject('Microsoft.XMLHTTP');\n  }\n  method = method.toUpperCase();\n\n  if(method === 'GET') {\n    app.open(method, url + '?' + data, flag);\n    app.send();\n  }else if(method === 'POST') {\n    app.open(method, url, flag);\n    app.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n    app.send(data);\n  }\n  app.onreadystatechange = function() {\n    if(app.readyState === 4) {\n\tif(app.status === 200) {\n\t  callBack(app.responseText);\n\t}else{\n\t  alert('error');\n\t}\n    }\n  }\n}\n```\n__vue重要思想（借鉴React）中的虚拟DOM（真实DOM用js实现的方式），极大的减少了浏览器页面切换间的刷新次数。创新的思想！__\n真实实现方法是用：vue.render()函数中的h()函数来实现的！\n## 模拟虚拟DOM的实现方法：\n```\nfunction vElement(tagName,prop,children)\n{\n  if(!(this instanceof vElement)){\n    return new vElement(tagName,prop,children);\n  }\n  if(Object.prototype.toString.call(prop) === \"[object Array]\") {\n    children = prop;\n    prop = {}\n  }\n  this.tagName = tagName;\n  this.children = children;\n  this.prop = prop;\n  var count = 0;\n  this.children.forEach(function(child, index){\n    if(child instanceof vElement) {\n\tcount += child.count;\n    }\n    count ++;\n  })\n  this.count = count;\n}\nvElement.prototype.render = function()\n{\n  var el = document.createElement(this.tagName);\n  var children = this.children;\n  var prop = this.prop;\n  for(var item in prop){\n    var curProp = prop[item];\n    el.setAttribute(item, curProp);\n  }\n  children.forEach(function(child,index){\n    if(child instanceof vElement){\n\tvar childDom = child.render();\n    }else{\n\tvar childDom = document.createTextNode(child);\n    }\n    el.appendChild(childDom);\n  })\n  return el;\n}\nvar dom = vElement(\"div\",{class: \"demo\", id:\"demo1\"},[\"hello world\",vElement(\"p\",{class:\"demo2\"},[\"我是p标签\"])]);\ndom.render();\n```\n结果为：渲染出了两个dom数节点；分别为：\n`<div class=\"demo\" id=\"demo1\">\n  <p class=\"demo2\">我是p标签</p>\n</div>`\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"浏览器之DOM","url":"/2017/11/DOM.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n## DOM--->Document Object Model\nDOM定义了表示和修改文档所需的方法。DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml功能的一类对象的集合。也有人称DOM是对HTML以及XML的标准编程接口。\nDOM不能操作CSS！！！DOM修改CSS的是通过改变HTML间接改变CSS的。改变不了CSS行间样式，改变的是HTML。\n\nDOM之后一些成组出现的东西都是类数组的形式。\n\n每一个词条就是一个query。每个query都是人工自己写的。因为商家都追求不平凡，要和别家的有区分，绚丽一点儿的。\n\n\n`var div = document.getElementsByTagName('div')[0];\ndiv.style.width = \"100px\";\ndiv.style.height = \"100px\";\ndiv.style.backgroundColor = \"red\";\n在div上永久绑定一个方法，每次点击都变色。\nvar count = 0;\ndiv.onclick = function () {\n  count ++;\n  if(count % 2 == 1) {\n\tthis.style.background = \"green\";\n  }else{\n\tthis.style.background = \"red\";\n  }\n}`\n\n\n\n鼠标监控：\n`document.onkeydown = function(e) {\n  switch(e.which) {\n\tcase 37:\n\t  div.style.left = perseInt(div.style.left) - speed + 'px';\n\tcase 38:\n\t  div.style.top = perseInt(div.style.top) + speed + 'px';\n\tcase 39:\n\t  div.style.left = perseInt(div.style.left) + speed + 'px';\n\tcase 40:\n\t  div.style.top = perseInt(div.style.top) - speed + 'px';\n  }\n}`\n\n\n\n## 对节点的增删改查\n查\n查看元素节点\ndocument代表整个文档\ndocument.getElementById() //元素id 在Ie8以下的浏览器，不区分id大小写，而且也返回匹配name属性的元素\n.getElementsByTagName() // 标签名\ngetElementByName(); //，需注意，只有部分标签name可生效（表单，表单元素，img，iframe）\n.getElementsByClassName() // 类名 -> ie8和ie8以下的ie版本中没有，可以多个class一起\n.querySelector() // css选择器   在ie7和ie7以下的版本中没有\n.querySelectorAll() // css选择器 在ie7和ie7以下的版本中没有\n但是他和querySelector这两个方法不常用，因为这两个方法不是实时的，静态的。因为js语言就是实时的，后期只要操作HTML就会重新执行一下页面，所以效率低，但是执行的是实时的。\n\n\n## DOM结构树  --> 一系列继承关系。\n\nNode也是一个构造函数，他是最顶头的那个函数对象。\n```\ndocument.__proto__   就是HTMLDocument\ndocument.__proto__.__proto__    就是Document\ndocument.__proto__.__proto__.__proto__   就是Node\ndocument.__proto__.__proto__.__proto__.__proto__   就是EventTarget   这是一个事件\ndocument.__proto__.__proto__.__proto__.__proto__.__proto__   就是系统上的Object的原型，最终都会追溯到系统上的__proto__\ndocument.documentElement   代表的就是HTML标签\nDocument  --> HTMLDocument.\ndocument代表的是整个页面文档。Document原型链\n```\n1. getElementById方法定义在Document.prototype上，即Element节点上不能使用。\n2. getElementsByName方法定义在HTMLDocument.prototype上，即非html中的document以外不能使用(xml document,Element)\n3. getElementsByTagName方法定义在Document.prototype 和 Element.prototype上\n4. HTMLDocument.prototype定义了一些常用的属性，body,head,分别指代HTML文档中的<body><head>标签。\n5. Document.prototype上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代<html>元素\n6. getElementsByClassName、querySelectorAll、querySelector在Document,Element类中均有定义\n\n\n`<div><span>1</span></div><span></span>`\n`var div = document.getElementsByTagName('div')[0];`\n`var span = div.getElementsByTagName('span')[0];`\n在开发的时候也是先选中父级，然后在父级下选择要选择的子级。\n\n\n## 节点的类型\n元素节点   —— 1\n属性节点   —— 2\n文本节点   —— 3\n注释节点   —— 8\ndocument  —— 9\nDocumentFragment  ——  11 （文档碎片节点）\n获取节点类型   nodeType \n\n\n## 遍历节点树：\n parentNode -> 父节点  每个节点只有一个父节点(最顶端的parentNode为#document。再往上就是null);\n childNodes -> 子节点们\n firstChild -> 第一个子节点\n lastChild -> 最后一个子节点\n nextSibling->后一个兄弟元素 \n previousSibling->前一个兄弟元素\n\n所说的IE不兼容说的都是IE9以下的。IE10以上都兼容W3C标准了。\n基于元素节点树的遍历\nparentElement -> 返回当前元素的父元素节点 (IE不兼容)\nchildren -> 只返回当前元素的元素子节点  \nnode.childElementCount  === node.children.length当前元素节点的子元素节点个数(IE不兼容)\nfirstElementChild -> 返回的是第一个元素节点(IE不兼容)\nlastElementChild -> 返回的是最后一个元素节点(IE不兼容)\nnextElementSibling / previousElementSibling ->返回后一个/前一个兄弟元素节点（IE不兼容)\n\n\n## 节点的四个属性\nnodeName\n元素的标签名，以大写形式表示,只读\nnodeValue\nText节点或Comment节点的文本内容,可读写\nnodeType（必须记住，很重要的！）\n该节点的类型，只读\nattributes\nElement 节点的属性集合,比如：<div id='only' class='demo'></div>  div.attributes取出来一个集合放到一个类数组里面。 可以改变值div.attributes[0].value = 'abc'; 能赋值能改值，只能改属性值，也就是更改id的值。\n\n节点的一个方法  Node.hasChildNodes();   有没有子节点，返回结果是false或者true。\n\n\n\n## DOM基本操作：\n增\n`document.createElement();\ndocument.createTextNode();\ndocument.createComment();\ndocument.createDocumentFragment();`\n插\n`PARENTNODE.appendChild();\nPARENTNODE.insertBefore(a, b);`\n例如：页面中有`<div>`\n`<span></span>`\n`</div>`\n`var str = document.createElement('strong');`\n`var div = document.getElementsByTagName('div')[0];`\n`div.insertBefore(str, span)`\n就是把创建的strong标签插入到div里面的span之前。\n\n\n删除标签\n`div.removeChild();`   其实是剪切,先找到要删除的标签的父级，然后用的是父级删除其中子级的标签功能，一般都用的是这个，因为想用的时候，如果还保存着就还可以找到。真正的删除是用对象`.remove();`   这是新出的方法，原先没有的。这个是真正的删除了，就再也找不到了。\n\n替换标签也是父级调用，`parentNode.replaceChild(new, origin);`用新的去替换久的。被替换的标签不是被删除了，而是被剪切出来了。\n\n\n\n`div.appendChild(p)`,在div标签中加上一些内容或者标签等等。\n\n\n## Element节点的一些属性\n`innerHTML`  这个可以获取标签中的内容。不是追加，是可以覆盖原先的内容的，但是可以用+=的方法追加内容。还可以改变CSS样式的，只要写入就能使用。\n`innerText(火狐不兼容) / textContent(老版本IE不好使)`   可取可赋值。但是这个方法一定要慎重的去用。因为会把原先的内容给覆盖的。\n\n## Element节点的一些方法\n`ele.setAttribute();` 设置原生DOM上的属性 例如：\n`div.setArrtibute('id','only')`   这表示在div上加上id属性。还可以加上一些没有的属性，也就是人为加上去的属性。就比如在标签上人为设置一个属性，data-log='0'; 这个认为加上的属性是用来计算数据量的，算流量的，看这些流量从哪些网站分流出来的，计算给钱。   取data-log值就是：  `div.getAttribute('data-log');`\n\n\n`ele.getAttribute(); ` 取原生DOM上的属性\n`div.getArrtibute();`取出行间属性的值。\n\n\n\n## 日期对象Date();\n\n先  `var date = new Date();`\n然后就能调用Date()方法的一些方法。\n`date.getDate(); ` 从Data对象中返回一个月中的某一天 （1-31）  `date.getDay();`   从Data对象返回一周中的某一天（0-6）\n`date.getMonth();` 从Data对象返回月份（0-11）\n`date.getFullYear();`  从Data对象以四位数字返回年份（后来才有的方法）\n`date.getYear(); `  请使用`data.getFullYear()`方法：一开始就有的方法。只不过这个方法有一个缺点，就是它是用六位表示年月日的。95.03.17；到二千年的时候就不够用了。所以才有了上面的那个完整表示的方法。这就是千年虫问题的出现。当然肯定还有万年虫，不过这个就不是我们需要考虑的问题了，离我们太遥远了~~\n`date.getHours();`   返回Data对象的小时（0-23）\n`date.getMinutes();`   返回Data对象的分钟（0-59）\n`date.getSeconds();`   返回Data对象的秒数（0-59）\n`date.getMillseconds();`  返回Data对象的毫秒数（0-999）\n`date.getTime(); `    返回1970年1月1日至今的毫秒数（这个方法是最常用的，把耶稣出生的那一年当做人类的纪元年，计算机的纪元年就是1970.01.01，所有的计算机和手机的时间的计算都是根据计算机纪元时间来换算出来的。重点是：这个方法能帮我们算时间差，每个功能用的时间差就是根据这个方法来计算的）\n`date.getTimezoneOffset();`   返回本地时间与格林威治标准时间（GMT）的分钟差\n`date.getUTCDate();`    根据世界时从Data对象返回月中的一天（1-31）\n`date.getUTCDay();`   根据世界时从Data对象返回月份（0-6）\n`date.getUTCMonth();`  根据世界时从Data对象返回月份（0-11）\n`date.getUTCFullYear();` 根据世界时从Data对象返回四位数的年份\n`date.getUTCHours();`  根据世界时返回Data对象的小时（0-23）\n`date.getUTCMiutes();`  根据世界时返回Data对象的分钟（0-59）\n`date.getUTCSeconds();`  根据世界时返回Date对象的秒钟（0-59）\n`date.getUTCMillseconds();` 根据世界时返回Date对象的毫秒（0-999）\n`date.parse();`   返回1970年1月1日午夜到指定日期（字符串）的毫秒数\n人为设置一个时间点，到设置好的时间点执行一个功能，比如淘宝上的定时抢购，就是到达人为设置的时间点之后立即执行函数功能。\n`date.setDate();`   设置Date对象中月的某一天（1-31）\n`date.setMonth();`   设置Date对象中月份（0-11）\n`date.setFullYear();`  设置Date对象中的年份（四位数字）\n`date.setYear();`     请使用setFullYear()方法代替\n`date.setHours();`    设置Date对象中的小时（0-23）\n`date.setMinutes();`  设置Date对象中的分钟（0-59）\n`date.setSeconds();`    设置Date对象中的秒钟（0-59）\n`date.setMillseconds();`  设置Date对象中的毫秒（0-999）\n`date.setTime();`      以毫秒设置Date对象\n`date.toSource();`    返回该对象的源代码\n`date.toString();`   把Date对象转换为字符串\n`date.toTimeString();`  把Date对象的时间部分转换为字符串\n`date.toDateString();`  把Date对象的日期部分转换成字符串\n\n\n# JS定时器\n## setInterval()\n   `setInterval(function() {}, time);`time只能赋一次值，并不能通过改变time的值来动态改变隔得时间。定时器并不准。如何看时间准不准呢？写一个函数如下：\n```\nvar firstTime = new Date().getTime();\nsetInterval(function () {\n var lastTime = new Date().getTime();\n console.log(lastTime - firstTime);\n firstTime - lastTime;\n}, 1000);\n```\n在控制台上打印的结果并不总是1000毫秒，所以这个方法的时间间隔并不是很准的。所以要是做的功能对时间有很精确的时间要求就不能寄希望于这个方法上的。与系统执行代码所消耗的时间还有。这个方法的排列机制是基于红黑数的。每一次这个方法都会返回一个唯一标示。应用就是VIP电影有试看时间，就是用这个方法。\n\n`setTimeout();`   只执行一次。\n`clearInterval();`\n`clearTimeout();`\n全局对象window上的方法，内部函数this指向window\n注意 ：`setInterval(\"func()\",1000);`\n\n\n\n## 查看滚动条的滚动距离\n`window.pageXOffset/pageYOffset`\nIE8及IE8以下不兼容\nIE8及IE8以下用的下面这个方法：\n`document.body/documentElement.scrollLeft/scrollTop`\n但是这两个方法是在IE浏览器中到底哪个能用是不一定的，又但是这两个问题是互相冲突的，一个有值另一个就没有值了。所以就让两个值加起来用。\n兼容性比较混乱，用时取两个值相加，因为不可能存在两个同时有值\n\n## 练习：\n**封装兼容性方法，求滚动轮滚动距离**\n\n`getScrollOffset()`\n```\nfunction getScrollOffset() {\n  if(window.pageXOffset) {\n    return {\n\tx : window.pageXOffset,\n\ty : window.pageYOffset\n    }\n  }else{\n    return {\n\tx : document.body.scrollLeft + document.documentElement.scrollLeft,\n\ty : document.bodu.scrollTop + document.documentElement.scrollTop\n    }\n  }\n}\n```\n如果放大页面的尺寸。那么返回的可视区窗口就是放大之后的可视区的实际尺寸。\n\n就在编程的html标签的上面还有一个<!DOCTYPE html>表示 文档类型，当有这个标签的时候浏览器的渲染模式就是标准模式，没有这个标签的时候浏览器的渲染模式就是怪异模式。渲染就是识别语法并绘制成页面。\n标准模式：正常的渲染模式。一般除了IE浏览器其他的浏览器的与之前的变动并不是很大，所以也用不着去启用怪异模式。\n怪异模式又叫混杂模式：试图去兼容浏览器之前的版本。\n\n**有一个方法能看当前浏览器是在什么渲染模式下：**\n`document.compatMode`     当返回值为：\"CSS1Compat\";  表示标准模式下\t\t\t当返回值为：\"BackCompat\"  表示在怪异模式下，向后兼容\n\n## 查看视口的尺寸的方法：\n`window.innerWidth/innerHeight`\nIE8及IE8以下不兼容\n标准模式下，任意浏览器都兼容的方法：\n`document.documentElement.clientWidth/clientHeight`\n适用于怪异模式下的浏览器的方法：\n`document.body.clientWidth/clientHeight`\n\n\n## 练习：\n**封装兼容性方法，返回浏览器视口尺寸**\n`getViewportOffset()`\n```\nfunction getViewportOffset() {\n  if(window.innerWidth) {\n    return {\n\tw : window.innerWidth,\n\th : window.innerHeight\n    }\n  }else if(document.compatMode === \"BackCompat\"){     \n\treturn {\n\t  w : document.body.clientWidth,\n\t  h : document.body.clientHeight\n\t}\n  }else if(document.compatMode === \"CSS1Compat\"){\n\treturn {\n\t  w : document.documentElement.clientWidth,\n  \t  h : document.documentElement.clientHeight\n\t}\n  }\n}\n```\n## 比较获取查看窗口尺寸的方法的取值差异：\n使用`$(window).width() `与 `$(window).height();`\n获取的是屏幕可视区域的宽高，不包括滚动条与工具条。\n`window.outerWidth` 与 `window.outerHeight;`\n获取的是加上工具条与滚动条窗口的宽高与高度(总高度算上全部滚动条的高度)。\n`window.innerWidth `与 `window.innerHeight;`\n获取的是可视区域的宽高，但是宽度包含了纵向滚动条的宽度。\n`document.documentElement.clientWidth `与 `document.documentElement.clientHeight;`\n获取的是屏幕可视区域的宽高，不包括滚动条与工具条，跟JQuery的获取的结果是一样的。\n`document.body.clientWidth` 与 `document.body.clientHeight;`\n获取的是宽度可视区域的宽度，获取的高度是是body内容的高度，如果内容只有200px，那么这个高度也是200px，如果想通过它得到屏幕可视区域的宽高，需要样式设置如下：\n```\nbody {\n height: 100%;\n overflow: hidden;\n}\nbody, div, p, ul {\n margin: 0;\n padding: 0;\n}\n```\n## 兼容性：\n1. window.innerWidth 和 window.outerWidth 属性方法IE8以及以下不支持，得到的值为undefined。\n2. 测试浏览器IE，火狐，谷歌，Safari都支持怪异下的方法属性`document.documentElement.clientWidth` 与 `document.documentElement.clientHeight`。\n\n结论：\n获取屏幕的可视区域的宽高可使用jQuery的方式获得，也可以使用原生js获得，即：`document.documentElement.clientWidth `与 `document.documentElement.clientHeight` 方法。\n\n\n\n## 查看元素的几何尺寸\n`domEle.getBoundingClientRect();`\n兼容性很好，返回的是元素相对其他的最近的有定位的元素的真实的值\n该方法返回一个对象，对象里面有left,top,right,bottom等属性。left和top代表该元素左上角的X和Y坐标，right和bottom代表元素右下角的X和Y坐标\nheight和width代表该元素真实的自身可视高度和宽度。\nheight和width属性老版本IE并未实现\n返回的结果并不是“实时的”，并且在Google浏览器中扩大缩小页面的内容left和right的值是会跟着变的。其他值是可视区域真实值。\n \n\n## 查看元素的尺寸\n`dom.offsetWidth，dom.offsetHeight`\n## 查看元素的位置\n`dom.offsetLeft, dom.offsetTop`\n不管dom自身有没有定位，他都会把他跟他最近的有定位的父级元素的距离返回出来。对于无定位父级的元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标。在浏览器下缩放对该方法的取值是有影响的，返回的是真实的可视区域的大小值。\n`dom.offsetParent`\n返回最近的有定位的父级，如无，返回body，    \n`documen.body.offsetParent `返回null\n\n\n## 练习：\neg：求元素相对于文档的坐标getElementPosition\n`function getElementPosition(dom) {\n  if(dom.offsetParent !== body) {\n    return {\n\t  x : dom.offsetLeft,\n  \t  y : dom.offsetTop\n\t}\n  }\n}`\n\n\n\n\n\n\n## 让滚动条滚动\nwindow上有三个方法\n`scroll(),scrollTo()       scrollBy();`\n三个方法功能类似，用法都是将x,y坐标传入。即实现让滚动轮滚动到当前位置。前两个方法不做累加，是定点到当前所设置位置。\n区别：scrollBy()会在之前的数据基础之上做累加。\n\neg：利用scrollBy() 快速阅读的功能    加锁式的编程方法\n```\n<div style='width:100px;height:100px;background-color:orange;color:#fff;font-size:40px;font-weight:bold;text-align:center;line-height:100px;position:fixed;bottom:200px;right:50px;border-radius:50%;opacity:0.5;'> start </div>\n<div style='width:100px;height:100px;background-color:red;color:#fff;font-size:40px;font-weight:bold;text-align:center;line-height:100px;position:fixed;bottom:400px;right:50px;border-radius:50%;opacity:0.5;'> stop </div>\n<script>\n    var start = document.getElementsByTagName('div')[0];\n    var stop = document.getElementsByTagName('div')[1];\n    var key = true;\n    var timer = 0;\n    start.onclick = function () {\n      if(key) {\n          timer = setInterval(function () {\n      window.scrollBy(0, 10);\n\n          }, 100);\n          key = false;\n        }\n    }\n    stop.onclick = function () {\n      clearInterval(timer);\n      key = true;\n    }\n</script>\n```\n\n\n## 间接控制脚本化CSS属性的方法：\n读写元素css属性\n`dom.style.prop`\n可读写行间样式，只能读写行间的值，写到别的地方是读写不出来的。写入操作的唯一方法，其他的方法只能读不能写入了。\n没有兼容性问题，碰到float这样的关键字属性，前面应加css\neg:float — > cssFloat\n复合属性必须拆解，组合单词变成小驼峰式写法\n写入的值必须是字符串格式\n\n\n\n## 查询计算样式\n这个方法传入的第二个参数null传入的是什么呢？传入的是获取伪元素，原生的方法。获取伪元素的属性，伪元素的display默认是inline-block；例如获取一个DOM元素div的伪元素的样式表。就是`window.getComputedStyle(div, \"after\")['prop']`就是获取的这个div上的伪元素属性after的一些值，但是不能操作，只能取出来。如何改变伪元素的需求呢？当点击一个DOM元素div的时候，让div上的一个伪元素变化。也就是操作CSS的样式上加上一些东西。改变原先的class名字而且先写好CSS样式。\n\n`window.getComputedStyle(ele,null);`显示获取出来的是显示展示能看见的真实值，获取出来的是一个对象，还可以.属性，获取出具体的一个属性值。\n计算样式只读\n返回的计算样式的值都是绝对值，没有相对单位（em）\nIE8 及 IE8以下不兼容\n\n查看IE8及IE8以下的属性的特有的方法\n查询样式\n`ele.currentStyle`\n计算样式只读\n返回的计算样式的值不是经过转换的绝对值\nIE独有的属性\n\n## 练习\n**封装兼容性方法getStyle(obj,prop);**  这个方法获取的很靠谱。并且这个方法获取的值是字符串形式的eg“8px”；所以用的时候需要用parseInt()方法来把后面的字符串截断成纯数字形式的，这样我们才能使用。\n\n`function getStyle(elem, prop) {\n  if(window.getComputedStyle) {\n    return window.getComputedStyle(elem, null)[prop];\n  }else{\n    return elem.currentStyle[prop];\n  }\n}`\n\n\n\n\n# JSON：\nJSON是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象就是本地用的，json是用来传输的）   最开始的时候前后端交流的是使用xml的形式的，但是现在用的是JSON的形式；\n可以把JSON当成一个构造函数，它里面就有如下两个方法：\nJSON.parse();   string--->json\nJSON.stringify();   json---->string\n是因为我们传输的信息就是字符串形式的：可以互相转换。\n\n## 静态类：\njs是面向过程正在朝面向对象过渡的过程：例如：\nsetInterval() 这个方法是window上的，js上定义的一些方法\nMath()这个方法，5年前是定义在function Math() {}上的；现在是一个对象。一些方法直接定义在了Math() 身上，所以想用的时候就不用new了，各有各的好处。他们身上的方法就叫做静态方法，静态类的总称。Math.floor()向下取整；Math.ceil()向上取整；Math.abs()取绝对值(absolute);Math.random()  0-1之间的任意小数；Math.sqrt()开方；\n\n\n## 时间线：\njs加载的缺点：加载工具方法没必要阻塞文档，使得js加载会影响页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染等工作。\n有些工具方法需要按需加载，用到再加载，不用不加载。\n\n\n\n## javascript 异步加载 的 三种方案\n1. defer 异步加载，下载完不是立刻执行，是要等到dom文档全部解析完才会被执行。只有IE能用。IE10以下的可用。不光是页面内的js文件还是页面外引入的都会变成异步加载的。\n<script type=\"text/javascript\" defer=\"defer\" src=\"xxx.js\"></script>可以简化成defer\n就比如说页面中有一个img标签，先解析，加到DOM树上；再加载，比如图片需要加载图片的二进制文档，也就是下载，下载完了也就是加载完了；最后绘制渲染出来。\n\n2. async 异步加载，加载完就执行，async只能加载外部脚本，不能把js写在script 标签里。这个方法只能是加载外部js引用时才能异步加载。\n<script type=\"text/javascript\" async=\"async\" src=\"xxx.js\"></script>\nasynchronous javascript and xml ----->  Ajax\n\n1和2 执行时也不阻塞页面，但是不能两个同时用。一般公司都会采用牺牲IE的方法只用async的。\n\n3. 创建script，插入到DOM中，加载完毕后callBack\n\n## 按需加载异步下载js的兼容性写法：\n```\nfunction loadScript(url, callback) {\n  var script = document.createElement('script');\n  script.type = \"text/jacascript\";\n  script.src = url;\n  if(script.readyState) {\n    script.onreadystatechange = function () {\n      if(script.readyState == \"complete\" ||  script.readyState == \"loaded\") {\n\t  callback();\n      }\n    }\n  }else{\n    script.onload = function () {\n      callback();\n    }\n  }\n  document.body.appendChild(script);\n}\nloadScript('tools.js', getScrollOffset);\n```\n这里有一个问题，就是还没等到工具js包下载完呢，就调用这个包里面的方法肯定会报错的。解决方法为可以`loadScript('tools.js', function() {console.log(getScrollOffset())});`或者把tools.js里面的方法都整合到一个对象里面：在js包里： `var obj={getScrollOffset: function() {console.log('a')}};`然后再把上面这个方法也改了，改成  `obj[callback]();`这样就可以这样用了`loadScript('tools.js', 'getScrollOffset');`\n\n\n\n## js时间线：\n\n1. 创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = 'loading'。\n2. 遇到link外部css，创建线程加载，并继续解析文档。\n3. 遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。\n4.  遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。\n对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()因为该方法会清空之前写的所有文档流）\n5. 遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。\n6. 当文档解析完成，document.readyState = 'interactive'。\n7. 文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）;\n8. 当文档解析完成后，document对象触发DOMContentLoaded事件，一触发就标志着解析完毕了。这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。\n9. 当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = 'complete'，也就是当所有的东西都加载完成之后，window对象触发load事件。加载完成就开始渲染，所有的东西都就画出来了，用户可以看见东西了。\n10. 从此，以异步响应方式处理用户输入、网络事件等。\n\n\n**绑定事件的时候，无论多少的单词都不会大写的，但是只有一个特殊的就是'DOMContentLoaded'。**\n`document.readyState 三个阶段：loading、interactive、comolete.`\n```\ndocument.addEventListener('DOMContentLoaded', function () {\n\tconsole.log(document.readyState)\n}, false);\n```\n这样打印出来就是： 'interactive'\n再复习一下第三个参数false是什么意思呢，就是捕获，绑定事件监听的事件处理模型只能有两种行为，一个是捕获，另一个是冒泡。true的时候就是冒泡。\n\n\n\n## 练习题：\n\n**请编写一段JavaScript脚本生成下面这段DOM结构。要求：使用标准的DOM方法或属性。**\n```\n<div class=\"example\">\n\t<p class=\"slogan\">姬成，你最帅!</p>\n</div>\n```\n提示 dom.className 可以读写class\n```\nvar div = document.createElement('div'),\n    p = document.createElement('p');\np.innerText = '姬成，你最帅！';      也可以  var text = document.createTextNode('姬成，你最帅！');\ndiv.appendChild(p);\ndocument.body.appendChild(div);\ndiv.setAttribute('class', 'example');\np.setAttribute('class', 'slogan');\n有一个注意的点就时appendChild()括号里没有''!!! 应该直接在里面写原生DOM   appendChild(div)\n```\n\n1. 封装函数insertAfter()；功能类似insertBefore();\n提示:可忽略老版本浏览器，直接在Element.prototype上编程\n```\nElement.prototype.insertAfter = function (targetNode, afterNode) {\n  var beforeNode = afterNode.nextElementSibling;\n  if(beforeNode) {\n    this.insertBefore(targetNode, beforeNode);\n  }else{\n    this.appendChild(targetNode);\n  }\n}\n```\n\n\n2. 将目标节点内部的节点顺序逆序。\neg:\n```\n<div> <a></a> <em></em></div> \n<div><em></em><a></a></div>\n\nElement.prototype.reverse = function (dom) {\n  var len = this.length;\n  for(var i = 0; i < len; i ++) {\n    this.\n\n  }\n\n}\n```\n\n\n\n# 作业区：\n\n1. 遍历元素节点树，要求不能用children属性\n```\n <div>\n   <span>\n     <p>\n\t<strong>\n\t  <em></em>\n\t</strong>\n     </p>\n   </span>\n </div>\n\nvar div = document.getElementByTagName('div')[0];\nfunction retElementChild(node) {\n  var temp = {\n     length : 0,\n     push : Array.prototype.push,\n     splice : Array.prototype.splice\n  },\n      child = node.childNodes,\n      len = child.length;\n  for(var i = 0; i < len; i ++) {\n     if(child[i].nodeType === 1) {\n\ttemp.push(child[i]);\n     }\n  }\n}\n\nretElement(div)\n```\n2. 封装函数，返回元素e的第n层祖先元素\n```\n <div>\n   <span>\n     <p>\n\t<strong>\n\t  <em></em>\n\t</strong>\n     </p>\n   </span>\n </div>\n\nfunction retParent(elem, n) {\n  while(n && elem) {\n    elem = elem.parentElement;\n    n --;\n  }\n  return elem;\n}\n```\n\n3. 封装函数，返回元素e的第n个兄弟元素节点，n为正，返回后面的兄弟元素节点，n为负，返回前面的，n为0，返回自己。\n```\n <div>\n   <span>\n     <p>\n\t<strong>\n\t  <em></em>\n\t</strong>\n     </p>\n   </span>\n </div>\n\nfunction retSibing(e, n) {\n  while(n && e) {\n    if(n > 0) {\n\tif(e.nextElementSibling) {\n          e = e.nextElementSibling;\n\t}else{\n\t  for(var e = e.nextSibling; e && e.nodeType != 1; e = e.nextSibling);\n\t}\n\tn --;\n    }else{\n\tif(e.previousElementSibling) {\n\t  e = e.previousElementSibling;\n\t}else{\n\t  for(var e = e.previousSibling; e && e.nodeType != 1; e = e.previousSibling);\n\t}\n\tn ++;\n    }\n  }\n  return e;\n}\n```\n4. 编辑函数，封装children功能，解决以前部分浏览器的兼容性问题,就是用自己的方法实现children方法。\n```\n <div>\n   <span>\n     <p>\n\t<strong>\n\t  <em></em>\n\t</strong>\n     </p>\n   </span>\n </div>\n\nvar div = document.getElementsByTagName('div')[0];\nElement.prototype.myChildren = function () {\n var child = this.childNodes,\n     len = child.length,\n     arr = [];\n for(var i = 0；i < len; i ++) {\n    if(child[i].nodeType == 1) {\n\tarr.push(child[i]);\n    }\n }\n return arr;\n}\ndiv.myChildren();    结果为：[span]\n```\n\n5. 自己封装hasChildren()方法，不可用children属性。如果有元素节点返回true，如果没有返回false。\n```\n <div>\n   <span>\n     <p>\n\t<strong>\n\t  <em></em>\n\t</strong>\n     </p>\n   </span>\n </div>\nvar div = document.getElementsByTagName('div')[0];\nElement.prototype.hasChildren = function () {\n  var child = this.childNodes,\n      len = child.length,\n      arr = [];\n  for(var i = 0; i < len; i ++) {\n     if(child[i].nodeType == 1) {\n\treturn true;\n     }\n  }\n  return false;\n}\n\ndiv.hasChildren();   结果：true;\n```","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"CSS小技巧","url":"/2017/11/CSS技巧.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n清除浮动元素的技巧解析:\ndisplay:block;\nheight:0;\nline-height:0;\ncontent:' ';\nclear:both;\nvisibility:hidden;\n这些是设置在元素的伪元素上的，比如要是想在当前元素的后面设置清除浮动，那就设置元素的:after设置上面的属性；要是想在当前元素的前面清除浮动，那就设置当前元素的:before上设置前面的属性。","tags":["CSS"],"categories":["学习笔记"]},{"title":"使用CSS3开启GPU硬件加速提升网站动画渲染性能","url":"/2017/11/CSS3中transform的加速问题.html","content":"\n** {{title}} ** <Excerpt in index | 首页摘要>\n\n今天再来说一下CSS3中的新特性，transform。说他之前先来解释图片中的两个格式的区别：PNG8和PNG24。\n# png8\n每一张“png8”图像，都最多只能展示256种颜色，所以“png8”格式更适合那些颜色比较单一的图像，例如纯色、logo、图标等；因为颜色数量少，所以图片的体积也会更小；\n# png 24\n每一张“png24”图像，可展示的颜色就远远多于“png8”了，最多可展示的颜色数量可多达1600万；所以“png24”所展示的图片颜色会更丰富，图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以“png24”的图片比较适合像摄影作品之类颜色比较丰富的图片；\n\n所以一些网站如果需要加载一些很大的PNG24类型的图片的话，那么图片加载的时间就会有点长甚至导致网站出现卡顿现象，进而影响用户体验。我们如何解决这个问题呢？或者说如何优化这个麻烦呢？这就需要我们今天要说到的CSS3中的transform属性了。为什么添加这个属性之后就会提升性能呢？因为为动画DOM元素添加CSS3样式-webkit-transform:transition3d(0,0,0)或-webkit-transform:translateZ(0);，这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画时从CPU转向GPU，其实说白了这是一个小伎俩，也可以算是一个Hack，-webkit-transform:transition3d和-webkit-transform:translateZ其实是为了渲染3D样式，但我们设置值为0后，并没有真正使用3D效果，但浏览器却因此开启了GPU硬件加速模式。\n　　这种GPU硬件加速在当今PC机及移动设备上都已普及，在移动端的性能提升是相当显著地，所以建议大家在做动画时可以尝试一下开启GPU硬件加速。\n\n当然也可以这样开启所有浏览器的GPU硬件加速：\n\n>-webkit-transform: translateZ(0);\n-moz-transform: translateZ(0);\n-ms-transform: translateZ(0);\n-o-transform: translateZ(0);\ntransform: translateZ(0);\n\n或者：\n\n>-webkit-transform: translate3d(0,0,0);\n-moz-transform: translate3d(0,0,0);\n-ms-transform: translate3d(0,0,0);\n-o-transform: translate3d(0,0,0);\ntransform: translate3d(0,0,0);\n\n但是我们要注意的是：开启GUI加速之后，会出现一些意想不到的BUG问题。当你有多个position:absolute;元素添加-webkit-transform:transition3d(0,0,0);开启GPU硬件加速之后，会有几个元素凭空消失，调试许久无果遂Google之，国内暂时没有人发表过关于这类问题的文章，于是在国外网站找呀找，找到了很多与我遇到同样问题的人，但都没有真正靠谱的解决办法，这可能是跟添加-webkit-transform之后chrome尝试使用GPU硬件加速有关系。\n在使用-webkit-transform尝试对很多DOM元素编写3D动画时，尽量不要对这些元素及他们的父元素使用position:absolute/fixed。(其实这种情况很难避免)\n\n通过-webkit-transform:transition3d/translateZ开启GPU硬件加速之后，有些时候可能会导致浏览器频繁闪烁或抖动，可以尝试以下办法解决之：\n>-webkit-backface-visibility:hidden;\n-webkit-perspective:1000;\n\n通过-webkit-transform:transition3d/translateZ开启GPU硬件加速的适用范围：\n\n1. 使用很多大尺寸图片(尤其是PNG24图)进行动画的页面。\n2. 页面有很多大尺寸图片并且进行了css缩放处理，页面可以滚动时。\n3. 使用background-size:cover设置大尺寸背景图，并且页面可以滚动时。(详见: <https://coderwall.com/p/j5udlw> )\n4. 编写大量DOM元素进行CSS3动画时(transition/transform/keyframes/absTop&Left)\n5. 使用很多PNG图片拼接成CSS Sprite时","tags":["CSS3"],"categories":["学习笔记"]},{"title":"CSS3选择器的使用方法","url":"/2017/11/CSS3-选择器的使用.html","content":"\n## 属性选择器\n增加了可以使用正则匹配属性名的方法：\nE[att^=“val”] {…}  选择匹配元素E, 且E元素定义了属性att, 其属性值以val开头的任何字符串\nE[att$=“val”]{…}选择匹配元素E, 且E元素定义了属性att, 其属性值以val结尾的任何字符串\nE[att*=“val”]{…}选择匹配元素E, 且E元素定义了属性att, 其属性值任意位置出现了“val”。即属性值包含了“val”，位置不限。\n\n\n## 初级伪类选择器：伪类用于向某些选择器添加特殊的效果。\n### 1.root 根标签选择器\n“:root”选择器等同于<html>元素，简单点说：\n:root{background:orange}\nhtml{background:orange}\n得到的效果等同\n建议使用:root（xml等）\n### 2.not 否定选择器\n用法和jQuery 中的not类似，可以排除某些特定条件的元素\ndiv:not([class=“demo”]){\nbackground-color:red;\n}\n意思为除了class为demo的div以外，所有的div的背景颜色都变红\n### 3.empty 空标签选择器\n用来选择没有内容的元素、不在文档树中的元素，这里的没有内容指的是一点内容都没有，哪怕是一个空格。\n### 4.target 目标元素选择器\n用来匹配被location.hash 选中的元素(即锚点元素)\n选择器可用于选取当前活动的目标元素，被设置为锚点的元素被锚点之后就可以显示相应的css样式。\n### 5.:first-child 第一个子元素\n:last-child 最后一个子元素\n:nth-child(){} 第xxx个子元素，n代表变量自然数\n:nth-last-child(){}  从后往前数\n以上四个选择器均有弊端，即如果当前位置元素不是前面所修饰的元素，那么无效\n注：其父元素的第 N 个子元素，不论元素的类型。\n### 6.:first-of-type 第一个子元素\n:last-of-type 最后一个子元素\n:nth-of-type(){} 第xxx个子元素，n代表变量自然数\n:nth-last-of-type(){}  从后往前数\n此种选择器，限制了类型，即在所修饰元素的类型下选择特定位置的元素。\n### 7 :only-child  唯一子元素选择器\n选择是独生子的子元素，即该子元素不能有兄弟元素，它的父元素只有他一个直接子元素。\n注意：选择的元素是独生子子元素，而非有唯一子元素的父元素。\n:only-of-type\n如果要选择第某类特定的子元素(p) 在兄弟节点中是此类元素唯一个的话 就需要用到这个属性了\n### 8 :enabled  可用的元素   :disabled 不可用的元素\n在web的表单中，有些表单元素有可用（“enabled”）和不可用（“disabled”）状态，比如输入框，密码框，复选框等。在默认情况下，这些表单元素都处在可用状态。那么我们可以通过伪类选择器 enabled 进行选择，disabled则相反。\n### 9:checked  选择框的被选中状态\n注：checkbox, radio 的一些默认状态不可用属性进行改变，如宽高颜色。\n### 10:read-only  选中只读的元素\neg:`<input type=“text” readonly=“readonly”/>`\n:read-write 选中非只读的元素\neg:`<input type=“text”/>`\n\n##### 扩张内容：伪类与伪元素的区别\n>伪类的效果可以通过添加一个实际的类来达到。\n>伪元素的效果则需要通过添加一个实际的元素才能达到。\n>这也是为什么他们一个称为伪类，一个称为伪元素的原因。\n\n## 伪元素选择器\nCSS3对伪元素进行了一定的调整，在以前的基础上增加了一个:也就是现在变成了::first-letter,::first-line,::before,::after\n另外还增加了一个::selection\n### 1.::selection\n“::selection” 选择器是用来匹配突出显示的文本（用鼠标选择文本的时候）。浏览器默认情况下，用鼠标选择网页文本是以“蓝色的北京，白色的字体”显示的。\n属性：user-select: none;\n注：火狐下必须加-moz-\n-moz-::selection\n\n## 条件选择\nE > F  an F element child of an E element\n直接子元素\nE + F an F element immediately preceded by an E element \n后面的紧挨着的兄弟节点\nE ~ F an F element preceded by an E element\n后面的兄弟节点\n\n\n\n\n                                                 Author:By--Dexinser","tags":["CSS3"],"categories":["必备知识"]},{"title":"CSS3新增加的功能和属性方法--之选择器","url":"/2017/11/CSS3-简介.html","content":"\n# CSS3---选择器\n\n提供了更加强大且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状、角度等，可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等等等...\n\n  在CSS3的一些新特性或方法还没正式使用之前，有一些浏览器商为了竞争用户使用人数或者说是为了一些商业目的，在CSS3还没有正式通过使用时就在自家的浏览器上实现了CSS3新出的功能。而这些浏览器商为了显示出这是自家的浏览器上实现的CSS3新功能，所以他们就在新实现的CSS3功能的属性之前加上了自家的标志。添加的前缀标志如下：\n  在编写CSS3样式时，不同的浏览器可能需要不同的前缀。它表示该CSS属性或规则尚未成为W3C标准的一部分，是浏览器的私有属性，虽然目前较新版本的浏览器都是不需要前缀的，但为了更好的向前兼容前缀还是少不了的。\n### 以CSS3新属性border-radius为例：\n> -webkit-border-radius          \n> Chrome和Safari\n> \n> -moz-border-radius    \n> Firefox\n> \n> -ms-border-radius         \n> IE\n> \n> -o-border-radius          \n> Opera\n\nCSS3新添加的属性方法有哪些?\n## 1\n添加圆角 -- border-radius 这是一个复合属性，分别为代表左上角、右上角、右下角、左下角；而且他们的所代表的左上角还是一个小的复合属性，又可以分成x轴和y轴的偏移量。 还有一种写法border-radius： 1em 2em 3em 4em / 2em 3em 4em 5em;\n## 2\n添加盒子阴影 --  box-shadow  这也是一个复合属性，是添加盒子阴影的方法。\nbox-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];  []里面的属性代表可以省略的属性。需要注意的是最后的一个可选属性即投影方式默认是outset投影方式，如果想设置成默认向外投影方式的话，一定注意不要把这个属性值写上去，写上去的话就不好使了，就没有阴影了，但是如果想改变投影方式为其他的形式需要写上去的。同一盒子，可以同时加多个阴影，阴影之间用“,”隔开。\n## 3\n添加文本阴影  text-shadow \n语法\ntext-shadow:X-Offset Y-Offset blur color;\nX-Offset：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移；\nY-Offset：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移\nBlur：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0；\nColor：是指阴影的颜色，其可以使用rgba色。\n## 4\n颜色值RGBA  再原先RGB的基础上添加了透明度这一参数。\n## 5\nCSS3的渐变分为两种\n1）线性渐变（linear - to）\n语法: linear-gradient([direction], color [percent], color [percent], …)\n[] 内为选填\ndirection角度的单位为 “deg” 也可以用to bottom, to left, to top left等的方式来表达\n2）径向渐变（radial - at）\n语法:radial-gradient(shape at position, color [percent] , color, …)\nshape:放射的形状，可以为原型circle，可以为椭圆ellipse\nposition: 圆心位置，可以两个值，也可以一个，如果为一个时，第二个值默认center 即 50%。值类型可以为，百分数，距离像素，也可以是方位值(left,top...); /*x 轴主半径 y轴次半径*/\n## 6\n文字边界换行\nword-wrap:normal|break-word;\n## 7\n可以下载网上的好看的字体想要引入的话就用下面的方式把下载到包用到我们的网页上，字体的包有很多格式，有的浏览器不支持某一种格式的话就换一种：\n`font-face\n@font-face{\nfont-family:”myFirstFont”;\nsrc:url('Sansation_Light.ttf'),\nurl(‘Sansation_Light.eot') format(‘eot’)；下载前面的优先选用\n}\n@font-face {\n    font-family: 'diyfont';\n    src: url('diyfont.eot'); /* IE9+ */\n    src: url('diyfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n         url('diyfont.woff') format('woff'), /* chrome、firefox */\n         url('diyfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/\n         url('diyfont.svg#fontname') format('svg'); /* iOS 4.1- */\n}`\n[字体](http://www.w3cplus.com/content/css3-font-face) (字体包下载地址)\n[字体](www.dafont.com) (字体包下载地址)\n\n## 8\nborder-image方法--边框应用背景\nborder-image: url(xxx.png)  number \n               stretch 很好理解就是拉伸，有多长拉多长。有多远“滚”多远\n               repeat (和4角上 同等大小图片进行平铺  当边框中间区域长度不是4角图片大小的整数倍时 会被切割)\n               铺满(round)(4角上的图片 进行拉伸平铺  不会被切割)\n（共三个参数）\nnumber 为截取指定图片四周的宽度作为border的背景填充部分(截取图可按border-width 大小伸缩), number为一个数字时是复合写法。最后一个属性为border-image的展示策略\n\n## 9\n背景图片起始位置background-origin\n语法：\nbackground-origin ： border-box | padding-box | content-box;\n参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。\n\n## 10\n裁剪背景图片background-clip\n语法：\nbackground-clip ： border-box | padding-box | content-box | no-clip\n参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。background-clip默认值为border-box。\ntext : background-clip : text ;\n从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果。这个很炫哦~~\n注意：webkit独有属性，且必须配合text-fill-color属性\n`-webkit-background-clip:text;-webkit-text-fill-color:transparent;\ntext-fill-color:-webkit-background-clip;\n-webkit-background-clip: text;\n-webkit-text-fill-color:transparent;`\n\n## 11\n背景图片尺寸background-size\n设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。\n语法：\nbackground-size: auto | <长度值> | <百分比> | cover | contain\n取值说明：\n1. auto：默认值，不改变背景图片的原始高度和宽度；\n2. <长度值>：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；\n3. <百分比>：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；\n4. cover：用一张图片铺满整个背景，如果比例不符，则截断图片\n5. contain：尽量让背景内，存在一整张图片\n\n\n","tags":["CSS3"],"categories":["必备知识"]},{"title":"CSS3动画的使用方法","url":"/2017/11/CSS3-动画的使用.html","content":"# CSS3动画的使用方法\n\n## 形状变换  —   高级动画基础 \n\n### transform -- 可以实现元素的形状、角度、位置等的变化。\n他的值有很多种：\n#### 旋转：\nrotate(); 以x/y/z为轴进行旋转，默认为z\nrotatex(), rotatey(), rotatez(), rotate3d(x, y, z, angle) x, y, z --->\n#### 缩放：\nscale(); 以x/y为轴进行缩放\nscale(x, y) 接受两个值，如果第二参数未提供，则第二个参数使用第一个参数的值\nscalex(),scaley() 值是数字表示倍数，不加任何单位\nscalez()\nscale3d()  scale3d(sx,sy,sz)\n#### 扭曲：\nskew(); 对元素进行倾斜扭曲\nskew(x, y);接受两个值，第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认值为0\nskewx(), skewy()\n#### 平移：\ntranslate(); 可以移动距离,相对于自身位置。\ntranslate(x, [y])\ntranslatex(),translatey(),translatez(),translate3d(x, y, z)  正规的写法是XYZ都应该是大写的。括号里面的值可以是像素(px, %)  当不知道元素自身的宽高是应该用这个百分比法来进行居中处理(-50%,-50%);\n#### transform-origin 变换原点\n任何一个元素都有一个中心点，\n默认情况下，其中心点是居于元素x轴和y轴的50%处。配合缩放的方法来使用，根据中心点的位置进行缩放。\n\n#### transition  过渡动画\ntransition  属性是css3的一个复合属性，主要包括一下几个子属性\ntransition-property:指定过渡或动态模拟的css属性\ntransition-duration:指定过渡所需要的时间\ntransition-timing-function:指定过渡函数\ntransition-delay:指定开始出现的延迟时间\n\ntransition  过渡动画可以参与过渡的属性\n\n#### animation -- 动画铺垫\n动画关键帧 \n@keyframes \n\nanimation 动画会按照keyframes 关键帧里面指定的帧状态而过渡执行。\n0% - 100% 代表动画的时间过渡\n@keyframes demoMove{\n0%{ background-color:red;}\n10%{ background-color:green;}\n20%{ background-color:white;}\n50%{ width:200px;}\n100%{ height:200px;}\n\nanimation 属性为css3的复合属性，主要包括以下子属性\nanimation-name:  此属性为执行动画的 keyframe 名\nanimation-duration:此属性为动画执行的时间\nanimation-timing-function:指定过渡函数速率\nanimation-delay: 执行延迟时间\nanimation-direction: normal/reverse/alternate/alternate-reverse; \nanimation-iteration-count:infinite/number;\nanimation-fill-mode:forwards/backwards/both/none;\n\nanimation-iteration-count:\n            属性主要用来定义动画的播放次数。\n            n 播放次数\n            infinite 无限次\n       animation-direction:\n            属性主要用来设置动画播放方向\n            normal  默认值。动画按正常播放。    测试 »\n            reverse 动画反向播放。 测试 »\n            alternate   动画在奇数次（1、3、5...）正向播放，在偶数次（2、4、6...）反向播放。    测试 »\n            alternate-reverse   动画在奇数次（1、3、5...）反向播放，在偶数次（2、4、6...）正向播放。    测试 »\n\nanimation-play-state:\n            属性主要用来控制元素动画的播放状态。\n            running 播放\n            paused  暂停\n       animation-fill-mode:\n            属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：\n            none:\n                默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时，动画会反转到初始帧处\n                \n            forwards:\n                表示动画在结束后继续应用最后的关键帧的位置\n            backwards:\n                会在向元素应用动画样式时迅速应用动画的初始帧\n            both:\n                元素动画同时具有forwards和backwards效果\n\n\n\n\n\n\n\n","tags":["CSS3"],"categories":["必备知识"]},{"title":"Html标签举例","url":"/2017/11/code.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n## html标签举例\n这是我最最开始学习HTML的时候保存下来的第一个HTML文件\n```\n<!-- html:hyperText markup language! -->\n<html lang=\"zh-cmn,en\">\n<head>\n    <meta charset=\"utf-8\">    <!-- gb2312 gbk unicode utf:8-bit unicode transformation format万国码 -->\n\t<title>京东，惊动世界!</title>\n\t<!-- SEO  搜索引擎爬虫在html中写的lang=“zh-cmn,en”<meta name=\"description\" content=\"一段幸福的婚姻\">\n\t<meta name=\"keywords\" content=\"王宝强，马蓉\"> -->\n</head>\n<body>\n    <p>成段落展示1</p>\n    <p>成段落展示2</p>\n    <h1>head标题1自带加粗</h1>\n    <h3>head标题3自带加粗</h3>\n    <strong>加粗1</strong><!-- <b>加粗</b> -->\n    <em>斜体1</em><!-- <i>斜体2</i> -->\n    <address>段落加加粗</address><!-- <b><em>段落加斜体</em></b> -->\n    <del>原价50元 </del><!-- html不能掺和css的功能，样式、结构、功能相分离 -->\n    <div>相当于容器，没功能，没样式，自成段落</div><!-- 容器里面东西多的话加功能比较方便，规格化和绑定操作 -->\n    <span>容器</span>\n    <!-- 空格在编辑器中被认为是文字分隔符 -->\n   <!--  html编码,空格 -->&nbsp;\n   <!-- html编码，大于小于号 -->&gt;div&lt;\n   <br><!-- 单独出现的标签，和meta标签也是单独出现的，没有尾标签，既然是尾标签那写的内容就的写在标签内，包住内容，这是换行标签，相当于回车 -->\n   <ol type=\"I\" reversed=\"reversed\">\n   \t<li>west world</li>\n   \t<li>big bang</li>\n   \t<li>journey to the west</li>\n   </ol>\n   <ul type=\"square\">\n   \t<li>衣服</li>\n   \t<li>鞋包</li>\n   \t<li>帽子</li>\n   \t<li>眼镜</li>\n   </ul><!-- 很重要的，但凡是导航栏就是用ul做的，配合css样式做出来的 div配合span也能做，不过不好，为了维护下来比较方便，人为规范-->\n  <!--  <img style=\"width:100px;\" src=\"china.jpg\" alt=\"这是中国高清地图\" title=\"China map\"> -->\n  <!--1.网上的url\n   2.本地的绝对路径\n   3.本地的相对路径  -->\n   <!-- 注释的功能：1.注释记载下来 2.锁定错误，检查错误，挑错-->\n   <a href=\"http://www.baidu.com\">百度一下</a><!-- 超链接功能hyperlink    来源于anchor汽车抛锚，起初是当锚点作用的 -->\n   <!-- a标签的功能有：1.超链接  2.锚点   3.协议限定符  就是用javescript在herf里写代码例如：herf=javescript:while(1){alert('中毒了，哦也！！！')}   4.自动调用电话或者邮件功能 -->\n   <div style=\"width:100px;height: 100px;background-color:black;\" id=\"only\"></div>\n   <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>\n   <a href=\"#only\">原来你在这儿呢，找到你了吧！</a>\n   <table border=\"0px\" cellpadding=\"100px\" cellspacing=\"0px\" style=\"width:800px;height: 400px;\"><!-- border边线cellpadding內边距cellspacing表格空隙 -->\n   \t   <tr align=\"center\">\n   \t   \t <td colspan=\"3\">1</td>\n   \t   </tr>\n       <tr>\n   \t   \t <td>2</td>\n   \t   \t <td>2</td>\n   \t   \t <td>2</td>\n   \t   </tr>\n       <tr>\n   \t   \t <td colspan=\"3\">3</td>\n   \t   </tr>\n   </table>\n   <!-- 写一个网站就需要一个服务器，网站就在服务器里面的一个地址，用户访问这个网站的话就需要下载这个网站的文件，但是用表格做的网页的话浏览器的加载方式是全部下载完并且执行，完成渲染之后才能展示这个网页。所以加载太慢用户体验差就不用了 -->\n   <!-- 前端fe(front end engnieer) 后端rd form前端向后端要信息的功能,发送信息的method中有俩值get|post,给谁后端发送信息的地址action。发送信息必要的2个东西：数据名(name)和数据值(用户提交的数据).有很多input组件，是单标签，里面必须有属性映衬type-->\n   <form method=\"get\" action=\"file:///file:///E:/duyi/message.html\">\n          <p>\n             username:<input type=\"text\" name=\"username\" value=\"请输入关键字\" style=\"color:#999\" onfocus=\"if(this.value=='请输入关键字'){this.value='';this.style.color='#424242'}\" onblur=\"if(this.value==''){this.value='请输入关键字';this.style.color='#999'}\">\n          </p>\n          <p>\n          \t  password:<input type=\"password\" name=\"password\"></input>\n           </p>\n      <input type=\"submit\"></input>\n         <!-- <h1>你们喜欢吃啥水果？(单选框)</h1>\n         <p>1.Apple<input type=\"radio\" name=\"fruit\" value=\"苹果\"></input></p>\n         <p>2.orange<input type=\"radio\" name=\"fruit\" value=\"橙子\"></input></p>\n         <p>3.banana<input type=\"radio\" name=\"fruit\" value=\"香蕉\"></input></p>\n      <input type=\"submit\"></input>\n      <h1>你有什么喜欢的运动？(多选)</h1>\n      <p>1.跑步<input type=\"checkbox\" name=\"yundong\" value=\"paobu\"></input></p>\n      <p>2.骑行<input type=\"checkbox\" name=\"yundong\" value=\"qixing\"></input></p>\n      <p>3.旅游<input type=\"checkbox\" name=\"yundong\" value=\"lvyou\"></input></p>\n      <input type=\"submit\"></input>\n      <h1>CHOOSE YOUR SEX!</h1>\n      <p>\n         1.female<input type=\"radio\" name=\"sex\" value=\"female\" checked=\"checked\"></input></p>\n      <p>\n         2.male<input type=\"radio\" name=\"sex\" value=\"male\" checked=\"checked\"></input></p>\n      <input type=\"submit\"></input> -->\n     <h1>直辖市</h1> \n      <select name=\"直辖市\">\n      \t<option value=\"beijing\">北京市</option>\n      \t<option value=\"beijing\">上海市</option>\n      \t<option>天津市</option>\n      </select>   <!-- 下拉菜单，选择用户所在省份,不用填value，填了以value为主，选票可以作弊.. -->\n   </form>\n</body>`\n</html>`\n```","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"Book","url":"/2017/11/book.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n我作为一个过来人(笑cry)，告诫你们年轻人，晚上不要熬夜，白天要好好学习，一定要多读书。。。\n《钢铁是怎样炼成的》为何如此出名？他告诉我们的道理不就是：生命只有一次，一定不要虚度光阴，世间好玩的事情太多，永远不要让虚妄的东西迷住了你的双眼，要努力探索新的知识，书山有路勤为径，学海无涯苦做舟；我也希望：当我到老年回收往事时，能不因我年少的虚度光阴而悔恨，不因碌碌无为而懊恼，我能展现最睿智的笑容，笑着对我的儿孙们说，爷爷这一辈子知足了！笑着合上我的双眼，满意的离开人世~\n\n年轻人在一定要注意身体，身体是革命的本钱，就算要玩游戏，就玩玩与现实中真正的人一块玩游戏，不要太过沉迷玩儿手机游戏或者电脑游戏。多出去走走，看看人世间的美好山河，多与人交流，感受人与人之间的淳朴之情。我这辈子的一大憾事就是不能把这个世界转遍了啊！！！希望你们可以做到哦~~~\n\n早上多运动，记得吃早饭，不要睡懒觉，更不要不睡觉，晚上好好睡觉，白天好好学习。\n永远不要满足于目前自身所具备的一点小才能，要不断求知，不断探索，世界上未知的东西如此之多，我都有点儿懊恼我为什么不能把这些东西全学完了呢？哎，让我再活500年，我要把全世界上的东西全部学完！！！我还不要睡觉，我要学习，我还不要死去，我要学习，我还不要吃饭，我要学习...生而为人已是我这辈子最大的满足，我还有什么不知足的，有爱我的家人，爷爷奶奶爸爸妈妈哥哥嫂嫂弟弟妹妹，我有这么多疼我爱我关心我懂我...的亲人，我真的是世界上最幸福的人~~~哈哈哈。好开心","tags":["book"],"categories":["个人随笔"]},{"title":"This Is Us","url":"/2017/11/2017.11.3-This is us-TV.html","content":"**{{ title }}** <Excerpt in index | 首页摘要>\n# People don't forget their 20s.\n说一下This is us 这部美剧吧！刚刚把昨天更新的S02E06看完了。这一集中讲述的挺真实的，讲的是兄妹三人在人生20s中遇到的种种挫折。兰德尔虽然在事业上获得了巨大的成功，成为了我们所说的成功人士，但是也有这个时期的烦恼或者说是压力，对任何事情都感到很茫然，除了工作。因为他的Tessa马上就要来到他的面前了，他害怕做不好一个父亲的职责..\n>Eastern wisdom is kind of a thing.\n>G(Garuda): -I will tell you one thing. I have five kids. And before first one was born, I was all questions, too. Can I? Will I? But they don't tell you is that babies come with the answers. They come out, they look up at you, and you at them, and...they tell you who you are. You'll see. Tomorrow you'll have all the answers you need.\n\n凯文和凯特过的都不好，凯文刚刚从父亲的阴影中走出来，而凯特依然沉浸在失去父亲的悲伤中，迟迟的不能走出悲伤接受事实..而丽贝卡也依然沉浸在过去之中，怀念着过去的丈夫..主要讲的是孩子们在人生中的20s这个时间段内所遇到的挫折..而捱过这段难熬的是家人之间的陪伴，又一次深深的被这部暖心剧所感动了。\n\n# Happening for us in the 20s.\n>Kevin: -Crushing the 20s.\n>Kate: -Crushing the 20s.\n>Kevin: -Bam. I haven't had an audition in, like, six months.\n>Kate: -The new guy is married.\n>Kevin: -Real--oh.\n>Kate: -Thanks. Have a little more.\n>Kevin: -Okay. Married, huh?\n>Kate: -Yeah.But he's nice, which makes it harder. He asks questions. He knows my class schedule.\n>Kevin: -I mean, come on, that's, you know, that's-that's a..that's a low bar.\n>Kate: -You really haven't had an audition in six months?\n>Kevin: -No, it's been more like a year, actually. Where are you at? I mean, what are you...You still sitting in your car, eating fast food, staring at where the house used to be? He's gone. Okey? And he's not coming back, and even if you sit there in the exact same spot that you were when he left, he's not...coming back.\n>Kate: -I know.\n>Kevin: -And he wouldn't want you to stay. Not if there was nothing for you there. You know what he'd want for you? Everything.\n>Kate: -Yeah, for you, too.\n>Kevin: -You know, maybe I'll take an acting class. I know it's...Or join a crappy improv troupe. I guess I could do that.\n>Kate: -That's the spirit. Yes. I bet you're hilarious.\n>Kevin: -I'm probably a pretty funny guy.\n\n# Life is not end, this monent is a new begining.\n>Rebecca: -Hi, little boy. I'm sorry it took me so long to get over here. I was really nervous to meet you. See...I talked to my other babies over there the whole time they were inside of me. But you weren't there, so...I want to come and introduce myself. And say hello and let you hear my voice.\n\n>Rebecca: -Hi, little sweet girl. I want to properly welcome you to the world. You are.. beautiful. Oh, my godness. I mean, all babies are beautiful, but you...you are Randall and Beth beautiful. And that is special. You know...I've been here before, Tess. You think you're at the beginning of your journey, right? But you also began a long time age. Do you know that? 'Cause I was there, and somebody else was there, too. Somebody really good. And we lost a baby, and we thought it was an ending, but...it was also a beginning.'\n\n>Rebecca: -Do you see those guys over there? That's your brother and sister. That's Kevin and Kate. And the man, the sweet man who fed you this afternoon. That's your dad.\n\n>Rebecca: -And life has a middle, too, and middles can be the hardest because...that's when you can get really lost. But middles can be beginning sometimes. And if you're lucky, you can have it all. And you...are lucky. You are the luckiest, prettiest, sweetest baby ever named after a ceiling fan.\n\n>Rebecca: -I think I...forgot to introduce myself. I'm your mom.\n\n>Rebecca: -You know, I thought my journey had come to an end, but I don't know. I don't know. Maybe...maybe we're both at out next beginning.\n\nAlways be a good man. Cause life is amazing. You don't know what is the time of moving coming.\n生活如此美好，引无数英雄竞折腰。\n\n慢慢都会变好的~~~","tags":["TV"],"categories":["moving"]},{"title":"第一次就把事情做好！","url":"/2017/11/2017.11.2-第一次就把事情做好.html","content":"\n**{{title}}** <Excerpt in index | 首页摘要>\n\n今天早上第一节上的是质量管理的课程。质量管理学的郝红军老师马上就要退休了，我们好像是他的最后一届的学生了，想到这个，真的是有点儿伤感...因为这个老师真的是太好了，无论是从做人上还是做事上，都教给了我们很多道理。说几个印象最深的事情吧！\n\n1. 真正的老师\n记得有次课上，课堂作业是每一组的小组成员上前简单介绍一下本次作业中的各小组成员分工和作业内容。有一个小组做的调查是：论当代大学生的上课缺勤情况分析。小组成员在介绍发生这种事情的原因时，先说明了关于学生自身的原因，后又说了关于老师的原因；老师方面的原因中说到了：老师对待学生不公平、老师责任心差、老师讲课不生动毫无生趣和老师性格特点方面的一些问题等等。说到这里，质量管理学的老师拍着胸脯大声地说到：我作为一个老师，敢说我决定没有那些问题，我对待每一个学生肯定不会有偏差，我对得起老师这两个字！！！在我的印象中，他真的是这样的一个老师。虽然这学期的课程中，数质量管理学的老师留的作业多，任务重；但是，他是真心实意的想让我们学习到一些真正的东西，毫不保留的教给我们一些重要的道理。\n\n2. 精神上的鼓励\n从我见到质量管理学老师的第一面开始，看到的都是一个乐观豁达，不断进取的一个精神头高涨的和蔼可亲的老师。真的，不管你什么时候见到他，他总是笑眯眯的样子，真的是让人有种亲切的感觉。上课的时候声音洪亮，做事的时候非常认真；对于自己不懂的地方，敢于承认自己的不足；没有一些老师的那种架子，但是他真的非常有实力哦~在质量管理学这方面，一直在学习，不像其他的老师，教的每一届的学生都是一样的教材，一样的内容，从来不去学习新得知识，这样的老师你怎么还能教给学生那种自学的能力呢？你自己都没有做到不断充实自己，而且是在你自己的专业领域中，你又有什么资格去指导别人呢？他教给我们的不止书本上的知识，作为一个快要退休的老师，有着丰富经历与见解的优秀教师，他总是会告诉我们一些生活中的道理，给我们指导人生的方向；遇见这种老师也真是我们的幸运吧！\n\n3. 道理语录\n该回到写这篇文章的目的了。一次就把事情做好！出自我的质量管理学老师。他说，不光在在这门课程中要这样做，在生活中也要这样做。做事情的时候，要在首次就做好，考虑放方方面面真的不容易，所以我们就要做充分的准备。胸有成竹之时，万事可破之日！\n\n哎~感叹一下吧，为什么这门课非要开在大四呢？说真的，因为目前大部分的同学都在紧张的准备考研或者找工作，根本不能全身心的投入到当前的学习当中，往往是顾得了这头，顾不了那头了，所以更有可能的是两件事都干不好呢！这也只是我的一个小小的吐槽，优秀的人，不论多少件事都能有条不紊的处理好，总归自己是一个平常人，做不到统筹兼备啊！所以就该更加的努力咯！加油吧！大学马上就要结束了，好好珍惜当下的课程吧！尤其是还有这么好的老师的时候，努力努力再努力，没有把你压垮的挫折都会成为你成长中的丰富养料~\n","tags":["个人感悟"],"categories":["others"]},{"title":"CSS3---景深详解","url":"/2017/11/2017.11.1-CSS3-景深详解.html","content":"**{{ title }}** <Excerpt in index | 首页摘要>\n\n今天回顾一下我之前学习到的CSS3中的一些属性方法，感觉生疏了很多，技术种东西还是得多看、多练啊。要不然真是‘士别三日，当刮目相看’啊~我认识他，他不认识我了！哈哈哈，好了，下面我们就来回顾一下CSS3中比较好玩的一个属性方法---景深。说到景深这个词，他其实来源于摄影行业中的专业词汇，正好我也比较喜欢摄影~~~那就先来说一下这个次的意思吧！\n维基百科中是这样解释的：\n\n> **景深**（英语：Depth of field, DOF）景深是指相机对焦点前后相对清晰的成像范围。在光学中，尤其是录影或是摄影，是一个描述在空间中，可以清楚成像的距离范围。虽然透镜只能够将光聚到某一固定的距离，远离此点则会逐渐模糊，但是在某一段特定的距离内，影像模糊的程度是肉眼无法察觉的，这段距离称之为景深。当焦点设在超焦距处时，景深会从超焦距的一半延伸到无限远，对一个固定的光圈值来说，这是最大的景深。\n\n而在计算机中我们的视点是屏幕前方，也就是说景深越大，那么这个元素离我们越远。CSS3中这个属性的设置是：\n\n`.stage{\n    perspective: 500px;\n}`\n\n应用景深的元素成为“舞台元素”，舞台元素的所有后代元素都会受到他的影响，__如果后代中的元素也添加了perspective属性，效果会叠加而不是覆盖！__\n\n**需要额外注意的事项：rotateX()和translateX()、rotateZ()和translateZ()方法默认都是顺时针方向旋转的，而rotateY()和translateY()方法默认是逆时针旋转的。旋转之后的位移一般都是用transitionZ()来进行的，矩形面的正方向朝向哪儿就朝那方向进行平移的运动。**\n\n代码如下：\n\n`<div class=\"wrapper\">\n    <div class=\"demo\">\n        <div class=\"up\">Up</div>\n        <div class=\"down\">Down</div>\n        <div class=\"front\">Front</div>\n        <div class=\"back\">Back</div>\n        <div class=\"left\">Left</div>\n        <div class=\"right\">Right</div>\n    </div>\n</div>`\n\n`* {\n    margin: 0;\n    padding: 0;\n}\n.wrapper {\n    perspective: 500px;\n    border: 2px dashed rgba(0, 0, 0, 1);\n    width: 500px;\n    height: 500px;\n}\n.wrapper .demo {\n    transform-style: preserve-3d;\n    position: relative;\n    width: 500px;\n    height: 500px;\n    animation: move 8s linear infinite;\n}\n.wrapper .demo div {\n    position: absolute;\n    width: 200px;\n    height: 200px;\n    opacity: 0.6;\n    left: 50%;\n    top: 50%;\n    margin-left: -100px;\n    margin-top: -100px;\n    text-align: center;\n    font-size: 50px;\n    font-weight: 900;\n    line-height: 200px;\n}\n.wrapper .demo .up {\n    transform: translateY(-100px) rotateX(90deg);\n    background-color: rgba(0, 0, 255, .8);\n}\n.wrapper .demo .down {\n    background-color: rgba(0, 255, 0, .8);\n    transform: translateY(100px) rotateX(-90deg);\n}\n.wrapper .demo .front {\n    background-color: rgba(255, 0, 0, .8);\n    transform: translateZ(100px) rotateY(0deg);\n}\n.wrapper .demo .back {\n    background-color: rgba(122,122, 122, .8);\n    transform: translateZ(-100px) rotateY(180deg);\n}\n.wrapper .demo .left {\n    background-color: rgba(255, 255, 0, .8);\n    transform: translateX(-100px) rotateY(-90deg);\n}\n.wrapper .demo .right {\n    background-color: rgba(0, 255, 255, .8);\n    transform: translateX(100px) rotateY(90deg);\n}\n@keyframes move {\n    0% {\n        transform: rotateX(0) rotateY(0) rotateZ(0);\n    }\n    30% {\n        transform: rotateX(360deg) rotateY(180deg) rotateZ(180deg)\n    }\n    60% {\n        transform: rotateX(180deg) rotateY(360deg) rotateZ(180deg);\n    }\n    100% {\n        transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg);\n    }\n}`\n\n上面的是方法是没有按照之前说的旋转之后的位移用transitionZ()来实现的。所以上面的方法在实现上有点儿难理解。其实要想用CSS3组成矩形，可以用rotate旋转配合transition平移组合出很多种方法的。\n\n下面就用我之前说的旋转之后用transitionZ()来进行平移这种方法来完成。DOM结构还是之前的结构，CSS样式代码如下：\n\n`* {\n    margin: 0;\n    padding: 0;\n}\n.wrapper {\n    perspective: 500px;\n    border: 2px dashed rgba(0, 0, 0, 1);\n    width: 500px;\n    height: 500px;\n}\n.wrapper .demo {\n    transform-style: preserve-3d;\n    position: relative;\n    width: 500px;\n    height: 500px;\n    animation: move 8s linear infinite;\n}\n.wrapper .demo div {\n    position: absolute;\n    width: 200px;\n    height: 200px;\n    opacity: 0.6;\n    left: 50%;\n    top: 50%;\n    margin-left: -100px;\n    margin-top: -100px;\n    text-align: center;\n    font-size: 50px;\n    font-weight: 900;\n    line-height: 200px;\n}\n.wrapper .demo .up {\n    transform: rotateX(90deg) translateZ(100px);\n    background-color: rgba(0, 0, 255, .8);\n}\n.wrapper .demo .down {\n    background-color: rgba(0, 255, 0, .8);\n    transform: rotateX(-90deg) translateZ(100px);\n}\n.wrapper .demo .front {\n    background-color: rgba(255, 0, 0, .8);\n    transform: rotateY(0deg) translateZ(100px);\n}\n.wrapper .demo .back {\n    background-color: rgba(122,122, 122, .8);\n    transform: rotateY(180deg) translateZ(100px);\n}\n.wrapper .demo .left {\n    background-color: rgba(255, 255, 0, .8);\n    transform: rotateY(-90deg) translateZ(100px);\n}\n.wrapper .demo .right {\n    background-color: rgba(0, 255, 255, .8);\n    transform: rotateY(90deg) translateZ(100px);\n}\n@keyframes move {\n    0% {\n        transform: rotateX(0) rotateY(0) rotateZ(0);\n    }\n    30% {\n        transform: rotateX(360deg) rotateY(180deg) rotateZ(180deg)\n    }\n    60% {\n        transform: rotateX(180deg) rotateY(360deg) rotateZ(180deg);\n    }\n    100% {\n        transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg);\n    }\n}`\n\n这种方法比较简单，不用去考虑方向的问题了，因为每次旋转之后的平移方向都是不一样的。\n\n好了，以上就是今天的分享内容了。总之，技术还是要多用啊~很多牛人的厉害之处并不是他们有多聪明，而是他们有正确的方法和学习习惯，懂得积少成多不抛弃不放弃，从最简单的入手而且深入对技术底层原理的探讨与思考，技术永远不要只停留在使用层面，而要去深入的研究底层的原理，这样，终有一日我们也会成为一个技术大牛的~共勉~~~","tags":["CSS3"],"categories":["前端知识点"]},{"title":"科学上网","url":"/2017/10/2017.10.29-科学上网.html","content":"\n** {{ title }} ** <Excerpt in index | 首页摘要>\n\n# 墙外的世界总是吸引我们啊~\n\n前几天也提了一下，就是最近因为十九大的原因，国内大大小小的翻墙工具都不能用了，就算有极个别的能用的速度也大大不如以前了。而我之前一直用的好好的蓝灯，居然也挂掉了！！！悲催啊~因为之前一直在用蓝灯，非常方便的可以在墙内墙外随意转，但是电脑里唯一的一个翻墙工具挂掉之后我就连备选方案都没有了。我能怎么办呢？只能去网上再找一条通往墙外的世界的通道咯！可是网上关于翻墙的东西居然都不见了，在知乎上搜索翻墙，被告知是敏感词汇，没有出现任何结果，百度搜索结果也是这样的，之前所有的关于翻墙的文章都被清理干净了！这一下让我慌了，看来这次禁网不简单啊！有人说十九大胜利闭幕之后11月份就能科学上网了，之前的翻墙软件就会恢复了...但是我看这架势估计够呛能再给你恢复了啊~理想很丰满，但是显示很骨感啊！有希望是好的，但是不要太过期望好结果哦~不然失望就越大咯！\n好了，又说了一堆废话（哈哈哈）！接下来就讲一下现阶段如何科学上网吧。最好的方法就是尝试用I2P补种或者自己搭建SS/SSR；\n\n[id]:  'github address'\n\n今天看了一篇博文，里面提到了：\n> 强烈建议大家移除 CNNIC 根证书。方法在这：[移除方法](https://github.com/chengr28/RevokeChinaCerts)\nCNNIC：中国互联网络信息中心（China Internet Network Information Center）\n\n### I2P\nI2P（Invisible Internet Project即“隐形网计划”），是一项混和授权的匿名网络项目。I2P网络是由I2P路由器以大蒜路由方式组成的表层网络，建立于其上的应用程序可以安全匿名的相互通信。它可以同时使用UDP及TCP协议，支持UPnP映射。其应用包括匿名上网、聊天、撰写博客和档案传输。\n大蒜路由（Garlic routing）是洋葱路由的一个变体。而洋葱路由（英语：Onion routing）为一种在电脑网络上匿名沟通的技术。在洋葱路由的网络中，消息一层一层的加密包装成像洋葱一样的数据包，并经由一系列被称作洋葱路由器的网络节点发送，每经过一个洋葱路由器会将数据包的最外层解密，直至目的地时将最后一层解密，目的地因而能获得原始消息。而因为通过这一系列的加密包装，每一个网络节点（包含目的地）都只能知道上一个节点的位置，但无法知道整个发送路径以及原发送者的地址。而洋葱路由是由洋葱路由器来发送的，简单的说洋葱路由器就是一个类似于P2P原理的代理服务器，所有安装了洋葱路由的用户既是代理服务器的使用者也是代理服务器的提供者。洋葱路由器是由志愿者，花费自己的带宽建立起来的。洋葱路由器是一个工具集，各类组织和个人可以用它来增强自己在互联网上的安全性。 洋葱路由器 能够匿名化你的 Web 浏览与发布、即时通讯、IRC、SSH 和其他使用 TCP 协议的应用。 洋葱路由器同时提供了一个平台，软件开发人员能够在上面构建具有内建匿名性、安全性与隐私保护特性的新的应用程序。洋葱路由器的目标是抵御流量分析，流量分析是一种对网络的监视行为，这种行为会威胁个人的匿名与隐私，商业活动与业务关系的保密和国家的安全。通信在一个由称作洋葱路由器的服务器所构建的分布式网络上传输， 保护你以避免网站收集你的兴趣爱好，本地的、甚至是洋葱路由器上的窃听者阅读你的数据、了解你所访问的站点。\n我们现在已经知道了被称作洋葱路由的原因在于消息一层一层的加密包装成被称作洋葱数据包的数据结构，层数取决于到目的地中间会经过的节点数，每经过一个节点层会将数据包的最外层解密，因此任一个节点都无法同时知晓这个消息最初与最终的目的地，使发送者达到匿名的效果。为了发送洋葱数据包，发送消息者会从“目录节点”（directory node）提供的列表中选取一些节点，并以这些规划出一条被称作“链”（chain）或“线路”（circuit）的发送路径，这条路径将为传输数据包所用。为了确保发送者的匿名性，任一节点都无法知道在链中自己的前一个节点是发送者还是链上的另一节点；同理，任一节点也无法知道在链中自己的下一节点是目的地还是链上另一节点。只有链上的最后一个节点知道自己是链上最终节点，该节点被称作“出口节点”（exit node）。洋葱路由网络使用非对称加密，发送者从目录节点获得一把公开密钥，用之将要发送的消息加密并发送给链上的第一个节点，该节点又被称作入口节点（entry node）；其后与之创建连接和共享密钥。创建连接后发送者就可以通过这条连接发送加密过的消息至链上的第二个节点，该消息将只有第二个节点可以解密；当第二个节点收到此消息后，便会与前一个节点也就是入口节点同样的创建连接，使发送者的加密连接延伸到它，但第二个节点并不晓得前一个节点在链中的身份。之后按照同样原理，发送者通过入口节点和第二个节点的这条加密连接将只有第三个节点能解密的消息发送给第三个节点，第三节点同样的与第二个节点创建连接；借由重复相同的步骤，发送者能产生一条越来越长的连接，但在性能上仍有限制。当链上的连接都创建后，发送者就可以通过其发送数据并保持匿名性。当目的地回送数据时，链上的节点会通过同一条连接将数据回传，且一样对数据层层加密，但加密的顺序与发送者完全相反；原发送者收到目的地回传的数据时，将仅剩最内一层加密，此时对其解密就可拿到目的地回送的消息。\n传统互联网不被认为具有匿名性的一个理由为互联网服务供应商具有纪录和追踪各电脑间的连接能力；例如当有人访问一个特定网站时，往来的信息内容如密码等，虽然能通过像是HTTPS等加密连接方式保护让其他人无法得知内容，但是连接本身却仍会有纪录，包含何时创建连接，多少数据量被发送等。洋葱路由虽然能创建并隐藏两电脑之间的连接，使两者之间并无一个可分辨的直接连接，但仍会有上述的连接纪录问题。流量分析可借由搜索连接纪录的连接时间和数据传输量来试图判别潜在的一对发送者与接收者；例如当有人发送51KB的数据到一个未知的电脑，三秒后另一未知的电脑发送51KB的数据给一个特定的网站，则可以推断此人可能与该网站曾创建连接。此外还有一些原因可以让流量分析更加有效，包含节点的损坏或离开网络，以及当链已经因为定期重建而改变，但有些链上节点却仍在追踪此前创建的会话等。\n大蒜路由是洋葱路由的一种变体，其结合了I2P网络并将多份消息加密打包在一起，使其更难被攻击者以流量分析的方式破解。它将传输的原始数据拆散为加密数据包通过多条隧道交叉疏散传递，令攻击者的流量分析难上加难。在洋葱路由中一条或多条数据流的上传与下载共用一条隧道，而这种路由方式的上传与下载隧道相互独立而且两个方向上的隧道数量都可能>1，所以被称为大蒜路由。\n与洋葱路由的电路交换（Circuit Switching）相比，大蒜路由也称为封包交换（Packet Switching）方式。大蒜路由是I2P与Tor及其他隐私/加密网络的主要区别之一。\n\nI2P是可伸缩性强，具有自我组织与恢复能力的包切换匿名网络。其上运行有多种不同的匿名安全程序，各程序可以自行决定匿名性、延迟、流量平衡而不用考虑混淆式路由网络的具体实现。它们的数据活动可以与现有的I2P用户的匿名数据相混合。目前可用的程序包括全部典型的Internet应用 - 匿名网页浏览（Eepproxy），匿名网站（Eepsite），匿名博客与内容聚合（Syndie），匿名聊天（通过IRC、Jabber、I2P-QTMessanger），匿名文件传输（I2PSnark，Robert），匿名文件分享（I2Phex, iMule），匿名电子邮件（I2PMail+susiMail），匿名新闻组，及其他开发中的程序。与自由网或GNUnet上内容发布网络不同，I2P所提供的服务具有更强的交互性 - 从常规的Web搜索引擎，到论坛，博客，数据站点再到无需安装Tor / 自由网即可访问其中内容的网关。\n\nI2P做为消息机制为基础的中间件与这些匿名性程序协同工作 - 程序要求发送数据给某一加密标识（目标），I2P来处理并保证数据安全匿名的到达目标。I2P还带有易用的流封装库，可将I2P匿名消息转换为可靠有序的数据流传输，提供基于TCP协议的拥堵控制算法解决网络程序的宽带延迟问题。I2P同时有简易的SOCKS代理接口可以将现有的网络程序绑定于I2P网络中。这样做的意义并不大因为几乎所有普通应用程序都会向网络暴露有碍匿名性的敏感数据，除非对程序进行全面审计。为了方便使用，I2P为各种语言提供了一系列API，从而充分利用I2P的资源。\n\nI2P被设计为其他程序可以使用的匿名网络层。这些运行于I2P上的程序有的被捆绑在I2P的安装包中，有的需要自行下载。I2P控制台是一个Web界面，可以通过浏览器管理I2P路由器的运行，类似于现在大多数家用路由器的管理方式。\n\n接下来看一下另一种方法吧：自己搭建SS/SSR\n\n### 自己搭建SS/SSR\n这个就自己去网上找教程吧~这里就不赘述咯~哈哈哈。给大家推荐一个教程吧。讲的挺细的，小白应该都能看懂的~但是推荐购买国外的服务器，比较便宜哦~ [搭建SS/SSR教程](http://www.wuzuowei.net/7998.html)\n\n\n**另外给大家推荐一篇博文，里面福利多多哦~~~**\n[全平台科学上网工具集合](https://www.bennythink.com/all-platform-scientific-internet-all-in-one.html)\n里面包括你知道的，你不知道的各个工具，真是大饱眼福咯~~\nLantern、XX-Net、VPNGate、Psiphon3、Tor、i2P、Shadowsocks/ShadowsocksR、v2ray、goproxy、firefly 等。\n\n好了，就分享这么多啦~睡了睡了！好困啊！","tags":["资源分享"],"categories":["others"]},{"title":"Win10计算机系统相关系列问题","url":"/2017/10/2017.10.28-win10系统相关.html","content":"\n** {{ title }} ** <Excerpt in index | 首页摘要>\n\n前两天做了一下计算机系统，把我从买笔记本到现在一直在用的win7旗舰版系统升级成了win10系统了。这几天用着感觉还不错，主要是因为之前用win7系统的体验太差的缘故吧！win7系统开机速度实在太慢了，时间4分多钟，你敢信？一直懒得升级系统，一直拖到现在，终于升级完成了。做了一下系统也有挺多收获的，今天就总结一下这几天关于计算机操作系统方面学到的知识吧~\n首先呢，先说明一下Windows系统与Linux系统相比，并没有那么的不堪；好多人都说Windows系统，用着用着就变慢了，而Linux操作系统却没有这个问题；所以好多用Windows系统的童鞋们都非常的向往Linux系统，想着有money了赶紧入手一台...其实这个并不是因为Windows操作系统做的不好，而是作为普罗大众的我们不去了解计算机系统的底层知识，只是一味的听信别人的一家之言，然后再结合我们的真实遭遇，就信口开河的也去散播这些谣言~哈哈哈，想想其实我以前也是这个样子的~嗯，又让我相信了知识改变命运这个神圣真理了。\n好了，说了这么多了，让我们来看一下为什么Windows系统用着用着就慢了呢？而Linux系统却没有这种问题呢？这是因为这两个系统的内核有本质区别，Windows使用近似微内核的结构，外围驱动有相当一部分是通过注册services项目的方式加载的，所以，新增硬件、新装软件如果有sys文件需要加载，就要通过services项，导致开机时Windows内核代码加载时间会慢慢变长！回过头来再说一下这个services项是什么东东呢？Windows系统是通过注册表来存储系统和应用程序的设置信息的。早在Windows 3.0推出OLE技术的时候，注册表就已经出现。随后推出的Windows NT是第一个从系统广泛使注册表的操作系统。但是，从Microsoft Windows 95操作系统开始，注册表才真正成为Windows用户经常接触的内容，并在其后的操作系统中继续沿用至今。而这个services就是注册表中程序设置信息所存放的位置，在这个文件夹下的信息，有一些是开机启动项，有一些是开始之后延迟启动的。下载的一些应用程序需要添加到注册表里他的配置信息才能使用，但是有的程序我们卸载完成后，并不会销毁这些注册表里面的东西，所以说我们的笔记本就会慢慢变慢了。并不是这些定西不能删除，而是那些应用程序并没有设置删除选项，或者一些病毒类的软件故意篡改注册表信息导致电脑出现一系列的问题。\n而Linux系统采用的是宏内核结构，大部分驱动都包含在内核里，我相信Linux用户不会没事干去重编自己的内核玩，所以Linux内核加载时间是固定的。那么使用很长的时间计算机的开机时间也不会有特别明显的变化。\n\n顺带吐槽一下win10系统中我认为一些不足的地方吧。就是新建文本文档的编码方式依然不是utf-8格式编码的，曾经被这种格式坑的很惨，所以记忆犹新。为什么都到了win10系统了，文本文档还不是utf-8呢？哎，以后还得注意这个问题啊~\n\n重装系统之后，一些要重新配置的程序和文件，如：GitHub、个人博客，最让我感到难过的是，Google账号登不上去了，以前在浏览器中保存好的书签全都同步不了了，我在想什么时候才能让我们重新科学上网呢。十九大也胜利闭幕了，我们的科学上网时间是不是也快到来了呢？感觉这次的事情好像并没有那么简单的样子呢~","tags":["计算机系统"],"categories":["资源分享"]},{"title":"前端算法JavaScript代码实现","url":"/2017/11/前端算法代码实现.html","content":"\n** {{ title }} ** <Excerpt in index | 首页摘要>\n\n# 金山WPS公司前端笔试算法题\n\n今天是金山WPS公司在哈尔滨理工大学举办宣讲会的日子，宣讲会结束之后就进行了前端开发工程师的笔试。虽然我参加的宣讲会不多，做的笔试题更少，但是以前参加的每家公司出的笔试题都不是纯前端的题，总是会参杂一些计算机系统、数据库等等方面的知识，而今天做的这个笔试题却是纯前端的题，并且还都是前端基础题；虽然是基础题，看着这些题都知道甚至可以很熟练的运用，但是真正做起题来还是有点儿拿捏不准。归根结底还是自己的基础功不扎实啊，做起题来才知道自己还欠缺还多底层知识的理解。总之，还是应该多看书、多追究底层实现的原理，不能仅仅追求熟练运用，而应该懂得这是如何实现的。前路漫漫，还得更加努力才行啊！加油吧，少年~\n\n说了这么多，说一下遇到的问题吧，最后一道编程题的解题思路和答案。\n\n问题：实现两个有序数组的合并。\n\n`function merge(left, right) {\n    var lLen = left.length,\n        rLen = right.length,\n        il = 0,\n        ir = 0,\n        res = [],\n        mid = [];\n    while(il < lLen && rl < rLen) {\n        if(left[il] > right[ir]) {\n            res.push(right[ir++])\n        }else{\n            res.push(left[il++])\n        }\n    }\n    mid = left[il] ? left.slice(il) : right.slice(ir);\n    return res.concat(mid);\n}`\n很简单的就实现了两个有序数组的合并。\n是不是很简单呢？\n\n# JavaScript算法\n\n既然说到排序了，那我们就来说一下JavaScript的排序算法的代码实现吧！\n\n1. 冒泡排序\n最最基础的是什么算法呢？当然是众所周知的冒泡排序算法了~\n那就先来实现一下它吧！\n\n`function bubbleSort(arr) {\n    var len = arr.length;\n    for(let i = 0; i < len; i++) {\n        for(let j = 0; j < len - 1 - i; j++) {\n            if(arr[j] > arr[j+1]) {\n                var temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n    return arr;\n}`\n用代码实现了冒泡排序，我们现在回过头来看看冒泡排序的时间复杂度吧~首先，冒泡排序用到的排序方法是穷举算法，也就是每一个数都要两两进行比较。这可以说是最容易让人理解的算法了，但是简单易懂换回的是计算机的处理效率的大大下降。因为计算量是很大的，所以这个算法的时间复杂度也是最大的；所以学习这个算法的目的也就是让我们去避免用到它，用高效的算法来替代它。\n时间复杂度：O(n²)的时间复杂度。\n\n2. 选择排序\n选择排序是表现最稳定的排序算法之一了，与冒泡排序一样用到的都是穷举算法。\n代码如下：\n\n`function selectionSort(arr){\n    var len = arr.length;\n    var minIndex, temp;\n    for(let i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for(let j = i + 1; j < len; j++) {\n            if(arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n}`\n\n与冒泡排序的方法类似，但是这个是从头开始排列的；应该尽量避免使用这个算法，因为这个也是最浪费性能的一个算法。\n时间复杂度：O(n²)的时间复杂度。\n\n3. 插入排序\n插入排序：类似打布克牌的时候新起上的牌放到手中已有的有序队列中；从当前手中牌的末尾开始比较，插入满足条件的位置中。\n代码如下：\n\n`funciton insertionSort(arr) {\n    var len = arr.length;\n    var perIndex, current;\n    for(let i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while(preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex + 1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex + 1] = current;\n    }\n    return arr;\n}`\n\n插入算法的时间复杂度：最差的情况下为O(n²)，即等于冒泡排序和选择排序的复杂度，但是一般不可能是最差的情况的，所以这个算法想比骄傲前两个来说性能上稍微提高了一点儿。既是时间复杂度<=O(n²)。\n\n4. 希尔排序\n希尔排序：是插入排序的一种更高效的实现；它与插入排序的不同之处在于，他会优先比较距离较远的元素。希尔排序的核心在于间隔排序的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。在这里，我就是用了这种方法。\n代码如下：\n\n`function shellSort(arr) {\n    var len = arr.length,\n        temp,\n        gap =  1;\n    while(gap < len / 3) {\n        gap = gap * 3 + 1;\n    }\n    for(gap; gap > 0; gap = Math.floor(gap / 3)) {\n        for(let i = gap; i < len; i++) {\n            temp = arr[i];\n            for(var j = i - gap; j > 0 && arr[j] > temp; j -= gap) {\n                arr[j + gap] = arr[j];\n            }\n            arr[j + gap] = temp;\n        }\n    }\n    return arr;\n}`\n\n时间复杂度：相比较上一种方法-插入排序，希尔排序自己定义好了间隔序列，这样就手动的排除了插入排序中最差的可能发生概率，进一步至少减少了1/4的比较运算相对于冒泡和选择排序而说。所以这是一种较优的算法。这个算法用到的思想就有点儿归并排序算法的影子了。接下来就让我们来看下一种算法-归并排序吧~\n\n5. 归并排序（合并排序）\n作为一种典型的分而治之的算法思想，归并排序的实现有两种方法：\n -自上而下的递归（递归方法可以用迭代重写）\n -自下而上的迭代\n","tags":["笔试"],"categories":["算法"]},{"title":"今日事","url":"/2017/10/2017.10.26今日事，古人的智慧.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n# 古人的智慧\n人们啊，有时候总是在错误的时间从事正确的事情，等我们到达了正确的时间却错过了我们应该从事的正确的事情，但是并不能说这是一个悲哀的事实，也许正是因为这样，才让我们明白了一些现实中的人生道理：珍惜当下，努力做好当下的事情，不要因为目前自身眼界的限制而看轻一些事情、道理、知识、人脉、友情、爱情、亲情等等的一些东西。为什么我会有这种感慨呢？因为正在走向而立之年，懂得了很多人情世故，稍微成长了一些吧；回想走过的路总是会叹息过去的自己的目光是如此的短浅，目之所及的浅显的道理都看不懂，可是如今再看目前的现阶段的自己，又何尝不是那个时候的有一个自己呢？所以说，不要怕或者说不要懊恼当下无知的自己，只要低下头，不停的前行，努力做好目前所应处理的问题，不要小看遇到的任何小问题，认真的处理好。质的成长永远都不是一瞬间就能做到的，古人说的好：不积小流无以成江海；不积硅步无以至千里；书山有路勤为径，学海无涯苦作舟；我认同这两句句中的坚持，我也非常认同坚持真的是一个人成功的关键，要想成功所必须要具备的品质。我想说的是什么呢？古人没有手机，没有电话，没有电脑，没有火车和飞机，但是他们追求的不是现代社会中经济的增长，他们追求的是哲学中真正的值得我们深思的问题，有些人穷其一生都在追求的东西，我们从哪儿来，我们生存的意义是什么，我们要到哪儿去？对啊，那个时候的人思想的很深刻，得出来很多真理名言，我们受国家义务教育这么多年，那些我们年少时，不屑一看、一读、一背的东西，显示中到头来总会给我们以深刻的打击，只有这个时候我们才认识到古人的智慧，所以说，骚年，多读书吧，少玩游戏，少浪费时间在一些不必要的事情上，纯粹点儿追求一些值得你追求的东西、你喜欢的东西、兴致所在才能坚持下去，才有可能成就一番伟业！","tags":["个人日记"],"categories":["个人感受"]},{"title":"个人日记","url":"/2017/10/2017.10.17个人日记.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n# 端正心态\n利用好时间，现在已经大四了，在大学里所剩的时间不多了，好好珍惜如今在学校的日子吧；身边的同学、老师，毕业之后可能再见就不知什么时候了；如今正是青春年华，你最好的时候，应该好好提升自己，充实自己；应届毕业生，现在说以后的成就，以后的梦想还是太早了，每个人都是相似的，你毕业不知所措，你毕业迷茫，对未来充满期待也好，对未来充满恐惧也罢，每个人都是差不多的感觉，也许我们现在的感知或者对未来的梦想是不真实的，因为我们并没有真正的在社会上历练过，有人说进入社会就会见到人与人之间的黑暗，见识到你以前所感到不可思议的东西，你不敢想象的事情的发生，不论怎样，我知道，只要我坚持初心，不忘了做人的基本准则，做好自己就好，能向人们传递一下感恩之心最好了，不能做到回报社会，起码我们应该做好我们自己，不忘初心，方得始终。\n# 努力努力再努力\n永远不要满足与当下自己所取得的小成就，不要羡慕别人所取得的成就，羡慕嫉妒恨真不是什么好的习惯哦~坚持自己选择的路，不是有一句话说的好吗？自己选择的路，就算是跪着、哭着、痛着也要走完；当然了，能够享受着最好了；累的时候就想一下这条路上的大牛们都在做什么，人家都在奋斗，你又有什么理由偷懒呢？最怕的就是你什么都不是还不思进取，永远记住比你厉害的人还比你努力，你怎么好意思去偷懒呢？\n# 不要说脏话\n有些人以说脏话为荣，我也不知道你的脑回路是什么样子的？就算是最好的朋友之间，难道除了脏话就不能有文明的话代表你的情感，抒发你的感受了吗？尤其受不了的是有些女生以说脏话为荣，好像说出来之后你的形象就立马高大上了是的？哎，别人怎么样，我不管也管不着，管好自己就好，管好你在意的人就好，希望我们都能在素养上得到提升吧！中国文化传承，礼仪上的传承是很重要的，我还后悔大学选修课没有选修礼仪的课程呢！以后自己学吧~\n# 兴趣\n有一句话说的好，兴趣是最大的老师；一个工作如果你失去了最初的兴趣，那这件工作也就到此终止了，就算你为了生活强撑下去到时最后的结局也不会太过美好的，我希望我能坚持我如今的兴趣，找到自己心仪的工作，按照我目前的规划前行，但是人生哪有那么美好呢？人生不如意事十之八九，学会处理好发生的意外才能快乐的生活，见识了人间的冷暖，才能够更好的享受人生！永远不要为自己所做出的坏事找借口，说什么以前也有人这么对过你，所以你现在就这么对别人！no，永远不要成为这样的人，好吗？做一个自己小时候想成为的人吧！你还记得吗？\n# 晚安\n多么美好的世界啊~生活本没有什么意义，但是我身边的亲人朋友们给了我生活的意义，让我发现生活中的阳光快乐竟是如此之多，我每时每刻都很珍惜流过的时光，感觉时间过得好快，朋友相处的时间太短，匆匆离别不是为了伤感，知识为了让我们以更好的姿态相聚，那时我们心与心的距离更短！加油吧！朋友们，人生太短，找到自己的目标不容易，那我们为什么不去实现他呢~加油，你的背后永远有一群支持你的人！永远不要怀疑自己，坚持自己的路你就胜利了。晚安世界~","tags":["个人日记"],"categories":["个人日记"]}]